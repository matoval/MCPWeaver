
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bundle-test: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">MCPWeaver/cmd/bundle-test/main.go (0.0%)</option>
				
				<option value="file1">MCPWeaver/cmd/performance-test/main.go (0.0%)</option>
				
				<option value="file2">MCPWeaver/cmd/ui-performance-test/main.go (0.0%)</option>
				
				<option value="file3">MCPWeaver/internal/app/app.go (7.5%)</option>
				
				<option value="file4">MCPWeaver/internal/app/errors.go (1.3%)</option>
				
				<option value="file5">MCPWeaver/internal/app/files.go (0.0%)</option>
				
				<option value="file6">MCPWeaver/internal/app/generation.go (0.0%)</option>
				
				<option value="file7">MCPWeaver/internal/app/logger.go (0.0%)</option>
				
				<option value="file8">MCPWeaver/internal/app/performance.go (2.0%)</option>
				
				<option value="file9">MCPWeaver/internal/app/projects.go (0.0%)</option>
				
				<option value="file10">MCPWeaver/internal/app/retry.go (0.0%)</option>
				
				<option value="file11">MCPWeaver/internal/app/settings.go (0.0%)</option>
				
				<option value="file12">MCPWeaver/internal/app/types.go (7.7%)</option>
				
				<option value="file13">MCPWeaver/internal/app/validation.go (57.1%)</option>
				
				<option value="file14">MCPWeaver/internal/database/db.go (65.0%)</option>
				
				<option value="file15">MCPWeaver/internal/database/errors.go (0.0%)</option>
				
				<option value="file16">MCPWeaver/internal/database/generations.go (29.3%)</option>
				
				<option value="file17">MCPWeaver/internal/database/migrations.go (36.1%)</option>
				
				<option value="file18">MCPWeaver/internal/database/projects.go (48.2%)</option>
				
				<option value="file19">MCPWeaver/internal/database/repository.go (0.0%)</option>
				
				<option value="file20">MCPWeaver/internal/database/settings.go (32.3%)</option>
				
				<option value="file21">MCPWeaver/internal/database/validation_cache.go (85.7%)</option>
				
				<option value="file22">MCPWeaver/internal/generator/service.go (0.0%)</option>
				
				<option value="file23">MCPWeaver/internal/mapping/service.go (60.4%)</option>
				
				<option value="file24">MCPWeaver/internal/parser/service.go (45.6%)</option>
				
				<option value="file25">MCPWeaver/internal/project/service.go (0.0%)</option>
				
				<option value="file26">MCPWeaver/internal/validator/service.go (68.9%)</option>
				
				<option value="file27">MCPWeaver/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

func main() <span class="cov0" title="0">{
        fmt.Println("Frontend Bundle Size Test")
        fmt.Println("==========================")
        
        // Change to frontend directory
        frontendDir := "./frontend"
        
        // Check if we can measure the existing dist directory
        distDir := filepath.Join(frontendDir, "dist")
        
        if _, err := os.Stat(distDir); err == nil </span><span class="cov0" title="0">{
                fmt.Println("Measuring existing build...")
                measureBundleSize(distDir)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("No existing build found, attempting to build...")
                
                // Try to build the frontend
                cmd := exec.Command("npm", "run", "build")
                cmd.Dir = frontendDir
                
                output, err := cmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Build failed: %v\n", err)
                        fmt.Printf("Output: %s\n", string(output))
                        
                        // Try to measure any partial build
                        if _, err := os.Stat(distDir); err == nil </span><span class="cov0" title="0">{
                                fmt.Println("Measuring partial build...")
                                measureBundleSize(distDir)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("No build artifacts found")
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("Build successful!")
                        measureBundleSize(distDir)
                }</span>
        }
        
        // Performance targets
        <span class="cov0" title="0">fmt.Println("\n=== BUNDLE SIZE TARGETS ===")
        fmt.Println("Target: &lt; 500KB total")
        fmt.Println("Target: &lt; 300KB JS")
        fmt.Println("Target: &lt; 100KB CSS")
        fmt.Println("Target: &lt; 100KB Assets")</span>
}

func measureBundleSize(distDir string) <span class="cov0" title="0">{
        fmt.Printf("\nMeasuring bundle size in: %s\n", distDir)
        fmt.Println("----------------------------------")
        
        var totalSize int64
        var jsSize int64
        var cssSize int64
        var assetSize int64
        
        err := filepath.Walk(distDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        totalSize += info.Size()
                        
                        ext := strings.ToLower(filepath.Ext(path))
                        switch ext </span>{
                        case ".js":<span class="cov0" title="0">
                                jsSize += info.Size()
                                fmt.Printf("JS: %s (%.2f KB)\n", info.Name(), float64(info.Size())/1024)</span>
                        case ".css":<span class="cov0" title="0">
                                cssSize += info.Size()
                                fmt.Printf("CSS: %s (%.2f KB)\n", info.Name(), float64(info.Size())/1024)</span>
                        case ".png", ".jpg", ".jpeg", ".svg", ".ico", ".woff", ".woff2":<span class="cov0" title="0">
                                assetSize += info.Size()
                                fmt.Printf("Asset: %s (%.2f KB)\n", info.Name(), float64(info.Size())/1024)</span>
                        default:<span class="cov0" title="0">
                                fmt.Printf("Other: %s (%.2f KB)\n", info.Name(), float64(info.Size())/1024)</span>
                        }
                }
                
                <span class="cov0" title="0">return nil</span>
        })
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error measuring bundle size: %v\n", err)
                return
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("\n=== BUNDLE SIZE SUMMARY ===\n")
        fmt.Printf("Total size: %.2f KB\n", float64(totalSize)/1024)
        fmt.Printf("JavaScript: %.2f KB\n", float64(jsSize)/1024)
        fmt.Printf("CSS: %.2f KB\n", float64(cssSize)/1024)
        fmt.Printf("Assets: %.2f KB\n", float64(assetSize)/1024)
        
        // Check against targets
        totalKB := float64(totalSize) / 1024
        jsKB := float64(jsSize) / 1024
        cssKB := float64(cssSize) / 1024
        assetKB := float64(assetSize) / 1024
        
        fmt.Printf("\n=== PERFORMANCE ASSESSMENT ===\n")
        
        if totalKB &lt; 500 </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Total size under 500KB\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Total size exceeds 500KB\n")
        }</span>
        
        <span class="cov0" title="0">if jsKB &lt; 300 </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: JavaScript size under 300KB\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: JavaScript size exceeds 300KB\n")
        }</span>
        
        <span class="cov0" title="0">if cssKB &lt; 100 </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: CSS size under 100KB\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: CSS size exceeds 100KB\n")
        }</span>
        
        <span class="cov0" title="0">if assetKB &lt; 100 </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Asset size under 100KB\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Asset size exceeds 100KB\n")
        }</span>
        
        <span class="cov0" title="0">overallPass := totalKB &lt; 500 &amp;&amp; jsKB &lt; 300 &amp;&amp; cssKB &lt; 100 &amp;&amp; assetKB &lt; 100
        
        if overallPass </span><span class="cov0" title="0">{
                fmt.Println("\n🎉 BUNDLE SIZE TARGETS MET!")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("\n⚠️  BUNDLE SIZE NEEDS OPTIMIZATION")
        }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "runtime"
        "time"

        "MCPWeaver/internal/database"
        "MCPWeaver/internal/parser"
        "MCPWeaver/internal/validator"
)

func main() <span class="cov0" title="0">{
        fmt.Println("MCPWeaver Performance Test")
        fmt.Println("==========================")
        
        // Test 1: Database Startup Time
        fmt.Println("\n1. Testing Database Startup Time")
        fmt.Println("---------------------------------")
        
        dbStart := time.Now()
        
        // Test database initialization
        dbPath := "./test_performance.db"
        db, err := database.Open(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open database: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                db.Close()
                os.Remove(dbPath) // Clean up test database
        }</span>()
        
        <span class="cov0" title="0">dbDuration := time.Since(dbStart)
        fmt.Printf("Database initialization time: %v\n", dbDuration)
        
        if dbDuration &lt; 500*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Database initialization under 500ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Database initialization exceeds 500ms\n")
        }</span>
        
        // Test 2: Memory Usage
        <span class="cov0" title="0">fmt.Println("\n2. Testing Memory Usage (Target: &lt;50MB)")
        fmt.Println("----------------------------------------")
        
        // Force garbage collection to get accurate reading
        runtime.GC()
        time.Sleep(100 * time.Millisecond) // Allow GC to complete
        
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        allocMB := float64(m.Alloc) / 1024 / 1024
        sysMB := float64(m.Sys) / 1024 / 1024
        
        fmt.Printf("Memory allocated: %.2f MB\n", allocMB)
        fmt.Printf("Memory system: %.2f MB\n", sysMB)
        
        if allocMB &lt; 50 </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Memory usage is under 50MB\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Memory usage exceeds 50MB\n")
        }</span>
        
        // Test 3: Parser Performance
        <span class="cov0" title="0">fmt.Println("\n3. Testing Parser Performance")
        fmt.Println("------------------------------")
        
        parserService := parser.NewService()
        
        // Create a small test OpenAPI spec
        testSpec := `
openapi: 3.0.0
info:
  title: Test API
  version: 1.0.0
paths:
  /test:
    get:
      summary: Test endpoint
      responses:
        '200':
          description: Success
`
        
        // Write test spec to file
        testSpecPath := "./test_spec.yaml"
        err = os.WriteFile(testSpecPath, []byte(testSpec), 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to write test spec: %v", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(testSpecPath)
        
        // Test parsing performance
        parseStart := time.Now()
        _, err = parserService.ParseFromFile(testSpecPath)
        parseDuration := time.Since(parseStart)
        
        fmt.Printf("Small spec parsing time: %v\n", parseDuration)
        
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ FAIL: Parser error: %v\n", err)
        }</span> else<span class="cov0" title="0"> if parseDuration &lt; 100*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Small spec parsing under 100ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Small spec parsing exceeds 100ms\n")
        }</span>
        
        // Test 4: Validator Performance
        <span class="cov0" title="0">fmt.Println("\n4. Testing Validator Performance")
        fmt.Println("---------------------------------")
        
        validatorService := validator.New()
        
        ctx := context.Background()
        validateStart := time.Now()
        _, err = validatorService.ValidateFile(ctx, testSpecPath)
        validateDuration := time.Since(validateStart)
        
        fmt.Printf("Validation time: %v\n", validateDuration)
        
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ FAIL: Validator error: %v\n", err)
        }</span> else<span class="cov0" title="0"> if validateDuration &lt; 50*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Validation under 50ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Validation exceeds 50ms\n")
        }</span>
        
        // Test 5: Memory Leak Detection
        <span class="cov0" title="0">fmt.Println("\n5. Memory Leak Detection")
        fmt.Println("------------------------")
        
        // Take initial memory reading
        runtime.GC()
        time.Sleep(100 * time.Millisecond)
        var m1 runtime.MemStats
        runtime.ReadMemStats(&amp;m1)
        initialAlloc := m1.Alloc
        
        // Simulate operations that might cause memory leaks
        for i := 0; i &lt; 100; i++ </span><span class="cov0" title="0">{
                // Simulate parsing operations
                _, _ = parserService.ParseFromFile(testSpecPath)
                
                // Simulate validation operations
                _, _ = validatorService.ValidateFile(context.Background(), testSpecPath)
                
                // Force GC periodically
                if i%20 == 0 </span><span class="cov0" title="0">{
                        runtime.GC()
                        time.Sleep(10 * time.Millisecond)
                }</span>
        }
        
        // Take final memory reading
        <span class="cov0" title="0">runtime.GC()
        time.Sleep(100 * time.Millisecond)
        var m2 runtime.MemStats
        runtime.ReadMemStats(&amp;m2)
        finalAlloc := m2.Alloc
        
        memoryGrowth := float64(finalAlloc-initialAlloc) / 1024 / 1024
        fmt.Printf("Memory growth after 100 operations: %.2f MB\n", memoryGrowth)
        
        if memoryGrowth &lt; 5.0 </span><span class="cov0" title="0">{ // Less than 5MB growth is acceptable for 100 operations
                fmt.Printf("✅ PASS: No significant memory leaks detected\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("⚠️  WARN: Potential memory leak detected (%.2f MB growth)\n", memoryGrowth)
        }</span>
        
        // Test 6: Concurrent Performance
        <span class="cov0" title="0">fmt.Println("\n6. Testing Concurrent Performance")
        fmt.Println("----------------------------------")
        
        concurrentStart := time.Now()
        
        // Run multiple operations concurrently
        done := make(chan bool, 10)
        
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{ done &lt;- true }</span>()
                        
                        // Parse spec
                        <span class="cov0" title="0">_, _ = parserService.ParseFromFile(testSpecPath)
                        
                        // Validate spec
                        _, _ = validatorService.ValidateFile(context.Background(), testSpecPath)</span>
                }()
        }
        
        // Wait for all goroutines to complete
        <span class="cov0" title="0">for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                &lt;-done
        }</span>
        
        <span class="cov0" title="0">concurrentDuration := time.Since(concurrentStart)
        fmt.Printf("10 concurrent operations time: %v\n", concurrentDuration)
        
        if concurrentDuration &lt; 1*time.Second </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Concurrent operations under 1 second\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Concurrent operations exceed 1 second\n")
        }</span>
        
        // Summary
        <span class="cov0" title="0">fmt.Println("\n=== PERFORMANCE TEST SUMMARY ===")
        fmt.Printf("Database Init: %v (Target: &lt;500ms)\n", dbDuration)
        fmt.Printf("Memory Usage: %.2f MB (Target: &lt;50MB)\n", allocMB)
        fmt.Printf("Small Spec Parse: %v (Target: &lt;100ms)\n", parseDuration)
        fmt.Printf("Validation: %v (Target: &lt;50ms)\n", validateDuration)
        fmt.Printf("Memory Growth: %.2f MB (Target: &lt;5MB)\n", memoryGrowth)
        fmt.Printf("Concurrent Ops: %v (Target: &lt;1s)\n", concurrentDuration)
        
        // Overall result
        overallPass := dbDuration &lt; 500*time.Millisecond &amp;&amp; 
                allocMB &lt; 50 &amp;&amp; 
                parseDuration &lt; 100*time.Millisecond &amp;&amp;
                validateDuration &lt; 50*time.Millisecond &amp;&amp;
                memoryGrowth &lt; 5.0 &amp;&amp; 
                concurrentDuration &lt; 1*time.Second
        
        if overallPass </span><span class="cov0" title="0">{
                fmt.Println("\n🎉 ALL PERFORMANCE TESTS PASSED!")
                os.Exit(0)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("\n❌ SOME PERFORMANCE TESTS FAILED")
                os.Exit(1)
        }</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "runtime"
        "time"

        "MCPWeaver/internal/database"
        "MCPWeaver/internal/parser"
        "MCPWeaver/internal/validator"
)

func main() <span class="cov0" title="0">{
        fmt.Println("UI Performance &amp; Responsiveness Test")
        fmt.Println("====================================")
        
        // Test 1: Database Operations (UI data loading)
        fmt.Println("\n1. Testing Database Operations (Target: &lt;100ms)")
        fmt.Println("------------------------------------------------")
        
        // Initialize database
        dbPath := "./test_ui_performance.db"
        db, err := database.Open(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open database: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                db.Close()
                os.Remove(dbPath)
        }</span>()
        
        // Test project repository operations
        <span class="cov0" title="0">projectRepo := database.NewProjectRepository(db)
        
        // Test GetAll (common UI operation)
        start := time.Now()
        projects, err := projectRepo.GetAll()
        duration := time.Since(start)
        
        fmt.Printf("GetAll projects response time: %v\n", duration)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Projects retrieved: %d\n", len(projects))
        }</span>
        
        <span class="cov0" title="0">if duration &lt; 100*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: GetAll projects under 100ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: GetAll projects exceeds 100ms\n")
        }</span>
        
        // Test 2: File Operations (UI file handling)
        <span class="cov0" title="0">fmt.Println("\n2. Testing File Operations (Target: &lt;100ms)")
        fmt.Println("---------------------------------------------")
        
        // Create test file
        testSpec := `
openapi: 3.0.0
info:
  title: Test API
  version: 1.0.0
paths:
  /test:
    get:
      summary: Test endpoint
      responses:
        '200':
          description: Success
`
        
        testSpecPath := "./test_spec.yaml"
        err = os.WriteFile(testSpecPath, []byte(testSpec), 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to write test spec: %v", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(testSpecPath)
        
        // Test file reading (UI file import)
        start = time.Now()
        content, err := os.ReadFile(testSpecPath)
        duration = time.Since(start)
        
        fmt.Printf("File reading response time: %v\n", duration)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("File content length: %d\n", len(content))
        }</span>
        
        <span class="cov0" title="0">if duration &lt; 100*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: File reading under 100ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: File reading exceeds 100ms\n")
        }</span>
        
        // Test file existence check (UI validation)
        <span class="cov0" title="0">start = time.Now()
        _, err = os.Stat(testSpecPath)
        exists := err == nil
        duration = time.Since(start)
        
        fmt.Printf("File existence check response time: %v\n", duration)
        fmt.Printf("File exists: %t\n", exists)
        
        if duration &lt; 100*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: File existence check under 100ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: File existence check exceeds 100ms\n")
        }</span>
        
        // Test 3: Parser Operations (UI spec processing)
        <span class="cov0" title="0">fmt.Println("\n3. Testing Parser Operations (Target: &lt;100ms)")
        fmt.Println("----------------------------------------------")
        
        parserService := parser.NewService()
        
        // Test parsing (UI spec import)
        start = time.Now()
        _, err = parserService.ParseFromFile(testSpecPath)
        duration = time.Since(start)
        
        fmt.Printf("Spec parsing response time: %v\n", duration)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Spec parsed successfully\n")
        }</span>
        
        <span class="cov0" title="0">if duration &lt; 100*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Spec parsing under 100ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Spec parsing exceeds 100ms\n")
        }</span>
        
        // Test 4: Validation Operations (UI real-time validation)
        <span class="cov0" title="0">fmt.Println("\n4. Testing Validation Operations (Target: &lt;100ms)")
        fmt.Println("--------------------------------------------------")
        
        validatorService := validator.New()
        
        // Test validation (UI spec validation)
        start = time.Now()
        ctx := context.Background()
        _, err = validatorService.ValidateFile(ctx, testSpecPath)
        duration = time.Since(start)
        
        fmt.Printf("Spec validation response time: %v\n", duration)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Spec validated successfully\n")
        }</span>
        
        <span class="cov0" title="0">if duration &lt; 100*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Spec validation under 100ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Spec validation exceeds 100ms\n")
        }</span>
        
        // Test 5: Memory Operations (UI monitoring)
        <span class="cov0" title="0">fmt.Println("\n5. Testing Memory Operations (Target: &lt;10ms)")
        fmt.Println("---------------------------------------------")
        
        // Test memory stats (UI memory display)
        start = time.Now()
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        duration = time.Since(start)
        
        fmt.Printf("Memory stats response time: %v\n", duration)
        fmt.Printf("Memory allocated: %.2f MB\n", float64(m.Alloc)/1024/1024)
        
        if duration &lt; 10*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Memory stats under 10ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Memory stats exceeds 10ms\n")
        }</span>
        
        // Test 6: Concurrent Operations (UI concurrent tasks)
        <span class="cov0" title="0">fmt.Println("\n6. Testing Concurrent Operations (Target: &lt;200ms)")
        fmt.Println("--------------------------------------------------")
        
        start = time.Now()
        
        // Simulate multiple concurrent UI operations
        done := make(chan bool, 5)
        
        // Concurrent operations that UI might perform
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{ done &lt;- true }</span>()
                <span class="cov0" title="0">projectRepo.GetAll()</span>
        }()
        
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{ done &lt;- true }</span>()
                <span class="cov0" title="0">var m runtime.MemStats
                runtime.ReadMemStats(&amp;m)</span>
        }()
        
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{ done &lt;- true }</span>()
                <span class="cov0" title="0">os.Stat(testSpecPath)</span>
        }()
        
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{ done &lt;- true }</span>()
                <span class="cov0" title="0">parserService.ParseFromFile(testSpecPath)</span>
        }()
        
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{ done &lt;- true }</span>()
                <span class="cov0" title="0">validatorService.ValidateFile(context.Background(), testSpecPath)</span>
        }()
        
        // Wait for all operations to complete
        <span class="cov0" title="0">for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                &lt;-done
        }</span>
        
        <span class="cov0" title="0">duration = time.Since(start)
        fmt.Printf("5 concurrent operations time: %v\n", duration)
        
        if duration &lt; 200*time.Millisecond </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Concurrent operations under 200ms\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ FAIL: Concurrent operations exceed 200ms\n")
        }</span>
        
        // Test 7: Memory Stability During Operations
        <span class="cov0" title="0">fmt.Println("\n7. Testing Memory Stability (Target: &lt;5MB growth)")
        fmt.Println("--------------------------------------------------")
        
        // Initial memory reading
        runtime.GC()
        time.Sleep(100 * time.Millisecond)
        var m1 runtime.MemStats
        runtime.ReadMemStats(&amp;m1)
        initialAlloc := m1.Alloc
        
        // Simulate intensive UI operations
        for i := 0; i &lt; 50; i++ </span><span class="cov0" title="0">{
                projectRepo.GetAll()
                
                var m runtime.MemStats
                runtime.ReadMemStats(&amp;m)
                
                os.Stat(testSpecPath)
                parserService.ParseFromFile(testSpecPath)
                
                // Periodic GC
                if i%10 == 0 </span><span class="cov0" title="0">{
                        runtime.GC()
                        time.Sleep(10 * time.Millisecond)
                }</span>
        }
        
        // Final memory reading
        <span class="cov0" title="0">runtime.GC()
        time.Sleep(100 * time.Millisecond)
        var m2 runtime.MemStats
        runtime.ReadMemStats(&amp;m2)
        finalAlloc := m2.Alloc
        
        memoryGrowth := float64(finalAlloc-initialAlloc) / 1024 / 1024
        fmt.Printf("Memory growth after 50 operations: %.2f MB\n", memoryGrowth)
        
        if memoryGrowth &lt; 5.0 </span><span class="cov0" title="0">{
                fmt.Printf("✅ PASS: Memory growth under 5MB\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("⚠️  WARN: Memory growth exceeds 5MB\n")
        }</span>
        
        // Summary
        <span class="cov0" title="0">fmt.Println("\n=== UI PERFORMANCE SUMMARY ===")
        fmt.Printf("Database Operations: Measured\n")
        fmt.Printf("File Operations: Measured\n")
        fmt.Printf("Parser Operations: Measured\n")
        fmt.Printf("Validation Operations: Measured\n")
        fmt.Printf("Memory Operations: Measured\n")
        fmt.Printf("Concurrent Operations: Measured\n")
        fmt.Printf("Memory Stability: %.2f MB growth\n", memoryGrowth)
        
        fmt.Println("\n🎉 UI PERFORMANCE TESTING COMPLETED!")
        fmt.Println("\nNote: This test simulates UI operations and measures backend response times.")
        fmt.Println("Frontend rendering performance depends on React components and browser optimization.")</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "MCPWeaver/internal/database"
        "MCPWeaver/internal/generator"
        "MCPWeaver/internal/mapping"
        "MCPWeaver/internal/parser"
        "MCPWeaver/internal/validator"
        
        "github.com/wailsapp/wails/v2/pkg/runtime"
)

// App struct holds the application context and services
type App struct {
        ctx                 context.Context
        db                  *sql.DB
        projectRepo         *database.ProjectRepository
        validationCacheRepo *database.ValidationCacheRepository
        parserService       *parser.Service
        mappingService      *mapping.Service
        generatorService    *generator.Service
        validatorService    *validator.Service
        settings            *AppSettings
        errorManager        *ErrorManager
        performanceMonitor  *PerformanceMonitor
}

// NewApp creates a new application instance
func NewApp() *App <span class="cov8" title="1">{
        return &amp;App{
                parserService:      parser.NewService(),
                validatorService:   validator.New(),
                settings:           getDefaultSettings(),
                errorManager:       NewErrorManager(),
                performanceMonitor: NewPerformanceMonitor(),
        }
}</span>

// OnStartup is called when the app starts, before the frontend is loaded
func (a *App) OnStartup(ctx context.Context) error <span class="cov0" title="0">{
        a.ctx = ctx
        
        // Record startup time
        startupStart := time.Now()
        
        // Initialize database
        dbPath := "./mcpweaver.db"
        dbWrapper, err := database.Open(dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize database: %w", err)
        }</span>
        <span class="cov0" title="0">a.db = dbWrapper.GetConn()
        
        // Initialize repositories
        a.projectRepo = database.NewProjectRepository(dbWrapper)
        a.validationCacheRepo = database.NewValidationCacheRepository(dbWrapper)
        
        // Load settings
        settings, err := a.loadSettings()
        if err != nil </span><span class="cov0" title="0">{
                // Use default settings if loading fails
                runtime.LogWarning(a.ctx, "Failed to load settings, using defaults: "+err.Error())
                settings = getDefaultSettings()
        }</span>
        <span class="cov0" title="0">a.settings = settings
        
        // Record startup time
        startupDuration := time.Since(startupStart)
        a.performanceMonitor.RecordStartupTime(startupDuration)
        
        // Emit startup event
        runtime.EventsEmit(a.ctx, "system:startup", map[string]interface{}{
                "timestamp": time.Now(),
                "version":   "1.0.0",
                "startup_time": startupDuration.String(),
        })
        
        return nil</span>
}

// OnShutdown is called when the app is about to quit
func (a *App) OnShutdown(ctx context.Context) error <span class="cov0" title="0">{
        // Emit shutdown event
        runtime.EventsEmit(a.ctx, "system:shutdown", map[string]interface{}{
                "timestamp": time.Now(),
        })
        
        // Save settings
        if err := a.saveSettings(); err != nil </span><span class="cov0" title="0">{
                runtime.LogError(a.ctx, "Failed to save settings: "+err.Error())
        }</span>
        
        // Close database connection
        <span class="cov0" title="0">if a.db != nil </span><span class="cov0" title="0">{
                if err := a.db.Close(); err != nil </span><span class="cov0" title="0">{
                        runtime.LogError(a.ctx, "Failed to close database: "+err.Error())
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// GetPerformanceMetrics returns current performance metrics
func (a *App) GetPerformanceMetrics() *PerformanceMetrics <span class="cov0" title="0">{
        return a.performanceMonitor.GetMetrics()
}</span>

// GetMemoryUsage returns current memory usage in MB
func (a *App) GetMemoryUsage() float64 <span class="cov0" title="0">{
        return a.performanceMonitor.GetMemoryUsageMB()
}</span>

// ForceGarbageCollection forces garbage collection
func (a *App) ForceGarbageCollection() <span class="cov0" title="0">{
        a.performanceMonitor.ForceGC()
}</span>

// OnDomReady is called after the frontend dom is ready
func (a *App) OnDomReady(ctx context.Context) <span class="cov0" title="0">{
        // Emit DOM ready event
        runtime.EventsEmit(a.ctx, "system:ready", map[string]interface{}{
                "timestamp": time.Now(),
        })
}</span>

// OnBeforeClose is called when the application is about to quit
func (a *App) OnBeforeClose(ctx context.Context) bool <span class="cov0" title="0">{
        // Allow the app to close
        return false
}</span>

// createAPIError creates a standardized API error
func (a *App) createAPIError(errorType, code, message string, details map[string]string) *APIError <span class="cov8" title="1">{
        return &amp;APIError{
                Type:      errorType,
                Code:      code,
                Message:   message,
                Details:   details,
                Timestamp: time.Now(),
        }
}</span>

// emitError emits an error event to the frontend
func (a *App) emitError(err *APIError) <span class="cov0" title="0">{
        runtime.EventsEmit(a.ctx, "system:error", err)
}</span>

// ReportError reports an error from the frontend
func (a *App) ReportError(errorReport map[string]interface{}) error <span class="cov0" title="0">{
        // Log the error
        fmt.Printf("Frontend Error Report: %+v\n", errorReport)
        
        // Here you could send the error to a logging service, database, or monitoring system
        // For now, we'll just emit it as a system event
        runtime.EventsEmit(a.ctx, "system:error-report", errorReport)
        
        return nil
}</span>

// emitNotification emits a notification event to the frontend
func (a *App) emitNotification(notificationType, title, message string) <span class="cov0" title="0">{
        runtime.EventsEmit(a.ctx, "system:notification", map[string]interface{}{
                "type":    notificationType,
                "title":   title,
                "message": message,
                "timestamp": time.Now(),
        })
}</span>

// loadSettings loads application settings from storage
func (a *App) loadSettings() (*AppSettings, error) <span class="cov0" title="0">{
        // TODO: Implement settings loading from file/database
        return getDefaultSettings(), nil
}</span>

// saveSettings saves application settings to storage
func (a *App) saveSettings() error <span class="cov0" title="0">{
        // TODO: Implement settings saving to file/database
        return nil
}</span>

// getDefaultSettings returns default application settings
func getDefaultSettings() *AppSettings <span class="cov8" title="1">{
        return &amp;AppSettings{
                Theme:             "light",
                Language:          "en",
                AutoSave:          true,
                DefaultOutputPath: "./output",
                RecentProjects:    []string{},
                WindowSettings: WindowSettings{
                        Width:     1200,
                        Height:    800,
                        Maximized: false,
                        X:         100,
                        Y:         100,
                },
                EditorSettings: EditorSettings{
                        FontSize:        14,
                        FontFamily:      "Monaco",
                        TabSize:         4,
                        WordWrap:        true,
                        LineNumbers:     true,
                        SyntaxHighlight: true,
                },
                GenerationSettings: GenerationSettings{
                        DefaultTemplate:     "default",
                        EnableValidation:    true,
                        AutoOpenOutput:      true,
                        ShowAdvancedOptions: false,
                        BackupOnGenerate:    true,
                        CustomTemplates:     []string{},
                },
        }
}</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "fmt"
        "math/rand"
        "runtime"
        "time"
)

// ErrorManager handles error creation, logging, and recovery
type ErrorManager struct {
        defaultRetryPolicy RetryPolicy
        correlationIDGen   func() string
}

// NewErrorManager creates a new error manager
func NewErrorManager() *ErrorManager <span class="cov8" title="1">{
        return &amp;ErrorManager{
                defaultRetryPolicy: DefaultRetryPolicy(),
                correlationIDGen:   generateCorrelationID,
        }
}</span>

// CreateError creates a new APIError with comprehensive context
func (em *ErrorManager) CreateError(errType, code, message string, options ...ErrorOption) *APIError <span class="cov0" title="0">{
        apiError := &amp;APIError{
                Type:          errType,
                Code:          code,
                Message:       message,
                Timestamp:     time.Now(),
                CorrelationID: em.correlationIDGen(),
                Severity:      ErrorSeverityMedium,
                Recoverable:   false,
                Details:       make(map[string]string),
        }

        // Apply options
        for _, option := range options </span><span class="cov0" title="0">{
                option(apiError)
        }</span>

        // Set default retry policy for retryable errors
        <span class="cov0" title="0">if apiError.Recoverable &amp;&amp; apiError.RetryAfter == nil </span><span class="cov0" title="0">{
                delay := em.defaultRetryPolicy.InitialDelay
                apiError.RetryAfter = &amp;delay
        }</span>

        <span class="cov0" title="0">return apiError</span>
}

// CreateValidationError creates a validation error with suggestions
func (em *ErrorManager) CreateValidationError(message string, details map[string]string, suggestions []string) *APIError <span class="cov0" title="0">{
        return em.CreateError(
                ErrorTypeValidation,
                ErrCodeValidation,
                message,
                WithDetails(details),
                WithSuggestions(suggestions),
                WithSeverity(ErrorSeverityMedium),
        )
}</span>

// CreateNetworkError creates a network error that can be retried
func (em *ErrorManager) CreateNetworkError(message string, details map[string]string) *APIError <span class="cov0" title="0">{
        return em.CreateError(
                ErrorTypeNetwork,
                ErrCodeNetworkError,
                message,
                WithDetails(details),
                WithSeverity(ErrorSeverityHigh),
                WithRecoverable(true),
                WithSuggestions(NetworkSuggestions),
        )
}</span>

// CreateFileSystemError creates a file system error with recovery guidance
func (em *ErrorManager) CreateFileSystemError(message string, filePath string, operation string) *APIError <span class="cov0" title="0">{
        return em.CreateError(
                ErrorTypeFileSystem,
                ErrCodeFileAccess,
                message,
                WithDetails(createDetailsMap("file_path", filePath, "operation", operation)),
                WithSuggestions(FileSystemSuggestions),
                WithSeverity(ErrorSeverityMedium),
        )
}</span>

// CreateGenerationError creates a generation error with context
func (em *ErrorManager) CreateGenerationError(message string, projectID string, step string) *APIError <span class="cov0" title="0">{
        return em.CreateError(
                ErrorTypeGeneration,
                ErrCodeGenerationError,
                message,
                WithDetails(createDetailsMap("project_id", projectID, "step", step)),
                WithSuggestions(GenerationSuggestions),
                WithSeverity(ErrorSeverityHigh),
                WithContext(&amp;ErrorContext{
                        Operation: "generation",
                        Component: "generator",
                        ProjectID: projectID,
                }),
        )
}</span>

// CreateInternalError creates an internal error with debug information
func (em *ErrorManager) CreateInternalError(message string, err error) *APIError <span class="cov0" title="0">{
        // Get stack trace
        stackTrace := getStackTrace(2) // Skip this function and the caller
        
        return em.CreateError(
                ErrorTypeSystem,
                ErrCodeInternalError,
                message,
                WithDetails(createDetailsMap("internal_error", err.Error())),
                WithSuggestions(InternalSuggestions),
                WithSeverity(ErrorSeverityCritical),
                WithRecoverable(true),
                WithContext(&amp;ErrorContext{
                        Operation:  "internal",
                        Component:  "system",
                        StackTrace: stackTrace,
                }),
        )
}</span>

// CreateDatabaseError creates a database error with recovery options
func (em *ErrorManager) CreateDatabaseError(message string, operation string, table string) *APIError <span class="cov0" title="0">{
        return em.CreateError(
                ErrorTypeDatabase,
                ErrCodeDatabaseError,
                message,
                WithDetails(createDetailsMap("operation", operation, "table", table)),
                WithSuggestions(DatabaseSuggestions),
                WithSeverity(ErrorSeverityHigh),
                WithRecoverable(true),
        )
}</span>

// CreateErrorCollection creates a collection for batch operations
func (em *ErrorManager) CreateErrorCollection(operation string, totalItems int) *ErrorCollection <span class="cov0" title="0">{
        return &amp;ErrorCollection{
                Errors:      []APIError{},
                Warnings:    []APIError{},
                Operation:   operation,
                TotalItems:  totalItems,
                FailedItems: 0,
                Timestamp:   time.Now(),
        }
}</span>

// ErrorOption is a function that configures an APIError
type ErrorOption func(*APIError)

// WithDetails adds details to an error
func WithDetails(details map[string]string) ErrorOption <span class="cov0" title="0">{
        return func(e *APIError) </span><span class="cov0" title="0">{
                if e.Details == nil </span><span class="cov0" title="0">{
                        e.Details = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range details </span><span class="cov0" title="0">{
                        e.Details[k] = v
                }</span>
        }
}

// WithSuggestions adds suggestions to an error
func WithSuggestions(suggestions []string) ErrorOption <span class="cov0" title="0">{
        return func(e *APIError) </span><span class="cov0" title="0">{
                e.Suggestions = suggestions
        }</span>
}

// WithSeverity sets the severity of an error
func WithSeverity(severity ErrorSeverity) ErrorOption <span class="cov0" title="0">{
        return func(e *APIError) </span><span class="cov0" title="0">{
                e.Severity = severity
        }</span>
}

// WithRecoverable marks an error as recoverable
func WithRecoverable(recoverable bool) ErrorOption <span class="cov0" title="0">{
        return func(e *APIError) </span><span class="cov0" title="0">{
                e.Recoverable = recoverable
        }</span>
}

// WithRetryAfter sets the retry delay for an error
func WithRetryAfter(delay time.Duration) ErrorOption <span class="cov0" title="0">{
        return func(e *APIError) </span><span class="cov0" title="0">{
                e.RetryAfter = &amp;delay
        }</span>
}

// WithContext adds context to an error
func WithContext(context *ErrorContext) ErrorOption <span class="cov0" title="0">{
        return func(e *APIError) </span><span class="cov0" title="0">{
                e.Context = context
        }</span>
}

// WithCorrelationID sets a custom correlation ID
func WithCorrelationID(correlationID string) ErrorOption <span class="cov0" title="0">{
        return func(e *APIError) </span><span class="cov0" title="0">{
                e.CorrelationID = correlationID
        }</span>
}

// Helper functions

// createDetailsMap creates a details map from key-value pairs
func createDetailsMap(pairs ...string) map[string]string <span class="cov0" title="0">{
        details := make(map[string]string)
        for i := 0; i &lt; len(pairs)-1; i += 2 </span><span class="cov0" title="0">{
                details[pairs[i]] = pairs[i+1]
        }</span>
        <span class="cov0" title="0">return details</span>
}

// Common suggestion collections
var (
        NetworkSuggestions = []string{
                "Check your internet connection",
                "Try again in a few moments",
                "Verify the service is available",
        }
        
        FileSystemSuggestions = []string{
                "Check that the file or directory exists",
                "Verify you have the necessary permissions",
                "Ensure the path is correct",
        }
        
        GenerationSuggestions = []string{
                "Check the OpenAPI specification for errors",
                "Verify the project configuration",
                "Try regenerating the server",
        }
        
        InternalSuggestions = []string{
                "This is an internal error. Please contact support if it persists",
                "Try refreshing the page or restarting the application",
        }
        
        DatabaseSuggestions = []string{
                "Check database connectivity",
                "Verify the operation is valid",
                "Try again in a few moments",
        }
)

// asAPIError safely converts an error to APIError if possible
func asAPIError(err error) (*APIError, bool) <span class="cov0" title="0">{
        if apiErr, ok := err.(*APIError); ok </span><span class="cov0" title="0">{
                return apiErr, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

// generateCorrelationID generates a unique correlation ID
func generateCorrelationID() string <span class="cov0" title="0">{
        return fmt.Sprintf("mcpw-%d-%d", time.Now().UnixNano(), rand.Intn(1000))
}</span>

// getStackTrace gets the current stack trace
func getStackTrace(skip int) string <span class="cov0" title="0">{
        const depth = 32
        var pcs [depth]uintptr
        n := runtime.Callers(skip+1, pcs[:])
        
        var trace string
        frames := runtime.CallersFrames(pcs[:n])
        for </span><span class="cov0" title="0">{
                frame, more := frames.Next()
                trace += fmt.Sprintf("%s:%d %s\n", frame.File, frame.Line, frame.Function)
                if !more </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return trace</span>
}

// IsRetryableError checks if an error can be retried
func IsRetryableError(err error) bool <span class="cov0" title="0">{
        if apiErr, ok := asAPIError(err); ok </span><span class="cov0" title="0">{
                return apiErr.IsRetryable()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetErrorSeverity returns the severity of an error
func GetErrorSeverity(err error) ErrorSeverity <span class="cov0" title="0">{
        if apiErr, ok := asAPIError(err); ok </span><span class="cov0" title="0">{
                return apiErr.Severity
        }</span>
        <span class="cov0" title="0">return ErrorSeverityMedium</span>
}

// GetErrorSuggestions returns suggestions for an error
func GetErrorSuggestions(err error) []string <span class="cov0" title="0">{
        if apiErr, ok := asAPIError(err); ok </span><span class="cov0" title="0">{
                return apiErr.Suggestions
        }</span>
        <span class="cov0" title="0">return []string{}</span>
}

// GetErrorContext returns the context of an error
func GetErrorContext(err error) *ErrorContext <span class="cov0" title="0">{
        if apiErr, ok := asAPIError(err); ok </span><span class="cov0" title="0">{
                return apiErr.Context
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CategorizeError categorizes an error based on its type and code
func CategorizeError(err error) string <span class="cov0" title="0">{
        if apiErr, ok := asAPIError(err); ok </span><span class="cov0" title="0">{
                switch apiErr.Type </span>{
                case ErrorTypeValidation:<span class="cov0" title="0">
                        return "User Input Error"</span>
                case ErrorTypeNetwork:<span class="cov0" title="0">
                        return "Network Error"</span>
                case ErrorTypeFileSystem:<span class="cov0" title="0">
                        return "File System Error"</span>
                case ErrorTypeDatabase:<span class="cov0" title="0">
                        return "Database Error"</span>
                case ErrorTypeGeneration:<span class="cov0" title="0">
                        return "Generation Error"</span>
                case ErrorTypeSystem:<span class="cov0" title="0">
                        return "System Error"</span>
                case ErrorTypePermission:<span class="cov0" title="0">
                        return "Permission Error"</span>
                case ErrorTypeConfiguration:<span class="cov0" title="0">
                        return "Configuration Error"</span>
                case ErrorTypeAuthentication:<span class="cov0" title="0">
                        return "Authentication Error"</span>
                default:<span class="cov0" title="0">
                        return "Unknown Error"</span>
                }
        }
        <span class="cov0" title="0">return "Unknown Error"</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/wailsapp/wails/v2/pkg/runtime"
        "gopkg.in/yaml.v3"
)

// Performance constants for file operations
const (
        maxFileSize = 10 * 1024 * 1024 // 10MB max file size
        bufferSize  = 64 * 1024        // 64KB buffer for file operations
)

// SelectFile opens a file selection dialog
func (a *App) SelectFile(filters []FileFilter) (string, error) <span class="cov0" title="0">{
        if a.ctx == nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("internal", ErrCodeInternalError, "Application context not initialized", nil)
        }</span>

        // Open file dialog
        <span class="cov0" title="0">filePath, err := runtime.OpenFileDialog(a.ctx, runtime.OpenDialogOptions{
                Title:   "Select OpenAPI Specification",
                Filters: convertFilters(filters),
        })

        if err != nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("file_system", ErrCodeFileAccess, "Failed to open file dialog", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Empty string means user cancelled
        <span class="cov0" title="0">if filePath == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Verify file exists and is readable
        <span class="cov0" title="0">if err := a.fileExists(filePath); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return filePath, nil</span>
}

// fileExists checks if a file exists and returns appropriate error
func (a *App) fileExists(path string) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "File path is required", nil)
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "File does not exist", map[string]string{
                        "path": path,
                })
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "Failed to check file existence", map[string]string{
                        "path": path,
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// dirExists checks if a directory exists and is writable
func (a *App) dirExists(path string) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Directory path is required", nil)
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "Directory does not exist", map[string]string{
                        "path": path,
                })
        }</span>

        // Test if directory is writable
        <span class="cov0" title="0">testFile := filepath.Join(path, ".mcpweaver_test")
        if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "Directory is not writable", map[string]string{
                        "path": path,
                        "error": err.Error(),
                })
        }</span>
        <span class="cov0" title="0">os.Remove(testFile) // Clean up test file

        return nil</span>
}

// ensureDir ensures a directory exists, creating it if necessary
func (a *App) ensureDir(path string) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Directory path is required", nil)
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "Failed to create directory", map[string]string{
                        "path": path,
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// convertFilters converts FileFilter slice to Wails runtime.FileFilter slice
func convertFilters(filters []FileFilter) []runtime.FileFilter <span class="cov0" title="0">{
        wailsFilters := make([]runtime.FileFilter, len(filters))
        for i, filter := range filters </span><span class="cov0" title="0">{
                wailsFilters[i] = runtime.FileFilter{
                        DisplayName: filter.DisplayName,
                        Pattern:     filter.Pattern,
                }
        }</span>
        <span class="cov0" title="0">return wailsFilters</span>
}

// SelectDirectory opens a directory selection dialog
func (a *App) SelectDirectory(title string) (string, error) <span class="cov0" title="0">{
        if a.ctx == nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("internal", ErrCodeInternalError, "Application context not initialized", nil)
        }</span>

        <span class="cov0" title="0">if title == "" </span><span class="cov0" title="0">{
                title = "Select Directory"
        }</span>

        // Open directory dialog
        <span class="cov0" title="0">dirPath, err := runtime.OpenDirectoryDialog(a.ctx, runtime.OpenDialogOptions{
                Title: title,
        })

        if err != nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("file_system", ErrCodeFileAccess, "Failed to open directory dialog", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Empty string means user cancelled
        <span class="cov0" title="0">if dirPath == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Verify directory exists and is writable
        <span class="cov0" title="0">if err := a.dirExists(dirPath); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return dirPath, nil</span>
}

// SaveFile opens a save file dialog
func (a *App) SaveFile(content string, defaultPath string, filters []FileFilter) (string, error) <span class="cov0" title="0">{
        if a.ctx == nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("internal", ErrCodeInternalError, "Application context not initialized", nil)
        }</span>

        // Open save dialog
        <span class="cov0" title="0">filePath, err := runtime.SaveFileDialog(a.ctx, runtime.SaveDialogOptions{
                Title:           "Save File",
                DefaultFilename: defaultPath,
                Filters:         convertFilters(filters),
        })

        if err != nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("file_system", ErrCodeFileAccess, "Failed to open save dialog", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Empty string means user cancelled
        <span class="cov0" title="0">if filePath == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Ensure directory exists
        <span class="cov0" title="0">dir := filepath.Dir(filePath)
        if err := a.ensureDir(dir); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Write content to file
        <span class="cov0" title="0">if err := os.WriteFile(filePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("file_system", ErrCodeFileAccess, "Failed to save file", map[string]string{
                        "path": filePath,
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return filePath, nil</span>
}

// ReadFile reads the content of a file
func (a *App) ReadFile(path string) (string, error) <span class="cov0" title="0">{
        // Check if file exists
        if err := a.fileExists(path); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Read file content
        <span class="cov0" title="0">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("file_system", ErrCodeFileAccess, "Failed to read file", map[string]string{
                        "path": path,
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return string(content), nil</span>
}

// WriteFile writes content to a file with size validation
func (a *App) WriteFile(path string, content string) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "File path is required", nil)
        }</span>

        // Validate content size
        <span class="cov0" title="0">if len(content) &gt; maxFileSize </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "Content too large", map[string]string{
                        "path": path,
                        "size": fmt.Sprintf("%d", len(content)),
                        "max_size": fmt.Sprintf("%d", maxFileSize),
                })
        }</span>

        // Ensure directory exists
        <span class="cov0" title="0">dir := filepath.Dir(path)
        if err := a.ensureDir(dir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write content to file
        <span class="cov0" title="0">if err := os.WriteFile(path, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "Failed to write file", map[string]string{
                        "path": path,
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FileExists checks if a file exists
func (a *App) FileExists(path string) (bool, error) <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return false, a.createAPIError("validation", ErrCodeValidation, "File path is required", nil)
        }</span>

        <span class="cov0" title="0">_, err := os.Stat(path)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        
        // Other error occurred
        <span class="cov0" title="0">return false, a.createAPIError("file_system", ErrCodeFileAccess, "Failed to check file existence", map[string]string{
                "path": path,
                "error": err.Error(),
        })</span>
}

// GetDefaultOpenAPIFilters returns default file filters for OpenAPI specifications
func (a *App) GetDefaultOpenAPIFilters() []FileFilter <span class="cov0" title="0">{
        return []FileFilter{
                {
                        DisplayName: "OpenAPI Specifications",
                        Pattern:     "*.json;*.yaml;*.yml;*.openapi",
                        Extensions:  []string{".json", ".yaml", ".yml", ".openapi"},
                },
                {
                        DisplayName: "JSON Files",
                        Pattern:     "*.json",
                        Extensions:  []string{".json"},
                },
                {
                        DisplayName: "YAML Files",
                        Pattern:     "*.yaml;*.yml",
                        Extensions:  []string{".yaml", ".yml"},
                },
                {
                        DisplayName: "OpenAPI Files",
                        Pattern:     "*.openapi",
                        Extensions:  []string{".openapi"},
                },
                {
                        DisplayName: "All Files",
                        Pattern:     "*.*",
                        Extensions:  []string{"*"},
                },
        }
}</span>

// GetSupportedFileFormats returns all supported file formats for OpenAPI specs
func (a *App) GetSupportedFileFormats() []string <span class="cov0" title="0">{
        return []string{
                "application/json",
                "application/x-yaml",
                "text/yaml",
                "text/x-yaml",
                "application/yaml",
                "text/plain",
        }
}</span>

// DetectFileFormat detects the format of a file based on content and extension
func (a *App) DetectFileFormat(content string, filename string) (string, error) <span class="cov0" title="0">{
        // First, try to detect based on content
        content = strings.TrimSpace(content)
        
        if len(content) == 0 </span><span class="cov0" title="0">{
                return "", a.createAPIError("validation", ErrCodeValidation, "File is empty", nil)
        }</span>

        // Check if it's JSON
        <span class="cov0" title="0">if strings.HasPrefix(content, "{") &amp;&amp; strings.HasSuffix(content, "}") </span><span class="cov0" title="0">{
                var jsonData map[string]interface{}
                if err := json.Unmarshal([]byte(content), &amp;jsonData); err == nil </span><span class="cov0" title="0">{
                        return "json", nil
                }</span>
        }

        // Check if it's YAML
        <span class="cov0" title="0">if !strings.HasPrefix(content, "{") </span><span class="cov0" title="0">{
                var yamlData map[string]interface{}
                if err := yaml.Unmarshal([]byte(content), &amp;yamlData); err == nil </span><span class="cov0" title="0">{
                        return "yaml", nil
                }</span>
        }

        // Fall back to extension-based detection
        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(filename))
        switch ext </span>{
        case ".json":<span class="cov0" title="0">
                return "json", nil</span>
        case ".yaml", ".yml":<span class="cov0" title="0">
                return "yaml", nil</span>
        case ".openapi":<span class="cov0" title="0">
                // OpenAPI files can be either JSON or YAML
                if strings.HasPrefix(content, "{") </span><span class="cov0" title="0">{
                        return "json", nil
                }</span>
                <span class="cov0" title="0">return "yaml", nil</span>
        default:<span class="cov0" title="0">
                // Try to parse as JSON first, then YAML
                var jsonData map[string]interface{}
                if err := json.Unmarshal([]byte(content), &amp;jsonData); err == nil </span><span class="cov0" title="0">{
                        return "json", nil
                }</span>
                
                <span class="cov0" title="0">var yamlData map[string]interface{}
                if err := yaml.Unmarshal([]byte(content), &amp;yamlData); err == nil </span><span class="cov0" title="0">{
                        return "yaml", nil
                }</span>
                
                <span class="cov0" title="0">return "", a.createAPIError("validation", ErrCodeValidation, "Unable to detect file format", map[string]string{
                        "filename": filename,
                        "extension": ext,
                })</span>
        }
}

// ImportOpenAPISpec imports an OpenAPI specification from a file
func (a *App) ImportOpenAPISpec(filePath string) (*ImportResult, error) <span class="cov0" title="0">{
        if filePath == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "File path is required", nil)
        }</span>

        // Check if file exists
        <span class="cov0" title="0">if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, a.createAPIError("file_system", ErrCodeFileAccess, "File does not exist", map[string]string{
                        "path": filePath,
                })
        }</span>

        // Validate file extension
        <span class="cov0" title="0">if !a.isValidOpenAPIFile(filePath) </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Invalid file format. Please select a JSON or YAML file", map[string]string{
                        "path": filePath,
                })
        }</span>

        // Read file content
        <span class="cov0" title="0">content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("file_system", ErrCodeFileAccess, "Failed to read file", map[string]string{
                        "path": filePath,
                        "error": err.Error(),
                })
        }</span>

        // Get file info
        <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("file_system", ErrCodeFileAccess, "Failed to get file info", map[string]string{
                        "path": filePath,
                        "error": err.Error(),
                })
        }</span>

        // Parse and validate the OpenAPI spec
        <span class="cov0" title="0">result, err := a.parseOpenAPIContent(string(content), filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result.ImportedFrom = "file"
        result.FilePath = filePath
        result.FileSize = fileInfo.Size()
        result.ImportedAt = time.Now()

        // Add to recent files
        if result.Valid </span><span class="cov0" title="0">{
                a.AddRecentFile(filePath, "spec")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ImportOpenAPISpecFromURL imports an OpenAPI specification from a URL
func (a *App) ImportOpenAPISpecFromURL(url string) (*ImportResult, error) <span class="cov0" title="0">{
        if url == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "URL is required", nil)
        }</span>

        // Validate URL format
        <span class="cov0" title="0">if !strings.HasPrefix(url, "http://") &amp;&amp; !strings.HasPrefix(url, "https://") </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Invalid URL format. URL must start with http:// or https://", map[string]string{
                        "url": url,
                })
        }</span>

        // Create progress tracking
        <span class="cov0" title="0">progressID := a.generateProgressID()
        a.emitFileProgress(progressID, "import", 0, "Starting URL import...", 1, 0)

        // Create HTTP client with timeout
        client := &amp;http.Client{
                Timeout: 30 * time.Second,
        }

        // Make HTTP request
        a.emitFileProgress(progressID, "import", 25, "Connecting to URL...", 1, 0)
        resp, err := client.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                a.emitFileProgress(progressID, "import", 0, "Failed to connect", 1, 0)
                return nil, a.createAPIError("network", ErrCodeNetworkError, "Failed to fetch URL", map[string]string{
                        "url": url,
                        "error": err.Error(),
                })
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check response status
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                a.emitFileProgress(progressID, "import", 0, "HTTP error: "+resp.Status, 1, 0)
                return nil, a.createAPIError("network", ErrCodeNetworkError, "Failed to fetch URL", map[string]string{
                        "url": url,
                        "status": resp.Status,
                })
        }</span>

        // Read response body with progress tracking
        <span class="cov0" title="0">a.emitFileProgress(progressID, "import", 50, "Downloading content...", 1, 0)
        content, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                a.emitFileProgress(progressID, "import", 0, "Failed to read response", 1, 0)
                return nil, a.createAPIError("network", ErrCodeNetworkError, "Failed to read response", map[string]string{
                        "url": url,
                        "error": err.Error(),
                })
        }</span>

        // Parse and validate the OpenAPI spec
        <span class="cov0" title="0">a.emitFileProgress(progressID, "import", 75, "Parsing and validating content...", 1, 0)
        result, err := a.parseOpenAPIContent(string(content), url)
        if err != nil </span><span class="cov0" title="0">{
                a.emitFileProgress(progressID, "import", 0, "Validation failed", 1, 0)
                return nil, err
        }</span>

        <span class="cov0" title="0">result.ImportedFrom = "url"
        result.SourceURL = url
        result.FileSize = int64(len(content))
        result.ImportedAt = time.Now()

        a.emitFileProgress(progressID, "import", 100, "Import completed successfully", 1, 1)
        return result, nil</span>
}

// ExportGeneratedServer exports a generated server to a specified directory
func (a *App) ExportGeneratedServer(projectID, targetDir string) (*ExportResult, error) <span class="cov0" title="0">{
        if projectID == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Project ID is required", nil)
        }</span>

        <span class="cov0" title="0">if targetDir == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Target directory is required", nil)
        }</span>

        // Create progress tracking
        <span class="cov0" title="0">progressID := a.generateProgressID()
        a.emitFileProgress(progressID, "export", 0, "Starting export...", 1, 0)

        // Get project
        project, err := a.GetProject(projectID)
        if err != nil </span><span class="cov0" title="0">{
                a.emitFileProgress(progressID, "export", 0, "Failed to get project", 1, 0)
                return nil, err
        }</span>

        // Check if project has been generated
        <span class="cov0" title="0">if project.Status != ProjectStatusReady || project.GenerationCount == 0 </span><span class="cov0" title="0">{
                a.emitFileProgress(progressID, "export", 0, "Project not ready for export", 1, 0)
                return nil, a.createAPIError("validation", ErrCodeValidation, "Project has not been generated yet", nil)
        }</span>

        // Create target directory if it doesn't exist
        <span class="cov0" title="0">a.emitFileProgress(progressID, "export", 10, "Creating target directory...", 1, 0)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                a.emitFileProgress(progressID, "export", 0, "Failed to create directory", 1, 0)
                return nil, a.createAPIError("file_system", ErrCodeFileAccess, "Failed to create target directory", map[string]string{
                        "path": targetDir,
                        "error": err.Error(),
                })
        }</span>

        // Copy generated files
        <span class="cov0" title="0">sourceDir := project.OutputPath
        copiedFiles := []ExportedFile{}

        // List of files to copy
        filesToCopy := []string{
                "main.go",
                "go.mod",
                "README.md",
                "Dockerfile",
                "Makefile",
                ".gitignore",
        }

        totalFiles := len(filesToCopy)
        processedFiles := 0

        for _, fileName := range filesToCopy </span><span class="cov0" title="0">{
                sourcePath := filepath.Join(sourceDir, fileName)
                targetPath := filepath.Join(targetDir, fileName)

                if _, err := os.Stat(sourcePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        processedFiles++
                        continue</span> // Skip if file doesn't exist
                }

                // Update progress
                <span class="cov0" title="0">progress := 20 + (processedFiles * 60 / totalFiles)
                a.emitFileProgress(progressID, "export", progress, "Copying "+fileName+"...", totalFiles, processedFiles)

                // Copy file
                if err := a.copyFile(sourcePath, targetPath); err != nil </span><span class="cov0" title="0">{
                        a.emitFileProgress(progressID, "export", 0, "Failed to copy "+fileName, totalFiles, processedFiles)
                        return nil, a.createAPIError("file_system", ErrCodeFileAccess, "Failed to copy file", map[string]string{
                                "source": sourcePath,
                                "target": targetPath,
                                "error": err.Error(),
                        })
                }</span>

                // Get file info
                <span class="cov0" title="0">fileInfo, err := os.Stat(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        processedFiles++
                        continue</span>
                }

                <span class="cov0" title="0">copiedFiles = append(copiedFiles, ExportedFile{
                        Name:         fileName,
                        Path:         targetPath,
                        Size:         fileInfo.Size(),
                        ModifiedTime: fileInfo.ModTime(),
                })
                processedFiles++</span>
        }

        // Copy additional directories if they exist
        <span class="cov0" title="0">a.emitFileProgress(progressID, "export", 80, "Copying additional directories...", totalFiles, processedFiles)
        dirsToCopy := []string{"docs", "examples", "scripts"}
        for _, dirName := range dirsToCopy </span><span class="cov0" title="0">{
                sourceDirPath := filepath.Join(sourceDir, dirName)
                targetDirPath := filepath.Join(targetDir, dirName)

                if _, err := os.Stat(sourceDirPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span> // Skip if directory doesn't exist
                }

                <span class="cov0" title="0">if err := a.copyDirectory(sourceDirPath, targetDirPath); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the export
                        continue</span>
                }
        }

        <span class="cov0" title="0">result := &amp;ExportResult{
                ProjectID:     projectID,
                ProjectName:   project.Name,
                TargetDir:     targetDir,
                ExportedFiles: copiedFiles,
                TotalFiles:    len(copiedFiles),
                TotalSize:     a.calculateTotalSize(copiedFiles),
                ExportedAt:    time.Now(),
        }

        a.emitFileProgress(progressID, "export", 100, "Export completed successfully", totalFiles, processedFiles)
        return result, nil</span>
}

// parseOpenAPIContent parses and validates OpenAPI content
func (a *App) parseOpenAPIContent(content, source string) (*ImportResult, error) <span class="cov0" title="0">{
        result := &amp;ImportResult{
                Content:   content,
                Valid:     false,
                Errors:    []string{},
                Warnings:  []string{},
        }

        // Validate content size
        if len(content) == 0 </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, "File is empty")
                return result, nil
        }</span>

        <span class="cov0" title="0">if len(content) &gt; 10*1024*1024 </span><span class="cov0" title="0">{ // 10MB limit
                result.Errors = append(result.Errors, "File is too large (maximum 10MB)")
                return result, nil
        }</span>

        // Basic validation - check if content is valid JSON or YAML
        <span class="cov0" title="0">var specData map[string]interface{}
        var parseError error
        
        // Try parsing as JSON first
        if err := json.Unmarshal([]byte(content), &amp;specData); err != nil </span><span class="cov0" title="0">{
                // Try parsing as YAML
                if err := yaml.Unmarshal([]byte(content), &amp;specData); err != nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, "Invalid JSON or YAML format: "+err.Error())
                        return result, nil
                }</span>
                <span class="cov0" title="0">parseError = err</span>
        }

        // Check if it's an OpenAPI spec
        <span class="cov0" title="0">var openApiVersion string
        if version, hasOpenAPI := specData["openapi"].(string); hasOpenAPI </span><span class="cov0" title="0">{
                openApiVersion = version
        }</span> else<span class="cov0" title="0"> if version, hasSwagger := specData["swagger"].(string); hasSwagger </span><span class="cov0" title="0">{
                openApiVersion = version
                result.Warnings = append(result.Warnings, "Using older Swagger 2.0 specification. Consider upgrading to OpenAPI 3.0+")
        }</span> else<span class="cov0" title="0"> {
                result.Errors = append(result.Errors, "Not a valid OpenAPI specification. Missing 'openapi' or 'swagger' field")
                return result, nil
        }</span>

        // Validate OpenAPI version
        <span class="cov0" title="0">if openApiVersion != "" </span><span class="cov0" title="0">{
                if !a.isValidOpenAPIVersion(openApiVersion) </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, "Unsupported OpenAPI version: "+openApiVersion)
                }</span>
        }

        // Extract and validate basic info
        <span class="cov0" title="0">info := &amp;SpecInfo{
                Version: openApiVersion,
                Title: "Unknown",
                Description: "",
        }

        if infoData, ok := specData["info"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if version, ok := infoData["version"].(string); ok </span><span class="cov0" title="0">{
                        info.Version = version
                }</span> else<span class="cov0" title="0"> {
                        result.Errors = append(result.Errors, "Missing required 'info.version' field")
                        return result, nil
                }</span>
                
                <span class="cov0" title="0">if title, ok := infoData["title"].(string); ok </span><span class="cov0" title="0">{
                        info.Title = title
                }</span> else<span class="cov0" title="0"> {
                        result.Errors = append(result.Errors, "Missing required 'info.title' field")
                        return result, nil
                }</span>
                
                <span class="cov0" title="0">if description, ok := infoData["description"].(string); ok </span><span class="cov0" title="0">{
                        info.Description = description
                }</span>
        } else<span class="cov0" title="0"> {
                result.Errors = append(result.Errors, "Missing required 'info' section")
                return result, nil
        }</span>

        // Validate and count operations
        <span class="cov0" title="0">operationCount := 0
        schemaCount := 0
        
        if paths, ok := specData["paths"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if len(paths) == 0 </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, "No paths defined in the specification")
                }</span>
                
                <span class="cov0" title="0">for pathName, pathData := range paths </span><span class="cov0" title="0">{
                        if pathMethods, ok := pathData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for method := range pathMethods </span><span class="cov0" title="0">{
                                        if a.isValidHTTPMethod(method) </span><span class="cov0" title="0">{
                                                operationCount++
                                        }</span>
                                }
                        }
                        
                        // Validate path format
                        <span class="cov0" title="0">if !strings.HasPrefix(pathName, "/") </span><span class="cov0" title="0">{
                                result.Warnings = append(result.Warnings, "Path '"+pathName+"' should start with '/'")
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                result.Warnings = append(result.Warnings, "No paths section found")
        }</span>

        // Count schemas/components
        <span class="cov0" title="0">if components, ok := specData["components"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if schemas, ok := components["schemas"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        schemaCount = len(schemas)
                }</span>
        } else<span class="cov0" title="0"> if definitions, ok := specData["definitions"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Swagger 2.0 format
                schemaCount = len(definitions)
        }</span>

        <span class="cov0" title="0">info.OperationCount = operationCount
        info.SchemaCount = schemaCount

        // Extract and validate servers
        servers := []ServerInfo{}
        if serverData, ok := specData["servers"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, server := range serverData </span><span class="cov0" title="0">{
                        if serverMap, ok := server.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                serverInfo := ServerInfo{}
                                if url, ok := serverMap["url"].(string); ok </span><span class="cov0" title="0">{
                                        serverInfo.URL = url
                                        if !a.isValidServerURL(url) </span><span class="cov0" title="0">{
                                                result.Warnings = append(result.Warnings, "Invalid server URL: "+url)
                                        }</span>
                                }
                                <span class="cov0" title="0">if desc, ok := serverMap["description"].(string); ok </span><span class="cov0" title="0">{
                                        serverInfo.Description = desc
                                }</span>
                                <span class="cov0" title="0">servers = append(servers, serverInfo)</span>
                        }
                }
        } else<span class="cov0" title="0"> if host, ok := specData["host"].(string); ok </span><span class="cov0" title="0">{
                // Swagger 2.0 format
                scheme := "https"
                if schemes, ok := specData["schemes"].([]interface{}); ok &amp;&amp; len(schemes) &gt; 0 </span><span class="cov0" title="0">{
                        if s, ok := schemes[0].(string); ok </span><span class="cov0" title="0">{
                                scheme = s
                        }</span>
                }
                <span class="cov0" title="0">basePath := ""
                if bp, ok := specData["basePath"].(string); ok </span><span class="cov0" title="0">{
                        basePath = bp
                }</span>
                
                <span class="cov0" title="0">serverInfo := ServerInfo{
                        URL: scheme + "://" + host + basePath,
                        Description: "Generated from Swagger 2.0 host",
                }
                servers = append(servers, serverInfo)</span>
        }
        
        <span class="cov0" title="0">if len(servers) == 0 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "No servers defined in the specification")
        }</span>
        
        <span class="cov0" title="0">info.Servers = servers

        // Extract security schemes
        securitySchemes := []SecurityScheme{}
        if components, ok := specData["components"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if secSchemes, ok := components["securitySchemes"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for name, scheme := range secSchemes </span><span class="cov0" title="0">{
                                if schemeMap, ok := scheme.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        secScheme := SecurityScheme{Name: name}
                                        if schemeType, ok := schemeMap["type"].(string); ok </span><span class="cov0" title="0">{
                                                secScheme.Type = schemeType
                                        }</span>
                                        <span class="cov0" title="0">if desc, ok := schemeMap["description"].(string); ok </span><span class="cov0" title="0">{
                                                secScheme.Description = desc
                                        }</span>
                                        <span class="cov0" title="0">securitySchemes = append(securitySchemes, secScheme)</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">info.SecuritySchemes = securitySchemes

        // Additional validation checks
        if operationCount == 0 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "No operations found in the specification")
        }</span>

        <span class="cov0" title="0">if operationCount &gt; 1000 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "Large specification with "+string(rune(operationCount))+" operations. Generation may take longer.")
        }</span>

        <span class="cov0" title="0">if parseError != nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "File parsed as YAML but contains JSON syntax errors: "+parseError.Error())
        }</span>

        <span class="cov0" title="0">result.Valid = len(result.Errors) == 0
        result.SpecInfo = info

        return result, nil</span>
}

// isValidOpenAPIVersion checks if the OpenAPI version is supported
func (a *App) isValidOpenAPIVersion(version string) bool <span class="cov0" title="0">{
        supportedVersions := []string{"3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.1.0", "2.0"}
        for _, v := range supportedVersions </span><span class="cov0" title="0">{
                if strings.HasPrefix(version, v) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isValidHTTPMethod checks if a method is a valid HTTP method
func (a *App) isValidHTTPMethod(method string) bool <span class="cov0" title="0">{
        validMethods := []string{"get", "post", "put", "patch", "delete", "head", "options", "trace"}
        method = strings.ToLower(method)
        for _, m := range validMethods </span><span class="cov0" title="0">{
                if method == m </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isValidServerURL performs basic URL validation
func (a *App) isValidServerURL(url string) bool <span class="cov0" title="0">{
        if url == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Basic validation - should be a valid URL or template
        <span class="cov0" title="0">if strings.HasPrefix(url, "http://") || strings.HasPrefix(url, "https://") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Allow relative URLs and templates
        <span class="cov0" title="0">if strings.HasPrefix(url, "/") || strings.Contains(url, "{") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

// isValidOpenAPIFile checks if a file has a valid OpenAPI extension
func (a *App) isValidOpenAPIFile(filePath string) bool <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(filePath))
        return ext == ".json" || ext == ".yaml" || ext == ".yml" || ext == ".openapi"
}</span>

// copyFile copies a file from source to target
func (a *App) copyFile(source, target string) error <span class="cov0" title="0">{
        sourceFile, err := os.Open(source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer sourceFile.Close()

        // Create target directory if it doesn't exist
        targetDir := filepath.Dir(target)
        if err := os.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">targetFile, err := os.Create(target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer targetFile.Close()

        _, err = io.Copy(targetFile, sourceFile)
        return err</span>
}

// copyDirectory recursively copies a directory
func (a *App) copyDirectory(source, target string) error <span class="cov0" title="0">{
        return filepath.Walk(source, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Calculate relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(source, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">targetPath := filepath.Join(target, relPath)

                if info.IsDir() </span><span class="cov0" title="0">{
                        return os.MkdirAll(targetPath, info.Mode())
                }</span>

                <span class="cov0" title="0">return a.copyFile(path, targetPath)</span>
        })
}

// calculateTotalSize calculates the total size of exported files
func (a *App) calculateTotalSize(files []ExportedFile) int64 <span class="cov0" title="0">{
        var total int64
        for _, file := range files </span><span class="cov0" title="0">{
                total += file.Size
        }</span>
        <span class="cov0" title="0">return total</span>
}

// generateProgressID generates a unique ID for progress tracking
func (a *App) generateProgressID() string <span class="cov0" title="0">{
        return "file_op_" + string(rune(time.Now().UnixNano()))
}</span>

// emitFileProgress emits file operation progress via Wails events
func (a *App) emitFileProgress(operationID string, operationType string, progress int, message string, totalFiles int, processedFiles int) <span class="cov0" title="0">{
        if a.ctx == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">progressData := FileOperationProgress{
                OperationID:        operationID,
                Type:               operationType,
                Progress:           progress,
                CurrentFile:        message,
                TotalFiles:         totalFiles,
                ProcessedFiles:     processedFiles,
                StartTime:          time.Now().Format(time.RFC3339),
                ElapsedTime:        0,
                EstimatedRemaining: 0,
        }

        // Emit progress event
        runtime.EventsEmit(a.ctx, "file:progress", progressData)</span>
}

// AddRecentFile adds a file to the recent files list
func (a *App) AddRecentFile(filePath string, fileType string) error <span class="cov0" title="0">{
        if filePath == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "File path is required", nil)
        }</span>

        // Get file info
        <span class="cov0" title="0">fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "Failed to get file info", map[string]string{
                        "path": filePath,
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">recentFile := RecentFile{
                Path:         filePath,
                Name:         filepath.Base(filePath),
                Size:         fileInfo.Size(),
                LastAccessed: time.Now().Format(time.RFC3339),
                Type:         fileType,
        }

        // Get current settings
        settings, err := a.GetSettings()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Initialize recent files if not exists
        <span class="cov0" title="0">recentFiles := []RecentFile{}
        if len(settings.RecentFiles) &gt; 0 </span><span class="cov0" title="0">{
                // Parse existing recent files (stored as JSON strings)
                for _, recentFileData := range settings.RecentFiles </span><span class="cov0" title="0">{
                        var rf RecentFile
                        if err := json.Unmarshal([]byte(recentFileData), &amp;rf); err == nil </span><span class="cov0" title="0">{
                                recentFiles = append(recentFiles, rf)
                        }</span>
                }
        }

        // Remove duplicate if exists
        <span class="cov0" title="0">for i, rf := range recentFiles </span><span class="cov0" title="0">{
                if rf.Path == filePath </span><span class="cov0" title="0">{
                        recentFiles = append(recentFiles[:i], recentFiles[i+1:]...)
                        break</span>
                }
        }

        // Add new file to the beginning
        <span class="cov0" title="0">recentFiles = append([]RecentFile{recentFile}, recentFiles...)

        // Limit to 10 recent files
        if len(recentFiles) &gt; 10 </span><span class="cov0" title="0">{
                recentFiles = recentFiles[:10]
        }</span>

        // Convert back to JSON strings
        <span class="cov0" title="0">recentFileStrings := []string{}
        for _, rf := range recentFiles </span><span class="cov0" title="0">{
                if data, err := json.Marshal(rf); err == nil </span><span class="cov0" title="0">{
                        recentFileStrings = append(recentFileStrings, string(data))
                }</span>
        }

        // Update settings
        <span class="cov0" title="0">settings.RecentFiles = recentFileStrings
        return a.UpdateSettings(*settings)</span>
}

// GetRecentFiles returns the list of recent files
func (a *App) GetRecentFiles() ([]RecentFile, error) <span class="cov0" title="0">{
        settings, err := a.GetSettings()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">recentFiles := []RecentFile{}
        for _, recentFileData := range settings.RecentFiles </span><span class="cov0" title="0">{
                var rf RecentFile
                if err := json.Unmarshal([]byte(recentFileData), &amp;rf); err == nil </span><span class="cov0" title="0">{
                        // Check if file still exists
                        if _, err := os.Stat(rf.Path); err == nil </span><span class="cov0" title="0">{
                                recentFiles = append(recentFiles, rf)
                        }</span>
                }
        }

        <span class="cov0" title="0">return recentFiles, nil</span>
}

// ClearRecentFiles clears the recent files list
func (a *App) ClearRecentFiles() error <span class="cov0" title="0">{
        settings, err := a.GetSettings()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">settings.RecentFiles = []string{}
        return a.UpdateSettings(*settings)</span>
}

// RemoveRecentFile removes a specific file from the recent files list
func (a *App) RemoveRecentFile(filePath string) error <span class="cov0" title="0">{
        if filePath == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "File path is required", nil)
        }</span>

        <span class="cov0" title="0">settings, err := a.GetSettings()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse and filter recent files
        <span class="cov0" title="0">recentFiles := []RecentFile{}
        for _, recentFileData := range settings.RecentFiles </span><span class="cov0" title="0">{
                var rf RecentFile
                if err := json.Unmarshal([]byte(recentFileData), &amp;rf); err == nil </span><span class="cov0" title="0">{
                        if rf.Path != filePath </span><span class="cov0" title="0">{
                                recentFiles = append(recentFiles, rf)
                        }</span>
                }
        }

        // Convert back to JSON strings
        <span class="cov0" title="0">recentFileStrings := []string{}
        for _, rf := range recentFiles </span><span class="cov0" title="0">{
                if data, err := json.Marshal(rf); err == nil </span><span class="cov0" title="0">{
                        recentFileStrings = append(recentFileStrings, string(data))
                }</span>
        }

        // Update settings
        <span class="cov0" title="0">settings.RecentFiles = recentFileStrings
        return a.UpdateSettings(*settings)</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "MCPWeaver/internal/generator"
        "MCPWeaver/internal/mapping"
        "MCPWeaver/internal/parser"
        "github.com/wailsapp/wails/v2/pkg/runtime"
)

// Active generation jobs with cleanup
var (
        activeJobs = make(map[string]*GenerationJob)
        jobsMutex  = &amp;sync.RWMutex{}
)

// Memory pools for generation
var (
        stringPool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return make([]string, 0, 10)
                }</span>,
        }
        mapPool = sync.Pool{
                New: func() interface{} <span class="cov0" title="0">{
                        return make(map[string]interface{}, 10)
                }</span>,
        }
)

// GenerateServer starts the generation process for a project
func (a *App) GenerateServer(projectID string) (*GenerationJob, error) <span class="cov0" title="0">{
        if projectID == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Project ID is required", nil)
        }</span>

        // Get project
        <span class="cov0" title="0">project, err := a.GetProject(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if there's already an active job for this project
        <span class="cov0" title="0">jobsMutex.RLock()
        for _, job := range activeJobs </span><span class="cov0" title="0">{
                if job.ProjectID == projectID &amp;&amp; (job.Status == GenerationStatusStarted || job.Status == GenerationStatusParsing || job.Status == GenerationStatusMapping || job.Status == GenerationStatusGenerating) </span><span class="cov0" title="0">{
                        jobsMutex.RUnlock()
                        return nil, a.createAPIError("validation", ErrCodeValidation, "Generation already in progress for this project", nil)
                }</span>
        }
        <span class="cov0" title="0">jobsMutex.RUnlock()

        // Clean up completed jobs before adding new one
        a.cleanupCompletedJobs()

        // Create generation job
        job := &amp;GenerationJob{
                ID:          generateJobID(),
                ProjectID:   projectID,
                Status:      GenerationStatusStarted,
                Progress:    0.0,
                CurrentStep: "Initializing generation",
                StartTime:   time.Now(),
                Errors:      []GenerationError{},
        }

        // Store job
        jobsMutex.Lock()
        activeJobs[job.ID] = job
        jobsMutex.Unlock()

        // Update project status
        a.updateProjectStatus(projectID, ProjectStatusGenerating)

        // Start generation in background
        go a.runGeneration(job, project)

        // Emit event
        runtime.EventsEmit(a.ctx, "generation:started", job)

        return job, nil</span>
}

// GetGenerationJob returns a specific generation job by ID
func (a *App) GetGenerationJob(jobID string) (*GenerationJob, error) <span class="cov0" title="0">{
        if jobID == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Job ID is required", nil)
        }</span>

        <span class="cov0" title="0">jobsMutex.RLock()
        job, exists := activeJobs[jobID]
        jobsMutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, a.createAPIError("not_found", ErrCodeNotFound, "Generation job not found", nil)
        }</span>

        <span class="cov0" title="0">return job, nil</span>
}

// cleanupCompletedJobs removes completed jobs from memory to prevent memory leaks
func (a *App) cleanupCompletedJobs() <span class="cov0" title="0">{
        jobsMutex.Lock()
        defer jobsMutex.Unlock()
        
        for id, job := range activeJobs </span><span class="cov0" title="0">{
                if job.Status == GenerationStatusCompleted || job.Status == GenerationStatusFailed </span><span class="cov0" title="0">{
                        // Only keep jobs for the last 5 minutes
                        if time.Since(job.StartTime) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                                delete(activeJobs, id)
                        }</span>
                }
        }
}

// CancelGeneration cancels an active generation job
func (a *App) CancelGeneration(jobID string) error <span class="cov0" title="0">{
        if jobID == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Job ID is required", nil)
        }</span>

        <span class="cov0" title="0">jobsMutex.Lock()
        defer jobsMutex.Unlock()

        job, exists := activeJobs[jobID]
        if !exists </span><span class="cov0" title="0">{
                return a.createAPIError("not_found", ErrCodeNotFound, "Generation job not found", nil)
        }</span>

        <span class="cov0" title="0">if job.Status == GenerationStatusCompleted || job.Status == GenerationStatusFailed || job.Status == GenerationStatusCancelled </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Cannot cancel completed generation", nil)
        }</span>

        // Update job status
        <span class="cov0" title="0">job.Status = GenerationStatusCancelled
        job.CurrentStep = "Cancelled by user"
        endTime := time.Now()
        job.EndTime = &amp;endTime

        // Update project status
        a.updateProjectStatus(job.ProjectID, ProjectStatusReady)

        // Emit event
        runtime.EventsEmit(a.ctx, "generation:cancelled", job)

        // Send notification
        a.emitNotification("info", "Generation Cancelled", "Code generation has been cancelled")

        return nil</span>
}

// GetGenerationHistory returns the generation history for a project
func (a *App) GetGenerationHistory(projectID string) ([]*GenerationJob, error) <span class="cov0" title="0">{
        if projectID == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Project ID is required", nil)
        }</span>

        // For now, return active jobs for this project
        // In a full implementation, this would fetch from database
        <span class="cov0" title="0">jobsMutex.RLock()
        defer jobsMutex.RUnlock()

        var jobs []*GenerationJob
        for _, job := range activeJobs </span><span class="cov0" title="0">{
                if job.ProjectID == projectID </span><span class="cov0" title="0">{
                        jobs = append(jobs, job)
                }</span>
        }

        <span class="cov0" title="0">return jobs, nil</span>
}

// runGeneration executes the generation process
func (a *App) runGeneration(job *GenerationJob, project *Project) <span class="cov0" title="0">{
        // Start performance monitoring
        overallTimer := a.performanceMonitor.StartTimer("generation", "overall")
        defer func() </span><span class="cov0" title="0">{
                overallTimer()
                // Force garbage collection after generation
                a.performanceMonitor.ForceGC()
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        a.handleGenerationError(job, fmt.Sprintf("Generation panicked: %v", r))
                }</span>
        }()

        // Step 1: Parse OpenAPI specification
        <span class="cov0" title="0">a.updateJobProgress(job, GenerationStatusParsing, 0.1, "Parsing OpenAPI specification")
        parseTimer := a.performanceMonitor.StartTimer("generation", "parse")
        defer parseTimer()

        var specPath string
        if project.SpecPath != "" </span><span class="cov0" title="0">{
                specPath = project.SpecPath
        }</span> else<span class="cov0" title="0"> if project.SpecURL != "" </span><span class="cov0" title="0">{
                // For URLs, we'll parse directly
                specPath = project.SpecURL
        }</span> else<span class="cov0" title="0"> {
                a.handleGenerationError(job, "No OpenAPI specification provided")
                return
        }</span>

        <span class="cov0" title="0">var parsedAPI *parser.ParsedAPI
        var err error

        if strings.HasPrefix(specPath, "http://") || strings.HasPrefix(specPath, "https://") </span><span class="cov0" title="0">{
                parsedAPI, err = a.parserService.ParseFromURL(a.ctx, specPath)
        }</span> else<span class="cov0" title="0"> {
                parsedAPI, err = a.parserService.ParseFromFile(specPath)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                a.handleGenerationError(job, fmt.Sprintf("Failed to parse OpenAPI specification: %v", err))
                return
        }</span>

        <span class="cov0" title="0">a.updateJobProgress(job, GenerationStatusMapping, 0.3, "Mapping operations to MCP tools")
        mappingTimer := a.performanceMonitor.StartTimer("generation", "mapping")
        defer mappingTimer()

        // Step 2: Map operations to MCP tools
        baseURL := parsedAPI.BaseURL
        if baseURL == "" &amp;&amp; len(parsedAPI.Servers) &gt; 0 </span><span class="cov0" title="0">{
                baseURL = parsedAPI.Servers[0]
        }</span>

        <span class="cov0" title="0">mappingService := mapping.NewService(baseURL)
        tools, err := mappingService.MapOperationsToTools(parsedAPI.Operations)
        if err != nil </span><span class="cov0" title="0">{
                a.handleGenerationError(job, fmt.Sprintf("Failed to map operations to MCP tools: %v", err))
                return
        }</span>

        <span class="cov0" title="0">a.updateJobProgress(job, GenerationStatusGenerating, 0.5, "Generating MCP server code")
        generateTimer := a.performanceMonitor.StartTimer("generation", "generate")
        defer generateTimer()

        // Step 3: Generate server code
        if a.generatorService == nil </span><span class="cov0" title="0">{
                a.generatorService = generator.NewService(project.OutputPath)
        }</span>

        <span class="cov0" title="0">err = a.generatorService.Generate(parsedAPI, tools, project.Settings.PackageName)
        if err != nil </span><span class="cov0" title="0">{
                a.handleGenerationError(job, fmt.Sprintf("Failed to generate server code: %v", err))
                return
        }</span>

        <span class="cov0" title="0">a.updateJobProgress(job, GenerationStatusValidating, 0.8, "Validating generated code")
        validationTimer := a.performanceMonitor.StartTimer("generation", "validation")
        defer validationTimer()

        // Step 4: Validate generated code
        validationResult, err := a.generatorService.ValidateGeneratedCode()
        if err != nil </span><span class="cov0" title="0">{
                a.handleGenerationError(job, fmt.Sprintf("Failed to validate generated code: %v", err))
                return
        }</span>

        // Check validation result
        <span class="cov0" title="0">if !validationResult.IsValid </span><span class="cov0" title="0">{
                errorMsg := fmt.Sprintf("Generated code validation failed: %s", strings.Join(validationResult.Errors, "; "))
                a.handleGenerationError(job, errorMsg)
                return
        }</span>

        // Add warnings to job if any
        <span class="cov0" title="0">if len(validationResult.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                job.Warnings = validationResult.Warnings
        }</span>

        // Get file statistics
        <span class="cov0" title="0">generatedFiles := []GeneratedFile{}
        expectedFiles := []string{"main.go", "go.mod", "README.md"}
        
        for _, filename := range expectedFiles </span><span class="cov0" title="0">{
                filePath := filepath.Join(project.OutputPath, filename)
                if info, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                        var fileType string
                        switch filename </span>{
                        case "main.go":<span class="cov0" title="0">
                                fileType = "server"</span>
                        case "go.mod":<span class="cov0" title="0">
                                fileType = "module"</span>
                        case "README.md":<span class="cov0" title="0">
                                fileType = "documentation"</span>
                        default:<span class="cov0" title="0">
                                fileType = "other"</span>
                        }
                        
                        // Count lines of code
                        <span class="cov0" title="0">linesOfCode := 0
                        if content, err := os.ReadFile(filePath); err == nil </span><span class="cov0" title="0">{
                                linesOfCode = len(strings.Split(string(content), "\n"))
                        }</span>
                        
                        <span class="cov0" title="0">generatedFiles = append(generatedFiles, GeneratedFile{
                                Path: filePath,
                                Type: fileType,
                                Size: int(info.Size()),
                                LinesOfCode: linesOfCode,
                        })</span>
                }
        }

        // Step 5: Complete generation
        <span class="cov0" title="0">a.updateJobProgress(job, GenerationStatusCompleted, 1.0, "Generation completed successfully")

        // Update job results
        endTime := time.Now()
        job.EndTime = &amp;endTime
        job.Results = &amp;GenerationResults{
                ServerPath:     filepath.Join(project.OutputPath, "main.go"),
                GeneratedFiles: generatedFiles,
                MCPTools:       tools,
                Statistics: GenerationStats{
                        TotalEndpoints:  len(parsedAPI.Operations),
                        GeneratedTools:  len(tools),
                        ProcessingTime:  endTime.Sub(job.StartTime),
                        SpecComplexity:  a.calculateSpecComplexity(parsedAPI, tools),
                        TemplateVersion: "1.0.0",
                },
        }

        // Update project
        a.updateProjectGeneration(job.ProjectID)
        a.updateProjectStatus(job.ProjectID, ProjectStatusReady)

        // Emit completion event
        runtime.EventsEmit(a.ctx, "generation:completed", job)

        // Send notification
        a.emitNotification("success", "Generation Complete", 
                fmt.Sprintf("MCP server generated successfully with %d tools", len(tools)))</span>
}

// updateJobProgress updates the job progress and emits events
func (a *App) updateJobProgress(job *GenerationJob, status GenerationStatus, progress float64, step string) <span class="cov0" title="0">{
        jobsMutex.Lock()
        job.Status = status
        job.Progress = progress
        job.CurrentStep = step
        jobsMutex.Unlock()

        // Emit progress event
        runtime.EventsEmit(a.ctx, "generation:progress", GenerationProgress{
                JobID:       job.ID,
                Progress:    progress,
                CurrentStep: step,
                Message:     step,
        })
}</span>

// handleGenerationError handles errors during generation
func (a *App) handleGenerationError(job *GenerationJob, message string) <span class="cov0" title="0">{
        jobsMutex.Lock()
        job.Status = GenerationStatusFailed
        job.CurrentStep = "Generation failed"
        endTime := time.Now()
        job.EndTime = &amp;endTime
        
        job.Errors = append(job.Errors, GenerationError{
                Type:    "generation",
                Message: message,
                Details: "",
        })
        jobsMutex.Unlock()

        // Update project status
        a.updateProjectStatus(job.ProjectID, ProjectStatusError)

        // Emit error event
        runtime.EventsEmit(a.ctx, "generation:failed", map[string]interface{}{
                "jobId":   job.ID,
                "type":    "generation",
                "message": message,
        })

        // Send notification
        a.emitNotification("error", "Generation Failed", message)
}</span>

// updateProjectStatus updates the project status
func (a *App) updateProjectStatus(projectID string, status ProjectStatus) <span class="cov0" title="0">{
        project, err := a.GetProject(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Update project in database
        <span class="cov0" title="0">dbProject, err := a.projectRepo.GetByID(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">dbProject.Status = string(status)
        dbProject.UpdatedAt = time.Now()
        a.projectRepo.Update(dbProject)

        // Emit update event
        project.Status = status
        project.UpdatedAt = time.Now()
        runtime.EventsEmit(a.ctx, "project:updated", project)</span>
}

// updateProjectGeneration updates the project's generation count and timestamp
func (a *App) updateProjectGeneration(projectID string) <span class="cov0" title="0">{
        dbProject, err := a.projectRepo.GetByID(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">now := time.Now()
        dbProject.GenerationCount++
        dbProject.LastGenerated = &amp;now
        dbProject.UpdatedAt = now
        a.projectRepo.Update(dbProject)</span>
}

// generateJobID generates a unique job ID
func generateJobID() string <span class="cov0" title="0">{
        return fmt.Sprintf("gen_%d", time.Now().UnixNano())
}</span>

// calculateSpecComplexity calculates the complexity of the OpenAPI spec
func (a *App) calculateSpecComplexity(api *parser.ParsedAPI, tools []mapping.MCPTool) string <span class="cov0" title="0">{
        score := 0
        
        // Base score from number of operations
        operationCount := len(api.Operations)
        if operationCount &gt; 50 </span><span class="cov0" title="0">{
                score += 3
        }</span> else<span class="cov0" title="0"> if operationCount &gt; 20 </span><span class="cov0" title="0">{
                score += 2
        }</span> else<span class="cov0" title="0"> if operationCount &gt; 10 </span><span class="cov0" title="0">{
                score += 1
        }</span>
        
        // Score from number of tools generated
        <span class="cov0" title="0">toolCount := len(tools)
        if toolCount &gt; 50 </span><span class="cov0" title="0">{
                score += 3
        }</span> else<span class="cov0" title="0"> if toolCount &gt; 20 </span><span class="cov0" title="0">{
                score += 2
        }</span> else<span class="cov0" title="0"> if toolCount &gt; 10 </span><span class="cov0" title="0">{
                score += 1
        }</span>
        
        // Score from parameter complexity
        <span class="cov0" title="0">totalParams := 0
        for _, op := range api.Operations </span><span class="cov0" title="0">{
                totalParams += len(op.Parameters)
                if op.RequestBody != nil </span><span class="cov0" title="0">{
                        totalParams += 1 // Count request body as additional complexity
                }</span>
        }
        
        <span class="cov0" title="0">if totalParams &gt; 100 </span><span class="cov0" title="0">{
                score += 3
        }</span> else<span class="cov0" title="0"> if totalParams &gt; 50 </span><span class="cov0" title="0">{
                score += 2
        }</span> else<span class="cov0" title="0"> if totalParams &gt; 20 </span><span class="cov0" title="0">{
                score += 1
        }</span>
        
        // Score from server configuration
        <span class="cov0" title="0">if len(api.Servers) &gt; 3 </span><span class="cov0" title="0">{
                score += 1
        }</span>
        
        // Determine complexity level
        <span class="cov0" title="0">switch </span>{
        case score &gt;= 8:<span class="cov0" title="0">
                return "very high"</span>
        case score &gt;= 6:<span class="cov0" title="0">
                return "high"</span>
        case score &gt;= 4:<span class="cov0" title="0">
                return "medium"</span>
        case score &gt;= 2:<span class="cov0" title="0">
                return "low"</span>
        default:<span class="cov0" title="0">
                return "very low"</span>
        }
}</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"
)

// LogLevel represents the severity level of a log entry
type LogLevel int

const (
        LogLevelDebug LogLevel = iota
        LogLevelInfo
        LogLevelWarn
        LogLevelError
        LogLevelFatal
)

// String returns the string representation of the log level
func (l LogLevel) String() string <span class="cov0" title="0">{
        switch l </span>{
        case LogLevelDebug:<span class="cov0" title="0">
                return "DEBUG"</span>
        case LogLevelInfo:<span class="cov0" title="0">
                return "INFO"</span>
        case LogLevelWarn:<span class="cov0" title="0">
                return "WARN"</span>
        case LogLevelError:<span class="cov0" title="0">
                return "ERROR"</span>
        case LogLevelFatal:<span class="cov0" title="0">
                return "FATAL"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// LogEntry represents a structured log entry
type LogEntry struct {
        Timestamp     time.Time         `json:"timestamp"`
        Level         LogLevel          `json:"level"`
        Message       string            `json:"message"`
        Context       map[string]string `json:"context,omitempty"`
        Error         string            `json:"error,omitempty"`
        StackTrace    string            `json:"stackTrace,omitempty"`
        CorrelationID string            `json:"correlationId,omitempty"`
        Component     string            `json:"component,omitempty"`
        Operation     string            `json:"operation,omitempty"`
        Duration      time.Duration     `json:"duration,omitempty"`
        UserID        string            `json:"userId,omitempty"`
        ProjectID     string            `json:"projectId,omitempty"`
        SessionID     string            `json:"sessionId,omitempty"`
        RequestID     string            `json:"requestId,omitempty"`
}

// Logger provides structured logging capabilities
type Logger struct {
        level      LogLevel
        outputs    []io.Writer
        context    map[string]string
        component  string
        jsonFormat bool
}

// NewLogger creates a new logger instance
func NewLogger(level LogLevel, component string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                level:      level,
                outputs:    []io.Writer{os.Stdout},
                context:    make(map[string]string),
                component:  component,
                jsonFormat: true,
        }
}</span>

// NewFileLogger creates a logger that writes to a file
func NewFileLogger(level LogLevel, component string, logFile string) (*Logger, error) <span class="cov0" title="0">{
        // Create log directory if it doesn't exist
        logDir := filepath.Dir(logFile)
        if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        // Open log file
        <span class="cov0" title="0">file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open log file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Logger{
                level:      level,
                outputs:    []io.Writer{file, os.Stdout},
                context:    make(map[string]string),
                component:  component,
                jsonFormat: true,
        }, nil</span>
}

// WithContext adds context to the logger
func (l *Logger) WithContext(key, value string) *Logger <span class="cov0" title="0">{
        newLogger := *l
        newLogger.context = make(map[string]string)
        for k, v := range l.context </span><span class="cov0" title="0">{
                newLogger.context[k] = v
        }</span>
        <span class="cov0" title="0">newLogger.context[key] = value
        return &amp;newLogger</span>
}

// WithCorrelationID adds a correlation ID to the logger
func (l *Logger) WithCorrelationID(correlationID string) *Logger <span class="cov0" title="0">{
        return l.WithContext("correlationId", correlationID)
}</span>

// WithProjectID adds a project ID to the logger
func (l *Logger) WithProjectID(projectID string) *Logger <span class="cov0" title="0">{
        return l.WithContext("projectId", projectID)
}</span>

// WithUserID adds a user ID to the logger
func (l *Logger) WithUserID(userID string) *Logger <span class="cov0" title="0">{
        return l.WithContext("userId", userID)
}</span>

// WithOperation adds an operation name to the logger
func (l *Logger) WithOperation(operation string) *Logger <span class="cov0" title="0">{
        return l.WithContext("operation", operation)
}</span>

// Debug logs a debug message
func (l *Logger) Debug(message string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= LogLevelDebug </span><span class="cov0" title="0">{
                l.log(LogLevelDebug, message, args...)
        }</span>
}

// Info logs an info message
func (l *Logger) Info(message string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= LogLevelInfo </span><span class="cov0" title="0">{
                l.log(LogLevelInfo, message, args...)
        }</span>
}

// Warn logs a warning message
func (l *Logger) Warn(message string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= LogLevelWarn </span><span class="cov0" title="0">{
                l.log(LogLevelWarn, message, args...)
        }</span>
}

// Error logs an error message
func (l *Logger) Error(message string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= LogLevelError </span><span class="cov0" title="0">{
                l.log(LogLevelError, message, args...)
        }</span>
}

// Fatal logs a fatal message and exits
func (l *Logger) Fatal(message string, args ...interface{}) <span class="cov0" title="0">{
        l.log(LogLevelFatal, message, args...)
        os.Exit(1)
}</span>

// LogError logs an APIError with full context
func (l *Logger) LogError(err *APIError) <span class="cov0" title="0">{
        entry := LogEntry{
                Timestamp:     time.Now(),
                Level:         LogLevelError,
                Message:       err.Message,
                Error:         err.Error(),
                CorrelationID: err.CorrelationID,
                Component:     l.component,
                Context:       make(map[string]string),
        }

        // Add error context
        if err.Context != nil </span><span class="cov0" title="0">{
                entry.Operation = err.Context.Operation
                entry.ProjectID = err.Context.ProjectID
                entry.UserID = err.Context.UserID
                entry.SessionID = err.Context.SessionID
                entry.RequestID = err.Context.RequestID
                entry.StackTrace = err.Context.StackTrace
                
                // Add metadata to context
                for k, v := range err.Context.Metadata </span><span class="cov0" title="0">{
                        entry.Context[k] = v
                }</span>
        }

        // Add error details to context
        <span class="cov0" title="0">for k, v := range err.Details </span><span class="cov0" title="0">{
                entry.Context[k] = v
        }</span>

        // Add logger context
        <span class="cov0" title="0">for k, v := range l.context </span><span class="cov0" title="0">{
                entry.Context[k] = v
        }</span>

        <span class="cov0" title="0">l.writeEntry(entry)</span>
}

// LogOperation logs the start and end of an operation
func (l *Logger) LogOperation(operation string, fn func() error) error <span class="cov0" title="0">{
        startTime := time.Now()
        
        l.WithOperation(operation).Info("Operation started")
        
        err := fn()
        
        duration := time.Since(startTime)
        
        if err != nil </span><span class="cov0" title="0">{
                l.WithOperation(operation).WithContext("duration", duration.String()).Error("Operation failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                l.WithOperation(operation).WithContext("duration", duration.String()).Info("Operation completed")
        }</span>
        
        <span class="cov0" title="0">return err</span>
}

// LogRetry logs retry attempts
func (l *Logger) LogRetry(operation string, attempt int, maxAttempts int, err error, delay time.Duration) <span class="cov0" title="0">{
        l.WithOperation(operation).WithContext("attempt", fmt.Sprintf("%d/%d", attempt, maxAttempts)).
                WithContext("delay", delay.String()).
                Warn("Operation failed, retrying: %v", err)
}</span>

// log is the internal logging method
func (l *Logger) log(level LogLevel, message string, args ...interface{}) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                message = fmt.Sprintf(message, args...)
        }</span>

        <span class="cov0" title="0">entry := LogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Message:   message,
                Component: l.component,
                Context:   make(map[string]string),
        }

        // Add logger context
        for k, v := range l.context </span><span class="cov0" title="0">{
                entry.Context[k] = v
        }</span>

        // Add stack trace for errors
        <span class="cov0" title="0">if level &gt;= LogLevelError </span><span class="cov0" title="0">{
                entry.StackTrace = getStackTrace(3) // Skip this method, log method, and caller
        }</span>

        <span class="cov0" title="0">l.writeEntry(entry)</span>
}

// writeEntry writes a log entry to all outputs
func (l *Logger) writeEntry(entry LogEntry) <span class="cov0" title="0">{
        var output string
        
        if l.jsonFormat </span><span class="cov0" title="0">{
                jsonData, err := json.Marshal(entry)
                if err != nil </span><span class="cov0" title="0">{
                        // Fallback to simple format if JSON marshaling fails
                        output = fmt.Sprintf("[%s] %s %s: %s\n",
                                entry.Timestamp.Format(time.RFC3339),
                                entry.Level.String(),
                                entry.Component,
                                entry.Message)
                }</span> else<span class="cov0" title="0"> {
                        output = string(jsonData) + "\n"
                }</span>
        } else<span class="cov0" title="0"> {
                // Human-readable format
                output = fmt.Sprintf("[%s] %s %s: %s",
                        entry.Timestamp.Format("2006-01-02 15:04:05"),
                        entry.Level.String(),
                        entry.Component,
                        entry.Message)
                
                if len(entry.Context) &gt; 0 </span><span class="cov0" title="0">{
                        output += " {"
                        first := true
                        for k, v := range entry.Context </span><span class="cov0" title="0">{
                                if !first </span><span class="cov0" title="0">{
                                        output += ", "
                                }</span>
                                <span class="cov0" title="0">output += fmt.Sprintf("%s: %s", k, v)
                                first = false</span>
                        }
                        <span class="cov0" title="0">output += "}"</span>
                }
                <span class="cov0" title="0">output += "\n"</span>
        }

        <span class="cov0" title="0">for _, writer := range l.outputs </span><span class="cov0" title="0">{
                writer.Write([]byte(output))
        }</span>
}

// SetJSONFormat sets whether to output logs in JSON format
func (l *Logger) SetJSONFormat(jsonFormat bool) <span class="cov0" title="0">{
        l.jsonFormat = jsonFormat
}</span>

// SetLevel sets the minimum log level
func (l *Logger) SetLevel(level LogLevel) <span class="cov0" title="0">{
        l.level = level
}</span>

// AddOutput adds an output writer
func (l *Logger) AddOutput(writer io.Writer) <span class="cov0" title="0">{
        l.outputs = append(l.outputs, writer)
}</span>

// ErrorReporter handles error reporting to external services
type ErrorReporter struct {
        logger    *Logger
        enabled   bool
        endpoints []string
}

// NewErrorReporter creates a new error reporter
func NewErrorReporter(logger *Logger) *ErrorReporter <span class="cov0" title="0">{
        return &amp;ErrorReporter{
                logger:  logger,
                enabled: true,
        }
}</span>

// ReportError reports an error to external services
func (er *ErrorReporter) ReportError(err *APIError) <span class="cov0" title="0">{
        if !er.enabled </span><span class="cov0" title="0">{
                return
        }</span>

        // Log the error locally
        <span class="cov0" title="0">er.logger.LogError(err)

        // Here you could send the error to external services like:
        // - Sentry
        // - Rollbar
        // - Custom monitoring endpoints
        // - Email notifications
        // - Slack webhooks
        
        // For now, we'll just log that we would report it
        er.logger.Info("Error reported to monitoring services", 
                "correlationId", err.CorrelationID,
                "errorType", err.Type,
                "errorCode", err.Code)</span>
}

// Enable enables error reporting
func (er *ErrorReporter) Enable() <span class="cov0" title="0">{
        er.enabled = true
}</span>

// Disable disables error reporting
func (er *ErrorReporter) Disable() <span class="cov0" title="0">{
        er.enabled = false
}</span>

// Note: getStackTrace is defined in errors.go</pre>
		
		<pre class="file" id="file8" style="display: none">package app

import (
        "runtime"
        "sync"
        "time"
)

// PerformanceMetrics tracks application performance metrics
type PerformanceMetrics struct {
        StartupTime       time.Duration            `json:"startup_time"`
        MemoryUsage       int64                    `json:"memory_usage"`
        GenerationTimes   map[string]time.Duration `json:"generation_times"`
        DatabaseOpTimes   map[string]time.Duration `json:"database_op_times"`
        FileOpTimes       map[string]time.Duration `json:"file_op_times"`
        LastUpdated       time.Time                `json:"last_updated"`
        mutex             sync.RWMutex
}

// PerformanceMonitor handles performance monitoring
type PerformanceMonitor struct {
        metrics   *PerformanceMetrics
        startTime time.Time
        mutex     sync.RWMutex
}

// NewPerformanceMonitor creates a new performance monitor
func NewPerformanceMonitor() *PerformanceMonitor <span class="cov8" title="1">{
        return &amp;PerformanceMonitor{
                metrics: &amp;PerformanceMetrics{
                        GenerationTimes: make(map[string]time.Duration),
                        DatabaseOpTimes: make(map[string]time.Duration),
                        FileOpTimes:     make(map[string]time.Duration),
                },
                startTime: time.Now(),
        }
}</span>

// RecordStartupTime records the application startup time
func (pm *PerformanceMonitor) RecordStartupTime(duration time.Duration) <span class="cov0" title="0">{
        pm.mutex.Lock()
        defer pm.mutex.Unlock()
        pm.metrics.StartupTime = duration
        pm.metrics.LastUpdated = time.Now()
}</span>

// RecordMemoryUsage records current memory usage
func (pm *PerformanceMonitor) RecordMemoryUsage() <span class="cov0" title="0">{
        pm.mutex.Lock()
        defer pm.mutex.Unlock()
        
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        pm.metrics.MemoryUsage = int64(m.Alloc)
        pm.metrics.LastUpdated = time.Now()
}</span>

// RecordGenerationTime records generation time for a specific operation
func (pm *PerformanceMonitor) RecordGenerationTime(operation string, duration time.Duration) <span class="cov0" title="0">{
        pm.mutex.Lock()
        defer pm.mutex.Unlock()
        pm.metrics.GenerationTimes[operation] = duration
        pm.metrics.LastUpdated = time.Now()
}</span>

// RecordDatabaseOpTime records database operation time
func (pm *PerformanceMonitor) RecordDatabaseOpTime(operation string, duration time.Duration) <span class="cov0" title="0">{
        pm.mutex.Lock()
        defer pm.mutex.Unlock()
        pm.metrics.DatabaseOpTimes[operation] = duration
        pm.metrics.LastUpdated = time.Now()
}</span>

// RecordFileOpTime records file operation time
func (pm *PerformanceMonitor) RecordFileOpTime(operation string, duration time.Duration) <span class="cov0" title="0">{
        pm.mutex.Lock()
        defer pm.mutex.Unlock()
        pm.metrics.FileOpTimes[operation] = duration
        pm.metrics.LastUpdated = time.Now()
}</span>

// GetMetrics returns current performance metrics
func (pm *PerformanceMonitor) GetMetrics() *PerformanceMetrics <span class="cov0" title="0">{
        pm.mutex.RLock()
        defer pm.mutex.RUnlock()
        
        // Update memory usage before returning metrics
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        // Create a copy to avoid race conditions
        metrics := &amp;PerformanceMetrics{
                StartupTime:     pm.metrics.StartupTime,
                MemoryUsage:     int64(m.Alloc),
                GenerationTimes: make(map[string]time.Duration),
                DatabaseOpTimes: make(map[string]time.Duration),
                FileOpTimes:     make(map[string]time.Duration),
                LastUpdated:     time.Now(),
        }
        
        // Copy maps
        for k, v := range pm.metrics.GenerationTimes </span><span class="cov0" title="0">{
                metrics.GenerationTimes[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range pm.metrics.DatabaseOpTimes </span><span class="cov0" title="0">{
                metrics.DatabaseOpTimes[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range pm.metrics.FileOpTimes </span><span class="cov0" title="0">{
                metrics.FileOpTimes[k] = v
        }</span>
        
        <span class="cov0" title="0">return metrics</span>
}

// StartTimer returns a function that records the duration when called
func (pm *PerformanceMonitor) StartTimer(category, operation string) func() <span class="cov0" title="0">{
        start := time.Now()
        return func() </span><span class="cov0" title="0">{
                duration := time.Since(start)
                switch category </span>{
                case "generation":<span class="cov0" title="0">
                        pm.RecordGenerationTime(operation, duration)</span>
                case "database":<span class="cov0" title="0">
                        pm.RecordDatabaseOpTime(operation, duration)</span>
                case "file":<span class="cov0" title="0">
                        pm.RecordFileOpTime(operation, duration)</span>
                }
        }
}

// GetMemoryUsageBytes returns current memory usage in bytes
func (pm *PerformanceMonitor) GetMemoryUsageBytes() int64 <span class="cov0" title="0">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        return int64(m.Alloc)
}</span>

// GetMemoryUsageMB returns current memory usage in MB
func (pm *PerformanceMonitor) GetMemoryUsageMB() float64 <span class="cov0" title="0">{
        return float64(pm.GetMemoryUsageBytes()) / 1024 / 1024
}</span>

// IsMemoryWithinLimit checks if memory usage is within the specified limit
func (pm *PerformanceMonitor) IsMemoryWithinLimit(limitMB float64) bool <span class="cov0" title="0">{
        return pm.GetMemoryUsageMB() &lt;= limitMB
}</span>

// ForceGC forces garbage collection and records memory usage
func (pm *PerformanceMonitor) ForceGC() <span class="cov0" title="0">{
        runtime.GC()
        pm.RecordMemoryUsage()
}</span>

// GetUptimeSeconds returns application uptime in seconds
func (pm *PerformanceMonitor) GetUptimeSeconds() float64 <span class="cov0" title="0">{
        return time.Since(pm.startTime).Seconds()
}</pre>
		
		<pre class="file" id="file9" style="display: none">package app

import (
        "encoding/json"
        "fmt"
        "time"

        "MCPWeaver/internal/database"
        "github.com/wailsapp/wails/v2/pkg/runtime"
)

// CreateProject creates a new project with the given configuration
func (a *App) CreateProject(request CreateProjectRequest) (*Project, error) <span class="cov0" title="0">{
        // Validate input
        if request.Name == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Project name is required", nil)
        }</span>
        
        <span class="cov0" title="0">if request.OutputPath == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Output path is required", nil)
        }</span>

        // Check if project with same name already exists
        <span class="cov0" title="0">existing, err := a.projectRepo.GetByName(request.Name)
        if err != nil &amp;&amp; err.Error() != "project not found" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to check existing project", nil)
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Project with this name already exists", nil)
        }</span>

        // Serialize settings to JSON
        <span class="cov0" title="0">settingsJSON, err := json.Marshal(request.Settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to serialize settings", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Create database project
        <span class="cov0" title="0">dbProject := &amp;database.Project{
                ID:              fmt.Sprintf("proj_%d", time.Now().UnixNano()),
                Name:            request.Name,
                SpecPath:        request.SpecPath,
                SpecURL:         request.SpecURL,
                OutputPath:      request.OutputPath,
                Settings:        string(settingsJSON),
                Status:          string(ProjectStatusCreated),
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
                GenerationCount: 0,
        }

        // Save to database
        err = a.projectRepo.Create(dbProject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to create project", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Convert to API project
        <span class="cov0" title="0">project := a.dbProjectToAPI(dbProject)

        // Add to recent projects
        a.addToRecentProjects(project.ID)

        // Emit event
        runtime.EventsEmit(a.ctx, "project:created", project)

        // Send notification
        a.emitNotification("success", "Project Created", fmt.Sprintf("Project '%s' has been created successfully", project.Name))

        return project, nil</span>
}

// GetProjects returns all projects
func (a *App) GetProjects() ([]*Project, error) <span class="cov0" title="0">{
        dbProjects, err := a.projectRepo.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to retrieve projects", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">projects := make([]*Project, len(dbProjects))
        for i, dbProject := range dbProjects </span><span class="cov0" title="0">{
                projects[i] = a.dbProjectToAPI(dbProject)
        }</span>

        <span class="cov0" title="0">return projects, nil</span>
}

// GetProject returns a specific project by ID
func (a *App) GetProject(id string) (*Project, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Project ID is required", nil)
        }</span>

        <span class="cov0" title="0">dbProject, err := a.projectRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "project not found" </span><span class="cov0" title="0">{
                        return nil, a.createAPIError("not_found", ErrCodeNotFound, "Project not found", nil)
                }</span>
                <span class="cov0" title="0">return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to retrieve project", map[string]string{
                        "error": err.Error(),
                })</span>
        }

        <span class="cov0" title="0">return a.dbProjectToAPI(dbProject), nil</span>
}

// UpdateProject updates an existing project
func (a *App) UpdateProject(id string, updates ProjectUpdateRequest) (*Project, error) <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Project ID is required", nil)
        }</span>

        // Get existing project
        <span class="cov0" title="0">dbProject, err := a.projectRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "project not found" </span><span class="cov0" title="0">{
                        return nil, a.createAPIError("not_found", ErrCodeNotFound, "Project not found", nil)
                }</span>
                <span class="cov0" title="0">return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to retrieve project", map[string]string{
                        "error": err.Error(),
                })</span>
        }

        // Apply updates
        <span class="cov0" title="0">if updates.Name != nil </span><span class="cov0" title="0">{
                dbProject.Name = *updates.Name
        }</span>
        <span class="cov0" title="0">if updates.SpecPath != nil </span><span class="cov0" title="0">{
                dbProject.SpecPath = *updates.SpecPath
        }</span>
        <span class="cov0" title="0">if updates.SpecURL != nil </span><span class="cov0" title="0">{
                dbProject.SpecURL = *updates.SpecURL
        }</span>
        <span class="cov0" title="0">if updates.OutputPath != nil </span><span class="cov0" title="0">{
                dbProject.OutputPath = *updates.OutputPath
        }</span>
        <span class="cov0" title="0">if updates.Settings != nil </span><span class="cov0" title="0">{
                // Serialize updated settings to JSON
                settingsJSON, err := json.Marshal(updates.Settings)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to serialize settings", map[string]string{
                                "error": err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">dbProject.Settings = string(settingsJSON)</span>
        }

        <span class="cov0" title="0">dbProject.UpdatedAt = time.Now()

        // Save to database
        err = a.projectRepo.Update(dbProject)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to update project", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Convert to API project
        <span class="cov0" title="0">project := a.dbProjectToAPI(dbProject)

        // Emit event
        runtime.EventsEmit(a.ctx, "project:updated", project)

        // Send notification
        a.emitNotification("success", "Project Updated", fmt.Sprintf("Project '%s' has been updated successfully", project.Name))

        return project, nil</span>
}

// DeleteProject deletes a project by ID
func (a *App) DeleteProject(id string) error <span class="cov0" title="0">{
        if id == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Project ID is required", nil)
        }</span>

        // Get project to check if it exists
        <span class="cov0" title="0">dbProject, err := a.projectRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "project not found" </span><span class="cov0" title="0">{
                        return a.createAPIError("not_found", ErrCodeNotFound, "Project not found", nil)
                }</span>
                <span class="cov0" title="0">return a.createAPIError("internal", ErrCodeInternalError, "Failed to retrieve project", map[string]string{
                        "error": err.Error(),
                })</span>
        }

        // Delete from database
        <span class="cov0" title="0">err = a.projectRepo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to delete project", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Remove from recent projects
        <span class="cov0" title="0">a.removeFromRecentProjects(id)

        // Emit event
        runtime.EventsEmit(a.ctx, "project:deleted", id)

        // Send notification
        a.emitNotification("success", "Project Deleted", fmt.Sprintf("Project '%s' has been deleted successfully", dbProject.Name))

        return nil</span>
}

// GetRecentProjects returns recently accessed projects
func (a *App) GetRecentProjects() ([]*Project, error) <span class="cov0" title="0">{
        projects := make([]*Project, 0)
        
        for _, projectID := range a.settings.RecentProjects </span><span class="cov0" title="0">{
                project, err := a.GetProject(projectID)
                if err == nil </span><span class="cov0" title="0">{
                        projects = append(projects, project)
                }</span>
        }

        <span class="cov0" title="0">return projects, nil</span>
}

// SearchProjects searches for projects by name
func (a *App) SearchProjects(query string) ([]*Project, error) <span class="cov0" title="0">{
        if query == "" </span><span class="cov0" title="0">{
                return a.GetProjects()
        }</span>

        <span class="cov0" title="0">dbProjects, err := a.projectRepo.SearchByName(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to search projects", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">projects := make([]*Project, len(dbProjects))
        for i, dbProject := range dbProjects </span><span class="cov0" title="0">{
                projects[i] = a.dbProjectToAPI(dbProject)
        }</span>

        <span class="cov0" title="0">return projects, nil</span>
}

// ExportProject exports a project to a JSON file
func (a *App) ExportProject(projectID string) (string, error) <span class="cov0" title="0">{
        if projectID == "" </span><span class="cov0" title="0">{
                return "", a.createAPIError("validation", ErrCodeValidation, "Project ID is required", nil)
        }</span>

        <span class="cov0" title="0">project, err := a.GetProject(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create export data
        <span class="cov0" title="0">exportData := map[string]interface{}{
                "version":   "1.0.0",
                "project":   project,
                "exportedAt": time.Now().Format(time.RFC3339),
        }

        // Marshal to JSON
        jsonData, err := json.MarshalIndent(exportData, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("internal", ErrCodeInternalError, "Failed to export project", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return string(jsonData), nil</span>
}

// ImportProject imports a project from JSON data
func (a *App) ImportProject(jsonData string) (*Project, error) <span class="cov0" title="0">{
        if jsonData == "" </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "JSON data is required", nil)
        }</span>

        // Parse JSON
        <span class="cov0" title="0">var exportData map[string]interface{}
        if err := json.Unmarshal([]byte(jsonData), &amp;exportData); err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Invalid JSON format", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Extract project data
        <span class="cov0" title="0">projectData, ok := exportData["project"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Invalid project data format", nil)
        }</span>

        // Convert to project struct
        <span class="cov0" title="0">projectJSON, err := json.Marshal(projectData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to process project data", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov0" title="0">var importedProject Project
        if err := json.Unmarshal(projectJSON, &amp;importedProject); err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Invalid project structure", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Create new project from imported data
        <span class="cov0" title="0">createRequest := CreateProjectRequest{
                Name:       importedProject.Name + " (Imported)",
                SpecPath:   importedProject.SpecPath,
                SpecURL:    importedProject.SpecURL,
                OutputPath: importedProject.OutputPath,
                Settings:   importedProject.Settings,
        }

        newProject, err := a.CreateProject(createRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Send notification
        <span class="cov0" title="0">a.emitNotification("success", "Project Imported", fmt.Sprintf("Project '%s' has been imported successfully", newProject.Name))

        return newProject, nil</span>
}

// dbProjectToAPI converts a database project to API project
func (a *App) dbProjectToAPI(dbProject *database.Project) *Project <span class="cov0" title="0">{
        var lastGenerated *time.Time
        if dbProject.LastGenerated != nil </span><span class="cov0" title="0">{
                lastGenerated = dbProject.LastGenerated
        }</span>

        // Deserialize settings from JSON
        <span class="cov0" title="0">var settings ProjectSettings
        if err := json.Unmarshal([]byte(dbProject.Settings), &amp;settings); err != nil </span><span class="cov0" title="0">{
                // Use default settings if deserialization fails
                settings = ProjectSettings{
                        PackageName:     "generated-server",
                        ServerPort:      8080,
                        EnableLogging:   true,
                        LogLevel:        "info",
                        CustomTemplates: []string{},
                }
        }</span>

        <span class="cov0" title="0">return &amp;Project{
                ID:              dbProject.ID,
                Name:            dbProject.Name,
                SpecPath:        dbProject.SpecPath,
                SpecURL:         dbProject.SpecURL,
                OutputPath:      dbProject.OutputPath,
                Settings:        settings,
                Status:          ProjectStatus(dbProject.Status),
                CreatedAt:       dbProject.CreatedAt,
                UpdatedAt:       dbProject.UpdatedAt,
                LastGenerated:   lastGenerated,
                GenerationCount: dbProject.GenerationCount,
        }</span>
}

// addToRecentProjects adds a project to the recent projects list
func (a *App) addToRecentProjects(projectID string) <span class="cov0" title="0">{
        // Remove if already exists
        a.removeFromRecentProjects(projectID)
        
        // Add to beginning
        a.settings.RecentProjects = append([]string{projectID}, a.settings.RecentProjects...)
        
        // Keep only last 10
        if len(a.settings.RecentProjects) &gt; 10 </span><span class="cov0" title="0">{
                a.settings.RecentProjects = a.settings.RecentProjects[:10]
        }</span>
}

// removeFromRecentProjects removes a project from the recent projects list
func (a *App) removeFromRecentProjects(projectID string) <span class="cov0" title="0">{
        for i, id := range a.settings.RecentProjects </span><span class="cov0" title="0">{
                if id == projectID </span><span class="cov0" title="0">{
                        a.settings.RecentProjects = append(a.settings.RecentProjects[:i], a.settings.RecentProjects[i+1:]...)
                        break</span>
                }
        }
}</pre>
		
		<pre class="file" id="file10" style="display: none">package app

import (
        "context"
        "fmt"
        "math/rand"
        "strings"
        "time"
)

// RetryManager handles retry logic with exponential backoff
type RetryManager struct {
        defaultPolicy RetryPolicy
        errorManager  *ErrorManager
}

// NewRetryManager creates a new retry manager
func NewRetryManager(errorManager *ErrorManager) *RetryManager <span class="cov0" title="0">{
        return &amp;RetryManager{
                defaultPolicy: DefaultRetryPolicy(),
                errorManager:  errorManager,
        }
}</span>

// RetryResult contains the result of a retry operation
type RetryResult struct {
        Success     bool          `json:"success"`
        Attempts    int           `json:"attempts"`
        LastError   error         `json:"lastError,omitempty"`
        TotalDelay  time.Duration `json:"totalDelay"`
        StartTime   time.Time     `json:"startTime"`
        EndTime     time.Time     `json:"endTime"`
}

// RetryFunc is a function that can be retried
type RetryFunc func() error

// RetryWithPolicy executes a function with retry logic using the specified policy
func (rm *RetryManager) RetryWithPolicy(ctx context.Context, policy RetryPolicy, fn RetryFunc) *RetryResult <span class="cov0" title="0">{
        result := &amp;RetryResult{
                Success:   false,
                Attempts:  0,
                StartTime: time.Now(),
        }

        var lastError error
        delay := policy.InitialDelay

        for attempt := 0; attempt &lt;= policy.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                result.Attempts++

                // Execute the function
                err := fn()
                if err == nil </span><span class="cov0" title="0">{
                        result.Success = true
                        result.EndTime = time.Now()
                        return result
                }</span>

                <span class="cov0" title="0">lastError = err

                // Check if error is retryable
                if !rm.isRetryableError(err, policy) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Don't sleep after the last attempt
                <span class="cov0" title="0">if attempt &lt; policy.MaxRetries </span><span class="cov0" title="0">{
                        // Check context cancellation
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                lastError = ctx.Err()
                                break</span>
                        }

                        // Calculate delay with exponential backoff
                        <span class="cov0" title="0">actualDelay := rm.calculateDelay(delay, policy)
                        result.TotalDelay += actualDelay

                        // Sleep with context cancellation support
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                lastError = ctx.Err()
                                goto done</span>
                        case &lt;-time.After(actualDelay):<span class="cov0" title="0"></span>
                        }

                        // Increase delay for next attempt
                        <span class="cov0" title="0">delay = time.Duration(float64(delay) * policy.BackoffMultiplier)
                        if delay &gt; policy.MaxDelay </span><span class="cov0" title="0">{
                                delay = policy.MaxDelay
                        }</span>
                }
        }

done:
        <span class="cov0" title="0">result.LastError = lastError
        result.EndTime = time.Now()
        return result</span>
}

// Retry executes a function with default retry policy
func (rm *RetryManager) Retry(ctx context.Context, fn RetryFunc) *RetryResult <span class="cov0" title="0">{
        return rm.RetryWithPolicy(ctx, rm.defaultPolicy, fn)
}</span>

// RetryWithTimeout executes a function with retry logic and timeout
func (rm *RetryManager) RetryWithTimeout(timeout time.Duration, fn RetryFunc) *RetryResult <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        
        return rm.Retry(ctx, fn)
}</span>

// RetryAsync executes a function with retry logic asynchronously
func (rm *RetryManager) RetryAsync(ctx context.Context, fn RetryFunc, callback func(*RetryResult)) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                result := rm.Retry(ctx, fn)
                if callback != nil </span><span class="cov0" title="0">{
                        callback(result)
                }</span>
        }()
}

// RetryWithBackoff creates a custom retry policy with exponential backoff
func (rm *RetryManager) RetryWithBackoff(ctx context.Context, maxRetries int, initialDelay time.Duration, maxDelay time.Duration, fn RetryFunc) *RetryResult <span class="cov0" title="0">{
        policy := RetryPolicy{
                MaxRetries:        maxRetries,
                InitialDelay:      initialDelay,
                MaxDelay:          maxDelay,
                BackoffMultiplier: 2.0,
                JitterEnabled:     true,
                RetryableErrors:   rm.defaultPolicy.RetryableErrors,
        }
        
        return rm.RetryWithPolicy(ctx, policy, fn)
}</span>

// RetryOperation is a high-level wrapper for common retry operations
func (rm *RetryManager) RetryOperation(ctx context.Context, operationName string, fn RetryFunc) error <span class="cov0" title="0">{
        result := rm.Retry(ctx, fn)
        
        if !result.Success </span><span class="cov0" title="0">{
                // Create a detailed error with retry information
                details := map[string]string{
                        "operation":     operationName,
                        "attempts":      fmt.Sprintf("%d", result.Attempts),
                        "total_delay":   result.TotalDelay.String(),
                        "duration":      result.EndTime.Sub(result.StartTime).String(),
                }
                
                if result.LastError != nil </span><span class="cov0" title="0">{
                        details["last_error"] = result.LastError.Error()
                }</span>
                
                <span class="cov0" title="0">return rm.errorManager.CreateError(
                        ErrorTypeSystem,
                        ErrCodeInternalError,
                        fmt.Sprintf("Operation '%s' failed after %d attempts", operationName, result.Attempts),
                        WithDetails(details),
                        WithSeverity(ErrorSeverityHigh),
                        WithSuggestions([]string{
                                "The operation was retried automatically but still failed",
                                "Check the underlying service availability",
                                "Try again later or contact support if the issue persists",
                        }),
                )</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Helper functions

// isRetryableError checks if an error should be retried
func (rm *RetryManager) isRetryableError(err error, policy RetryPolicy) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if it's an APIError and has retry information
        <span class="cov0" title="0">if apiErr, ok := err.(*APIError); ok </span><span class="cov0" title="0">{
                if !apiErr.Recoverable </span><span class="cov0" title="0">{
                        return false
                }</span>
                
                // Check if error code is in the retryable list
                <span class="cov0" title="0">for _, code := range policy.RetryableErrors </span><span class="cov0" title="0">{
                        if apiErr.Code == code </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }

        // For non-APIError types, check against common retryable errors
        <span class="cov0" title="0">errorStr := err.Error()
        retryablePatterns := []string{
                "connection refused",
                "timeout",
                "temporary failure",
                "service unavailable",
                "network error",
                "database connection",
                "context deadline exceeded",
        }

        for _, pattern := range retryablePatterns </span><span class="cov0" title="0">{
                if containsSubstring(errorStr, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// calculateDelay calculates the actual delay with jitter
func (rm *RetryManager) calculateDelay(baseDelay time.Duration, policy RetryPolicy) time.Duration <span class="cov0" title="0">{
        if !policy.JitterEnabled </span><span class="cov0" title="0">{
                return baseDelay
        }</span>

        // Add jitter to prevent thundering herd
        <span class="cov0" title="0">jitter := time.Duration(rand.Float64() * float64(baseDelay) * 0.1) // 10% jitter
        return baseDelay + jitter</span>
}

// containsSubstring checks if a string contains a substring (case-insensitive)
func containsSubstring(s, substr string) bool <span class="cov0" title="0">{
        return strings.Contains(strings.ToLower(s), strings.ToLower(substr))
}</span>

// CircuitBreaker implements the circuit breaker pattern
type CircuitBreaker struct {
        maxFailures     int
        timeout         time.Duration
        failureCount    int
        lastFailureTime time.Time
        state           CircuitState
        errorManager    *ErrorManager
}

// CircuitState represents the state of a circuit breaker
type CircuitState int

const (
        CircuitClosed CircuitState = iota
        CircuitOpen
        CircuitHalfOpen
)

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(maxFailures int, timeout time.Duration, errorManager *ErrorManager) *CircuitBreaker <span class="cov0" title="0">{
        return &amp;CircuitBreaker{
                maxFailures:  maxFailures,
                timeout:      timeout,
                state:        CircuitClosed,
                errorManager: errorManager,
        }
}</span>

// Execute executes a function with circuit breaker protection
func (cb *CircuitBreaker) Execute(fn func() error) error <span class="cov0" title="0">{
        if cb.state == CircuitOpen </span><span class="cov0" title="0">{
                if time.Since(cb.lastFailureTime) &gt; cb.timeout </span><span class="cov0" title="0">{
                        cb.state = CircuitHalfOpen
                }</span> else<span class="cov0" title="0"> {
                        return cb.errorManager.CreateError(
                                ErrorTypeSystem,
                                ErrCodeInternalError,
                                "Circuit breaker is open",
                                WithDetails(map[string]string{
                                        "state":         "open",
                                        "failure_count": fmt.Sprintf("%d", cb.failureCount),
                                        "timeout":       cb.timeout.String(),
                                }),
                                WithSeverity(ErrorSeverityMedium),
                                WithRecoverable(true),
                                WithRetryAfter(cb.timeout),
                        )
                }</span>
        }

        <span class="cov0" title="0">err := fn()
        if err != nil </span><span class="cov0" title="0">{
                cb.onFailure()
                return err
        }</span>

        <span class="cov0" title="0">cb.onSuccess()
        return nil</span>
}

// onFailure handles circuit breaker failure
func (cb *CircuitBreaker) onFailure() <span class="cov0" title="0">{
        cb.failureCount++
        cb.lastFailureTime = time.Now()

        if cb.failureCount &gt;= cb.maxFailures </span><span class="cov0" title="0">{
                cb.state = CircuitOpen
        }</span>
}

// onSuccess handles circuit breaker success
func (cb *CircuitBreaker) onSuccess() <span class="cov0" title="0">{
        cb.failureCount = 0
        cb.state = CircuitClosed
}</span>

// GetState returns the current circuit breaker state
func (cb *CircuitBreaker) GetState() CircuitState <span class="cov0" title="0">{
        return cb.state
}</span>

// IsOpen returns true if the circuit breaker is open
func (cb *CircuitBreaker) IsOpen() bool <span class="cov0" title="0">{
        return cb.state == CircuitOpen
}</span>

// BulkheadManager manages resource isolation using the bulkhead pattern
type BulkheadManager struct {
        semaphores map[string]chan struct{}
        limits     map[string]int
}

// NewBulkheadManager creates a new bulkhead manager
func NewBulkheadManager() *BulkheadManager <span class="cov0" title="0">{
        return &amp;BulkheadManager{
                semaphores: make(map[string]chan struct{}),
                limits:     make(map[string]int),
        }
}</span>

// SetLimit sets the concurrency limit for a resource
func (bm *BulkheadManager) SetLimit(resource string, limit int) <span class="cov0" title="0">{
        bm.limits[resource] = limit
        bm.semaphores[resource] = make(chan struct{}, limit)
}</span>

// Execute executes a function with bulkhead protection
func (bm *BulkheadManager) Execute(ctx context.Context, resource string, fn func() error) error <span class="cov0" title="0">{
        semaphore, exists := bm.semaphores[resource]
        if !exists </span><span class="cov0" title="0">{
                return fn() // No limit set, execute directly
        }</span>

        <span class="cov0" title="0">select </span>{
        case semaphore &lt;- struct{}{}:<span class="cov0" title="0"> // Acquire
                defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>() // Release
                <span class="cov0" title="0">return fn()</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}</pre>
		
		<pre class="file" id="file11" style="display: none">package app

import (
        "encoding/json"
        "os"
        "path/filepath"

        "github.com/wailsapp/wails/v2/pkg/runtime"
)

// GetSettings returns the current application settings
func (a *App) GetSettings() (*AppSettings, error) <span class="cov0" title="0">{
        if a.settings == nil </span><span class="cov0" title="0">{
                return getDefaultSettings(), nil
        }</span>
        <span class="cov0" title="0">return a.settings, nil</span>
}

// UpdateSettings updates the application settings
func (a *App) UpdateSettings(settings AppSettings) error <span class="cov0" title="0">{
        // Validate settings
        if err := a.validateSettings(&amp;settings); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update current settings
        <span class="cov0" title="0">a.settings = &amp;settings

        // Save settings to storage
        if err := a.saveSettingsToFile(); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to save settings", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Emit settings updated event
        <span class="cov0" title="0">runtime.EventsEmit(a.ctx, "settings:updated", settings)

        // Send notification
        a.emitNotification("success", "Settings Updated", "Application settings have been saved successfully")

        return nil</span>
}

// ResetSettings resets all settings to their default values
func (a *App) ResetSettings() error <span class="cov0" title="0">{
        // Reset to default settings
        a.settings = getDefaultSettings()

        // Save default settings to storage
        if err := a.saveSettingsToFile(); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to reset settings", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Emit settings reset event
        <span class="cov0" title="0">runtime.EventsEmit(a.ctx, "settings:reset", a.settings)

        // Send notification
        a.emitNotification("success", "Settings Reset", "Application settings have been reset to defaults")

        return nil</span>
}

// GetSettingsFilePath returns the path to the settings file
func (a *App) GetSettingsFilePath() string <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "./mcpweaver-settings.json"
        }</span>
        <span class="cov0" title="0">return filepath.Join(homeDir, ".mcpweaver", "settings.json")</span>
}

// saveSettingsToFile saves settings to a JSON file
func (a *App) saveSettingsToFile() error <span class="cov0" title="0">{
        settingsPath := a.GetSettingsFilePath()
        
        // Ensure directory exists
        dir := filepath.Dir(settingsPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Marshal settings to JSON
        <span class="cov0" title="0">data, err := json.MarshalIndent(a.settings, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write to file
        <span class="cov0" title="0">return os.WriteFile(settingsPath, data, 0644)</span>
}

// loadSettingsFromFile loads settings from a JSON file
func (a *App) loadSettingsFromFile() (*AppSettings, error) <span class="cov0" title="0">{
        settingsPath := a.GetSettingsFilePath()
        
        // Check if file exists
        if _, err := os.Stat(settingsPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return getDefaultSettings(), nil
        }</span>

        // Read file
        <span class="cov0" title="0">data, err := os.ReadFile(settingsPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unmarshal JSON
        <span class="cov0" title="0">var settings AppSettings
        if err := json.Unmarshal(data, &amp;settings); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;settings, nil</span>
}

// validateSettings validates the settings structure
func (a *App) validateSettings(settings *AppSettings) error <span class="cov0" title="0">{
        // Validate theme
        if settings.Theme != "light" &amp;&amp; settings.Theme != "dark" &amp;&amp; settings.Theme != "auto" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Invalid theme value", map[string]string{
                        "theme": settings.Theme,
                        "valid": "light, dark, auto",
                })
        }</span>

        // Validate language
        <span class="cov0" title="0">if settings.Language == "" </span><span class="cov0" title="0">{
                settings.Language = "en"
        }</span>

        // Validate window settings
        <span class="cov0" title="0">if settings.WindowSettings.Width &lt; 800 </span><span class="cov0" title="0">{
                settings.WindowSettings.Width = 800
        }</span>
        <span class="cov0" title="0">if settings.WindowSettings.Height &lt; 600 </span><span class="cov0" title="0">{
                settings.WindowSettings.Height = 600
        }</span>

        // Validate editor settings
        <span class="cov0" title="0">if settings.EditorSettings.FontSize &lt; 8 || settings.EditorSettings.FontSize &gt; 24 </span><span class="cov0" title="0">{
                settings.EditorSettings.FontSize = 14
        }</span>
        <span class="cov0" title="0">if settings.EditorSettings.TabSize &lt; 2 || settings.EditorSettings.TabSize &gt; 8 </span><span class="cov0" title="0">{
                settings.EditorSettings.TabSize = 4
        }</span>
        <span class="cov0" title="0">if settings.EditorSettings.FontFamily == "" </span><span class="cov0" title="0">{
                settings.EditorSettings.FontFamily = "Monaco"
        }</span>

        // Validate generation settings
        <span class="cov0" title="0">if settings.GenerationSettings.DefaultTemplate == "" </span><span class="cov0" title="0">{
                settings.GenerationSettings.DefaultTemplate = "default"
        }</span>

        // Validate default output path
        <span class="cov0" title="0">if settings.DefaultOutputPath == "" </span><span class="cov0" title="0">{
                settings.DefaultOutputPath = "./output"
        }</span>

        // Limit recent projects to 20
        <span class="cov0" title="0">if len(settings.RecentProjects) &gt; 20 </span><span class="cov0" title="0">{
                settings.RecentProjects = settings.RecentProjects[:20]
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateTheme updates just the theme setting
func (a *App) UpdateTheme(theme string) error <span class="cov0" title="0">{
        if theme != "light" &amp;&amp; theme != "dark" &amp;&amp; theme != "auto" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Invalid theme value", map[string]string{
                        "theme": theme,
                        "valid": "light, dark, auto",
                })
        }</span>

        <span class="cov0" title="0">a.settings.Theme = theme

        // Save settings
        if err := a.saveSettingsToFile(); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to save theme setting", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Emit theme change event
        <span class="cov0" title="0">runtime.EventsEmit(a.ctx, "theme:changed", theme)

        return nil</span>
}

// UpdateLanguage updates just the language setting
func (a *App) UpdateLanguage(language string) error <span class="cov0" title="0">{
        if language == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Language is required", nil)
        }</span>

        <span class="cov0" title="0">a.settings.Language = language

        // Save settings
        if err := a.saveSettingsToFile(); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to save language setting", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Emit language change event
        <span class="cov0" title="0">runtime.EventsEmit(a.ctx, "language:changed", language)

        return nil</span>
}

// UpdateWindowSettings updates the window settings
func (a *App) UpdateWindowSettings(windowSettings WindowSettings) error <span class="cov0" title="0">{
        // Validate window settings
        if windowSettings.Width &lt; 800 </span><span class="cov0" title="0">{
                windowSettings.Width = 800
        }</span>
        <span class="cov0" title="0">if windowSettings.Height &lt; 600 </span><span class="cov0" title="0">{
                windowSettings.Height = 600
        }</span>

        <span class="cov0" title="0">a.settings.WindowSettings = windowSettings

        // Save settings
        if err := a.saveSettingsToFile(); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to save window settings", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Emit window settings change event
        <span class="cov0" title="0">runtime.EventsEmit(a.ctx, "window:settings:changed", windowSettings)

        return nil</span>
}

// AddRecentProject adds a project to the recent projects list
func (a *App) AddRecentProject(projectID string) error <span class="cov0" title="0">{
        if projectID == "" </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Project ID is required", nil)
        }</span>

        // Use the helper function from projects.go
        <span class="cov0" title="0">a.addToRecentProjects(projectID)

        // Save settings
        if err := a.saveSettingsToFile(); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to save recent projects", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Emit recent projects updated event
        <span class="cov0" title="0">runtime.EventsEmit(a.ctx, "recent:projects:updated", a.settings.RecentProjects)

        return nil</span>
}

// ClearRecentProjects clears the recent projects list
func (a *App) ClearRecentProjects() error <span class="cov0" title="0">{
        a.settings.RecentProjects = []string{}

        // Save settings
        if err := a.saveSettingsToFile(); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to clear recent projects", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Emit recent projects cleared event
        <span class="cov0" title="0">runtime.EventsEmit(a.ctx, "recent:projects:cleared", nil)

        // Send notification
        a.emitNotification("success", "Recent Projects Cleared", "Recent projects list has been cleared")

        return nil</span>
}

// ExportSettings exports settings to a file
func (a *App) ExportSettings() (string, error) <span class="cov0" title="0">{
        // Marshal settings to JSON
        data, err := json.MarshalIndent(a.settings, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("internal", ErrCodeInternalError, "Failed to export settings", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Open save dialog
        <span class="cov0" title="0">filePath, err := a.SaveFile(string(data), "mcpweaver-settings.json", []FileFilter{
                {
                        DisplayName: "JSON Files",
                        Pattern:     "*.json",
                        Extensions:  []string{".json"},
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if filePath != "" </span><span class="cov0" title="0">{
                a.emitNotification("success", "Settings Exported", "Settings have been exported successfully")
        }</span>

        <span class="cov0" title="0">return filePath, nil</span>
}

// ImportSettings imports settings from a file
func (a *App) ImportSettings() error <span class="cov0" title="0">{
        // Open file dialog
        filePath, err := a.SelectFile([]FileFilter{
                {
                        DisplayName: "JSON Files",
                        Pattern:     "*.json",
                        Extensions:  []string{".json"},
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if filePath == "" </span><span class="cov0" title="0">{
                return nil // User cancelled
        }</span>

        // Read file
        <span class="cov0" title="0">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("file_system", ErrCodeFileAccess, "Failed to read settings file", map[string]string{
                        "path": filePath,
                        "error": err.Error(),
                })
        }</span>

        // Unmarshal JSON
        <span class="cov0" title="0">var settings AppSettings
        if err := json.Unmarshal(data, &amp;settings); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("validation", ErrCodeValidation, "Invalid settings file format", map[string]string{
                        "path": filePath,
                        "error": err.Error(),
                })
        }</span>

        // Validate imported settings
        <span class="cov0" title="0">if err := a.validateSettings(&amp;settings); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update current settings
        <span class="cov0" title="0">a.settings = &amp;settings

        // Save settings
        if err := a.saveSettingsToFile(); err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to save imported settings", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        // Emit settings imported event
        <span class="cov0" title="0">runtime.EventsEmit(a.ctx, "settings:imported", settings)

        // Send notification
        a.emitNotification("success", "Settings Imported", "Settings have been imported successfully")

        return nil</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package app

import (
        "fmt"
        "time"

        "MCPWeaver/internal/mapping"
)

// Project Management Types
type CreateProjectRequest struct {
        Name       string          `json:"name" validate:"required,min=1,max=100"`
        SpecPath   string          `json:"specPath,omitempty"`
        SpecURL    string          `json:"specUrl,omitempty"`
        OutputPath string          `json:"outputPath" validate:"required"`
        Settings   ProjectSettings `json:"settings"`
}

type ProjectUpdateRequest struct {
        Name       *string          `json:"name,omitempty"`
        SpecPath   *string          `json:"specPath,omitempty"`
        SpecURL    *string          `json:"specUrl,omitempty"`
        OutputPath *string          `json:"outputPath,omitempty"`
        Settings   *ProjectSettings `json:"settings,omitempty"`
}

type Project struct {
        ID              string           `json:"id"`
        Name            string           `json:"name"`
        SpecPath        string           `json:"specPath"`
        SpecURL         string           `json:"specUrl"`
        OutputPath      string           `json:"outputPath"`
        Settings        ProjectSettings  `json:"settings"`
        Status          ProjectStatus    `json:"status"`
        CreatedAt       time.Time        `json:"createdAt"`
        UpdatedAt       time.Time        `json:"updatedAt"`
        LastGenerated   *time.Time       `json:"lastGenerated,omitempty"`
        GenerationCount int              `json:"generationCount"`
}

type ProjectSettings struct {
        PackageName     string   `json:"packageName" validate:"required,alphanum"`
        ServerPort      int      `json:"serverPort" validate:"min=1000,max=65535"`
        EnableLogging   bool     `json:"enableLogging"`
        LogLevel        string   `json:"logLevel" validate:"oneof=debug info warn error"`
        CustomTemplates []string `json:"customTemplates,omitempty"`
}

type ProjectStatus string

const (
        ProjectStatusCreated    ProjectStatus = "created"
        ProjectStatusValidating ProjectStatus = "validating"
        ProjectStatusReady      ProjectStatus = "ready"
        ProjectStatusGenerating ProjectStatus = "generating"
        ProjectStatusError      ProjectStatus = "error"
)

// Generation Types
type GenerationJob struct {
        ID          string             `json:"id"`
        ProjectID   string             `json:"projectId"`
        Status      GenerationStatus   `json:"status"`
        Progress    float64            `json:"progress"`
        CurrentStep string             `json:"currentStep"`
        StartTime   time.Time          `json:"startTime"`
        EndTime     *time.Time         `json:"endTime,omitempty"`
        Results     *GenerationResults `json:"results,omitempty"`
        Errors      []GenerationError  `json:"errors,omitempty"`
        Warnings    []string           `json:"warnings,omitempty"`
}

type GenerationStatus string

const (
        GenerationStatusStarted    GenerationStatus = "started"
        GenerationStatusParsing    GenerationStatus = "parsing"
        GenerationStatusMapping    GenerationStatus = "mapping"
        GenerationStatusGenerating GenerationStatus = "generating"
        GenerationStatusValidating GenerationStatus = "validating"
        GenerationStatusCompleted  GenerationStatus = "completed"
        GenerationStatusFailed     GenerationStatus = "failed"
        GenerationStatusCancelled  GenerationStatus = "cancelled"
)

type GenerationResults struct {
        ServerPath     string            `json:"serverPath"`
        GeneratedFiles []GeneratedFile   `json:"generatedFiles"`
        MCPTools       []mapping.MCPTool `json:"mcpTools"`
        Statistics     GenerationStats   `json:"statistics"`
}

type GeneratedFile struct {
        Path        string `json:"path"`
        Type        string `json:"type"`
        Size        int    `json:"size"`
        LinesOfCode int    `json:"linesOfCode"`
}

type GenerationStats struct {
        TotalEndpoints  int           `json:"totalEndpoints"`
        GeneratedTools  int           `json:"generatedTools"`
        ProcessingTime  time.Duration `json:"processingTime"`
        SpecComplexity  string        `json:"specComplexity"`
        TemplateVersion string        `json:"templateVersion"`
}

type GenerationError struct {
        Type        string         `json:"type"`
        Message     string         `json:"message"`
        Details     string         `json:"details,omitempty"`
        Suggestions []string       `json:"suggestions,omitempty"`
        Location    *ErrorLocation `json:"location,omitempty"`
}

type ErrorLocation struct {
        File   string `json:"file"`
        Line   int    `json:"line"`
        Column int    `json:"column"`
}

// Validation Types
type ValidationResult struct {
        Valid          bool                `json:"valid"`
        Errors         []ValidationError   `json:"errors"`
        Warnings       []ValidationWarning `json:"warnings"`
        Suggestions    []string            `json:"suggestions"`
        SpecInfo       *SpecInfo           `json:"specInfo,omitempty"`
        ValidationTime time.Duration       `json:"validationTime"`
        CacheHit       bool                `json:"cacheHit"`
        ValidatedAt    time.Time           `json:"validatedAt"`
}

type ValidationError struct {
        Type     string         `json:"type"`
        Message  string         `json:"message"`
        Path     string         `json:"path"`
        Line     int            `json:"line,omitempty"`
        Column   int            `json:"column,omitempty"`
        Severity string         `json:"severity"`
        Code     string         `json:"code"`
        Location *ErrorLocation `json:"location,omitempty"`
}

type ValidationWarning struct {
        Type       string `json:"type"`
        Message    string `json:"message"`
        Path       string `json:"path"`
        Suggestion string `json:"suggestion"`
}

type SpecInfo struct {
        Version         string            `json:"version"`
        Title           string            `json:"title"`
        Description     string            `json:"description"`
        OperationCount  int               `json:"operationCount"`
        SchemaCount     int               `json:"schemaCount"`
        SecuritySchemes []SecurityScheme  `json:"securitySchemes"`
        Servers         []ServerInfo      `json:"servers"`
}

type SecurityScheme struct {
        Type        string `json:"type"`
        Name        string `json:"name"`
        Description string `json:"description"`
}

type ServerInfo struct {
        URL         string `json:"url"`
        Description string `json:"description"`
}

// File System Types
type FileFilter struct {
        DisplayName string   `json:"displayName"`
        Pattern     string   `json:"pattern"`
        Extensions  []string `json:"extensions"`
}

// Settings Types
type AppSettings struct {
        Theme              string             `json:"theme"`
        Language           string             `json:"language"`
        AutoSave           bool               `json:"autoSave"`
        DefaultOutputPath  string             `json:"defaultOutputPath"`
        RecentProjects     []string           `json:"recentProjects"`
        RecentFiles        []string           `json:"recentFiles"`
        WindowSettings     WindowSettings     `json:"windowSettings"`
        EditorSettings     EditorSettings     `json:"editorSettings"`
        GenerationSettings GenerationSettings `json:"generationSettings"`
}

type WindowSettings struct {
        Width     int  `json:"width"`
        Height    int  `json:"height"`
        Maximized bool `json:"maximized"`
        X         int  `json:"x"`
        Y         int  `json:"y"`
}

type EditorSettings struct {
        FontSize        int    `json:"fontSize"`
        FontFamily      string `json:"fontFamily"`
        TabSize         int    `json:"tabSize"`
        WordWrap        bool   `json:"wordWrap"`
        LineNumbers     bool   `json:"lineNumbers"`
        SyntaxHighlight bool   `json:"syntaxHighlight"`
}

type GenerationSettings struct {
        DefaultTemplate     string   `json:"defaultTemplate"`
        EnableValidation    bool     `json:"enableValidation"`
        AutoOpenOutput      bool     `json:"autoOpenOutput"`
        ShowAdvancedOptions bool     `json:"showAdvancedOptions"`
        BackupOnGenerate    bool     `json:"backupOnGenerate"`
        CustomTemplates     []string `json:"customTemplates"`
}

// Template Types
type Template struct {
        ID          string             `json:"id"`
        Name        string             `json:"name"`
        Description string             `json:"description"`
        Version     string             `json:"version"`
        Author      string             `json:"author"`
        Type        TemplateType       `json:"type"`
        Path        string             `json:"path"`
        IsBuiltIn   bool               `json:"isBuiltIn"`
        Variables   []TemplateVariable `json:"variables"`
        CreatedAt   time.Time          `json:"createdAt"`
        UpdatedAt   time.Time          `json:"updatedAt"`
}

type TemplateType string

const (
        TemplateTypeDefault TemplateType = "default"
        TemplateTypeCustom  TemplateType = "custom"
        TemplateTypePlugin  TemplateType = "plugin"
)

type TemplateVariable struct {
        Name         string `json:"name"`
        Description  string `json:"description"`
        Type         string `json:"type"`
        DefaultValue string `json:"defaultValue"`
        Required     bool   `json:"required"`
}

// Error Types
type APIError struct {
        Type          string            `json:"type"`
        Code          string            `json:"code"`
        Message       string            `json:"message"`
        Details       map[string]string `json:"details,omitempty"`
        Timestamp     time.Time         `json:"timestamp"`
        Suggestions   []string          `json:"suggestions,omitempty"`
        CorrelationID string            `json:"correlationId,omitempty"`
        Severity      ErrorSeverity     `json:"severity"`
        Recoverable   bool              `json:"recoverable"`
        RetryAfter    *time.Duration    `json:"retryAfter,omitempty"`
        Context       *ErrorContext     `json:"context,omitempty"`
}

// Error implements the error interface for APIError
func (e *APIError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// IsRetryable returns true if the error can be retried
func (e *APIError) IsRetryable() bool <span class="cov0" title="0">{
        return e.Recoverable &amp;&amp; e.RetryAfter != nil
}</span>

// GetRetryDelay returns the suggested retry delay
func (e *APIError) GetRetryDelay() time.Duration <span class="cov0" title="0">{
        if e.RetryAfter != nil </span><span class="cov0" title="0">{
                return *e.RetryAfter
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ErrorSeverity defines the severity level of an error
type ErrorSeverity string

const (
        ErrorSeverityLow      ErrorSeverity = "low"
        ErrorSeverityMedium   ErrorSeverity = "medium"
        ErrorSeverityHigh     ErrorSeverity = "high"
        ErrorSeverityCritical ErrorSeverity = "critical"
)

// ErrorContext provides additional context about where an error occurred
type ErrorContext struct {
        Operation   string            `json:"operation"`
        Component   string            `json:"component"`
        ProjectID   string            `json:"projectId,omitempty"`
        UserID      string            `json:"userId,omitempty"`
        SessionID   string            `json:"sessionId,omitempty"`
        RequestID   string            `json:"requestId,omitempty"`
        StackTrace  string            `json:"stackTrace,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
}

// ErrorCollection aggregates multiple errors for batch operations
type ErrorCollection struct {
        Errors      []APIError `json:"errors"`
        Warnings    []APIError `json:"warnings"`
        Operation   string     `json:"operation"`
        TotalItems  int        `json:"totalItems"`
        FailedItems int        `json:"failedItems"`
        Timestamp   time.Time  `json:"timestamp"`
}

// HasErrors returns true if there are any errors
func (ec *ErrorCollection) HasErrors() bool <span class="cov0" title="0">{
        return len(ec.Errors) &gt; 0
}</span>

// HasWarnings returns true if there are any warnings
func (ec *ErrorCollection) HasWarnings() bool <span class="cov0" title="0">{
        return len(ec.Warnings) &gt; 0
}</span>

// Error implements the error interface for ErrorCollection
func (ec *ErrorCollection) Error() string <span class="cov0" title="0">{
        if len(ec.Errors) == 0 </span><span class="cov0" title="0">{
                return "no errors"
        }</span>
        <span class="cov0" title="0">if len(ec.Errors) == 1 </span><span class="cov0" title="0">{
                return ec.Errors[0].Error()
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d errors occurred during %s", len(ec.Errors), ec.Operation)</span>
}

// RetryPolicy defines retry behavior for operations
type RetryPolicy struct {
        MaxRetries      int           `json:"maxRetries"`
        InitialDelay    time.Duration `json:"initialDelay"`
        MaxDelay        time.Duration `json:"maxDelay"`
        BackoffMultiplier float64     `json:"backoffMultiplier"`
        JitterEnabled   bool          `json:"jitterEnabled"`
        RetryableErrors []string      `json:"retryableErrors"`
}

// DefaultRetryPolicy returns a default retry policy
func DefaultRetryPolicy() RetryPolicy <span class="cov8" title="1">{
        return RetryPolicy{
                MaxRetries:        3,
                InitialDelay:      time.Second,
                MaxDelay:          30 * time.Second,
                BackoffMultiplier: 2.0,
                JitterEnabled:     true,
                RetryableErrors: []string{
                        ErrCodeNetworkError,
                        ErrCodeInternalError,
                        ErrCodeDatabaseError,
                },
        }
}</span>

// Error constants
const (
        ErrCodeValidation      = "VALIDATION_ERROR"
        ErrCodeNotFound        = "NOT_FOUND"
        ErrCodeInternalError   = "INTERNAL_ERROR"
        ErrCodeFileAccess      = "FILE_ACCESS_ERROR"
        ErrCodeNetworkError    = "NETWORK_ERROR"
        ErrCodeParsingError    = "PARSING_ERROR"
        ErrCodeGenerationError = "GENERATION_ERROR"
        ErrCodeDatabaseError   = "DATABASE_ERROR"
        ErrCodePermissionError = "PERMISSION_ERROR"
        ErrCodeRateLimitError  = "RATE_LIMIT_ERROR"
        ErrCodeTimeoutError    = "TIMEOUT_ERROR"
        ErrCodeConfigError     = "CONFIG_ERROR"
        ErrCodeAuthError       = "AUTH_ERROR"
)

// Error type constants
const (
        ErrorTypeValidation   = "validation"
        ErrorTypeSystem       = "system"
        ErrorTypeNetwork      = "network"
        ErrorTypeFileSystem   = "filesystem"
        ErrorTypeDatabase     = "database"
        ErrorTypeGeneration   = "generation"
        ErrorTypePermission   = "permission"
        ErrorTypeConfiguration = "configuration"
        ErrorTypeAuthentication = "authentication"
)

// Event Types
type GenerationProgress struct {
        JobID       string  `json:"jobId"`
        Progress    float64 `json:"progress"`
        CurrentStep string  `json:"currentStep"`
        Message     string  `json:"message"`
}

type Notification struct {
        Type    string   `json:"type"`
        Title   string   `json:"title"`
        Message string   `json:"message"`
        Actions []string `json:"actions,omitempty"`
}

type SystemError struct {
        Type        string    `json:"type"`
        Message     string    `json:"message"`
        Timestamp   time.Time `json:"timestamp"`
        Recoverable bool      `json:"recoverable"`
}

// Import/Export Types
type ImportResult struct {
        Content      string    `json:"content"`
        Valid        bool      `json:"valid"`
        SpecInfo     *SpecInfo `json:"specInfo,omitempty"`
        Errors       []string  `json:"errors,omitempty"`
        Warnings     []string  `json:"warnings,omitempty"`
        ImportedFrom string    `json:"importedFrom"` // "file" or "url"
        FilePath     string    `json:"filePath,omitempty"`
        SourceURL    string    `json:"sourceUrl,omitempty"`
        FileSize     int64     `json:"fileSize"`
        ImportedAt   time.Time `json:"importedAt"`
}

type ExportResult struct {
        ProjectID     string         `json:"projectId"`
        ProjectName   string         `json:"projectName"`
        TargetDir     string         `json:"targetDir"`
        ExportedFiles []ExportedFile `json:"exportedFiles"`
        TotalFiles    int            `json:"totalFiles"`
        TotalSize     int64          `json:"totalSize"`
        ExportedAt    time.Time      `json:"exportedAt"`
}

type ExportedFile struct {
        Name         string    `json:"name"`
        Path         string    `json:"path"`
        Size         int64     `json:"size"`
        ModifiedTime time.Time `json:"modifiedTime"`
}

type FileOperationProgress struct {
        OperationID        string `json:"operationId"`
        Type               string `json:"type"` // "import" or "export"
        Progress           int    `json:"progress"`
        CurrentFile        string `json:"currentFile"`
        TotalFiles         int    `json:"totalFiles"`
        ProcessedFiles     int    `json:"processedFiles"`
        StartTime          string `json:"startTime"`
        ElapsedTime        int64  `json:"elapsedTime"`
        EstimatedRemaining int64  `json:"estimatedRemaining"`
}

type RecentFile struct {
        Path         string `json:"path"`
        Name         string `json:"name"`
        Size         int64  `json:"size"`
        LastAccessed string `json:"lastAccessed"`
        Type         string `json:"type"` // "spec" or "export"
}</pre>
		
		<pre class="file" id="file13" style="display: none">package app

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "MCPWeaver/internal/database"
        "MCPWeaver/internal/parser"
        "MCPWeaver/internal/validator"
        "github.com/getkin/kin-openapi/openapi3"
)

// ValidateSpec validates an OpenAPI specification from a file path with caching
func (a *App) ValidateSpec(specPath string) (*ValidationResult, error) <span class="cov8" title="1">{
        if specPath == "" </span><span class="cov8" title="1">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "Specification path is required", nil)
        }</span>

        // Check validation cache first
        <span class="cov8" title="1">if a.validationCacheRepo != nil </span><span class="cov8" title="1">{
                specHash, err := a.validationCacheRepo.GenerateSpecHash(specPath)
                if err == nil </span><span class="cov8" title="1">{
                        cachedResult, err := a.validationCacheRepo.GetByHash(specHash)
                        if err == nil &amp;&amp; cachedResult != nil </span><span class="cov8" title="1">{
                                // Cache hit - deserialize result
                                var result ValidationResult
                                if err := json.Unmarshal([]byte(cachedResult.ValidationResult), &amp;result); err == nil </span><span class="cov8" title="1">{
                                        result.CacheHit = true
                                        return &amp;result, nil
                                }</span>
                        }
                }
        }

        // Cache miss - perform validation
        <span class="cov8" title="1">startTime := time.Now()
        
        // Use the comprehensive validator service
        result, err := a.validatorService.ValidateFile(a.ctx, specPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeInternalError, fmt.Sprintf("Validation failed: %v", err), nil)
        }</span>

        // Convert validator result to app result format
        <span class="cov8" title="1">appResult := a.convertValidatorResult(result)
        appResult.ValidationTime = time.Since(startTime)

        // Cache the result if caching is enabled
        if a.validationCacheRepo != nil </span><span class="cov8" title="1">{
                a.cacheValidationResult(specPath, "", appResult)
        }</span>

        <span class="cov8" title="1">return appResult, nil</span>
}

// ValidateURL validates an OpenAPI specification from a URL with caching
func (a *App) ValidateURL(url string) (*ValidationResult, error) <span class="cov8" title="1">{
        if url == "" </span><span class="cov8" title="1">{
                return nil, a.createAPIError("validation", ErrCodeValidation, "URL is required", nil)
        }</span>

        // Check validation cache first (using URL-based hash)
        <span class="cov8" title="1">if a.validationCacheRepo != nil </span><span class="cov8" title="1">{
                specHash := a.validationCacheRepo.GenerateURLHash(url, time.Now())
                cachedResult, err := a.validationCacheRepo.GetByHash(specHash)
                if err == nil &amp;&amp; cachedResult != nil </span><span class="cov0" title="0">{
                        // Cache hit - deserialize result
                        var result ValidationResult
                        if err := json.Unmarshal([]byte(cachedResult.ValidationResult), &amp;result); err == nil </span><span class="cov0" title="0">{
                                result.CacheHit = true
                                return &amp;result, nil
                        }</span>
                }
        }

        // Cache miss - perform validation
        <span class="cov8" title="1">startTime := time.Now()
        
        // Use the comprehensive validator service
        result, err := a.validatorService.ValidateURL(a.ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("validation", ErrCodeInternalError, fmt.Sprintf("Validation failed: %v", err), nil)
        }</span>

        // Convert validator result to app result format
        <span class="cov8" title="1">appResult := a.convertValidatorResult(result)
        appResult.ValidationTime = time.Since(startTime)

        // Cache the result if caching is enabled
        if a.validationCacheRepo != nil </span><span class="cov8" title="1">{
                a.cacheValidationResult("", url, appResult)
        }</span>

        <span class="cov8" title="1">return appResult, nil</span>
}

// convertValidatorResult converts validator.ValidationResult to app.ValidationResult
func (a *App) convertValidatorResult(vResult *validator.ValidationResult) *ValidationResult <span class="cov8" title="1">{
        result := &amp;ValidationResult{
                Valid:          vResult.Valid,
                Errors:         make([]ValidationError, len(vResult.Errors)),
                Warnings:       make([]ValidationWarning, len(vResult.Warnings)),
                Suggestions:    vResult.Suggestions,
                ValidationTime: vResult.ValidationTime,
                CacheHit:       vResult.CacheHit,
                ValidatedAt:    vResult.ValidatedAt,
        }

        // Convert errors
        for i, verr := range vResult.Errors </span><span class="cov8" title="1">{
                result.Errors[i] = ValidationError{
                        Type:     verr.Type,
                        Message:  verr.Message,
                        Path:     verr.Path,
                        Line:     verr.Line,
                        Column:   verr.Column,
                        Severity: string(verr.Severity),
                        Code:     verr.Code,
                }
                
                if verr.Location != nil </span><span class="cov8" title="1">{
                        result.Errors[i].Location = &amp;ErrorLocation{
                                File:   verr.Location.File,
                                Line:   verr.Location.Line,
                                Column: verr.Location.Column,
                        }
                }</span>
        }

        // Convert warnings
        <span class="cov8" title="1">for i, vwarn := range vResult.Warnings </span><span class="cov8" title="1">{
                result.Warnings[i] = ValidationWarning{
                        Type:       vwarn.Type,
                        Message:    vwarn.Message,
                        Path:       vwarn.Path,
                        Suggestion: vwarn.Suggestion,
                }
        }</span>

        // Convert spec info
        <span class="cov8" title="1">if vResult.SpecInfo != nil </span><span class="cov8" title="1">{
                result.SpecInfo = &amp;SpecInfo{
                        Version:         vResult.SpecInfo.Version,
                        Title:           vResult.SpecInfo.Title,
                        Description:     vResult.SpecInfo.Description,
                        OperationCount:  vResult.SpecInfo.OperationCount,
                        SchemaCount:     vResult.SpecInfo.SchemaCount,
                        SecuritySchemes: make([]SecurityScheme, len(vResult.SpecInfo.SecuritySchemes)),
                        Servers:         make([]ServerInfo, len(vResult.SpecInfo.Servers)),
                }
                
                // Convert security schemes
                for i, scheme := range vResult.SpecInfo.SecuritySchemes </span><span class="cov0" title="0">{
                        result.SpecInfo.SecuritySchemes[i] = SecurityScheme{
                                Type:        scheme.Type,
                                Name:        scheme.Name,
                                Description: scheme.Description,
                        }
                }</span>
                
                // Convert servers
                <span class="cov8" title="1">for i, server := range vResult.SpecInfo.Servers </span><span class="cov0" title="0">{
                        result.SpecInfo.Servers[i] = ServerInfo{
                                URL:         server.URL,
                                Description: server.Description,
                        }
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// cacheValidationResult caches a validation result
func (a *App) cacheValidationResult(specPath, specURL string, result *ValidationResult) <span class="cov8" title="1">{
        // Serialize the result
        resultJSON, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return // Skip caching if serialization fails
        }</span>

        // Create cache entry
        <span class="cov8" title="1">cache := &amp;database.ValidationCache{
                SpecPath:         specPath,
                SpecURL:          specURL,
                ValidationResult: string(resultJSON),
                CachedAt:         time.Now(),
                ExpiresAt:        time.Now().Add(24 * time.Hour), // Cache for 24 hours
        }

        // Generate hash based on source type
        if specPath != "" </span><span class="cov8" title="1">{
                if hash, err := a.validationCacheRepo.GenerateSpecHash(specPath); err == nil </span><span class="cov8" title="1">{
                        cache.SpecHash = hash
                }</span>
        } else<span class="cov8" title="1"> if specURL != "" </span><span class="cov8" title="1">{
                cache.SpecHash = a.validationCacheRepo.GenerateURLHash(specURL, time.Now())
        }</span>

        // Store in cache
        <span class="cov8" title="1">a.validationCacheRepo.Store(cache)</span>
}

// ExportValidationResult exports a validation result to JSON
func (a *App) ExportValidationResult(result *ValidationResult) (string, error) <span class="cov8" title="1">{
        if result == nil </span><span class="cov8" title="1">{
                return "", a.createAPIError("validation", ErrCodeValidation, "Validation result is required", nil)
        }</span>

        // Create export data
        <span class="cov8" title="1">exportData := map[string]interface{}{
                "version":         "1.0.0",
                "validationResult": result,
                "exportedAt":      time.Now().Format(time.RFC3339),
        }

        // Marshal to JSON
        jsonData, err := json.MarshalIndent(exportData, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", a.createAPIError("internal", ErrCodeInternalError, "Failed to export validation result", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov8" title="1">return string(jsonData), nil</span>
}

// GetValidationCacheStats returns cache statistics
func (a *App) GetValidationCacheStats() (*database.ValidationCacheStats, error) <span class="cov8" title="1">{
        if a.validationCacheRepo == nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Validation cache not initialized", nil)
        }</span>

        <span class="cov8" title="1">stats, err := a.validationCacheRepo.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.createAPIError("internal", ErrCodeInternalError, "Failed to get cache stats", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// ClearValidationCache clears expired validation cache entries
func (a *App) ClearValidationCache() error <span class="cov8" title="1">{
        if a.validationCacheRepo == nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Validation cache not initialized", nil)
        }</span>

        <span class="cov8" title="1">err := a.validationCacheRepo.CleanExpired()
        if err != nil </span><span class="cov0" title="0">{
                return a.createAPIError("internal", ErrCodeInternalError, "Failed to clear cache", map[string]string{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateOperations validates the operations in the specification
func (a *App) validateOperations(operations []parser.Operation, result *ValidationResult) <span class="cov0" title="0">{
        if len(operations) == 0 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Type:       "operations",
                        Message:    "No operations found in the specification",
                        Path:       "/paths",
                        Suggestion: "Add API endpoints to generate MCP tools",
                })
                return
        }</span>

        <span class="cov0" title="0">operationIds := make(map[string]bool)
        
        for _, op := range operations </span><span class="cov0" title="0">{
                // Check for duplicate operation IDs
                if op.ID != "" </span><span class="cov0" title="0">{
                        if operationIds[op.ID] </span><span class="cov0" title="0">{
                                result.Errors = append(result.Errors, ValidationError{
                                        Type:     "operations",
                                        Message:  fmt.Sprintf("Duplicate operation ID: %s", op.ID),
                                        Path:     fmt.Sprintf("/paths%s", op.Path),
                                        Severity: "error",
                                        Code:     ErrCodeValidation,
                                })
                                result.Valid = false
                        }</span>
                        <span class="cov0" title="0">operationIds[op.ID] = true</span>
                }

                // Check for missing descriptions
                <span class="cov0" title="0">if op.Description == "" &amp;&amp; op.Summary == "" </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Type:       "operations",
                                Message:    fmt.Sprintf("Operation %s %s has no description", op.Method, op.Path),
                                Path:       fmt.Sprintf("/paths%s/%s", op.Path, strings.ToLower(op.Method)),
                                Suggestion: "Add description or summary to improve generated tool documentation",
                        })
                }</span>

                // Check for parameters without descriptions
                <span class="cov0" title="0">for _, param := range op.Parameters </span><span class="cov0" title="0">{
                        if param.Description == "" </span><span class="cov0" title="0">{
                                result.Warnings = append(result.Warnings, ValidationWarning{
                                        Type:       "parameters",
                                        Message:    fmt.Sprintf("Parameter '%s' in %s %s has no description", param.Name, op.Method, op.Path),
                                        Path:       fmt.Sprintf("/paths%s/%s/parameters", op.Path, strings.ToLower(op.Method)),
                                        Suggestion: "Add parameter descriptions to improve usability",
                                })
                        }</span>
                }
        }
}

// validateSchemas validates the schemas in the specification
func (a *App) validateSchemas(schemas map[string]*openapi3.SchemaRef, result *ValidationResult) <span class="cov0" title="0">{
        if len(schemas) == 0 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Type:       "schemas",
                        Message:    "No schemas defined in the specification",
                        Path:       "/components/schemas",
                        Suggestion: "Define reusable schemas to improve specification maintainability",
                })
                return
        }</span>

        <span class="cov0" title="0">for name, schemaRef := range schemas </span><span class="cov0" title="0">{
                if schemaRef.Value == nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, ValidationError{
                                Type:     "schemas",
                                Message:  fmt.Sprintf("Schema '%s' has no definition", name),
                                Path:     fmt.Sprintf("/components/schemas/%s", name),
                                Severity: "error",
                                Code:     ErrCodeValidation,
                        })
                        result.Valid = false
                        continue</span>
                }

                <span class="cov0" title="0">schema := schemaRef.Value

                // Check for schemas without descriptions
                if schema.Description == "" </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Type:       "schemas",
                                Message:    fmt.Sprintf("Schema '%s' has no description", name),
                                Path:       fmt.Sprintf("/components/schemas/%s", name),
                                Suggestion: "Add schema descriptions to improve documentation",
                        })
                }</span>
        }
}

// addGeneralSuggestions adds general suggestions based on the specification
func (a *App) addGeneralSuggestions(parsedAPI *parser.ParsedAPI, result *ValidationResult) <span class="cov0" title="0">{
        // Check for missing base URL
        if parsedAPI.BaseURL == "" &amp;&amp; len(parsedAPI.Servers) == 0 </span><span class="cov0" title="0">{
                result.Suggestions = append(result.Suggestions, 
                        "Consider adding server information to specify the base URL")
        }</span>

        // Check for complex specifications
        <span class="cov0" title="0">if len(parsedAPI.Operations) &gt; 50 </span><span class="cov0" title="0">{
                result.Suggestions = append(result.Suggestions, 
                        "Large specifications may result in many MCP tools. Consider grouping related operations")
        }</span>

        // Check for security schemes
        <span class="cov0" title="0">hasSecuritySchemes := false
        if parsedAPI.Document.Components != nil &amp;&amp; len(parsedAPI.Document.Components.SecuritySchemes) &gt; 0 </span><span class="cov0" title="0">{
                hasSecuritySchemes = true
        }</span>

        <span class="cov0" title="0">if !hasSecuritySchemes </span><span class="cov0" title="0">{
                result.Suggestions = append(result.Suggestions, 
                        "Consider adding security schemes if your API requires authentication")
        }</span>

        // Final validation check
        <span class="cov0" title="0">if len(result.Errors) == 0 </span><span class="cov0" title="0">{
                result.Valid = true
        }</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package database

import (
        "database/sql"
        "fmt"

        _ "github.com/mattn/go-sqlite3"
)

// DB represents the database connection
type DB struct {
        conn *sql.DB
}

// Open opens a connection to the SQLite database
func Open(dbPath string) (*DB, error) <span class="cov8" title="1">{
        conn, err := sql.Open("sqlite3", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov8" title="1">if err := conn.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov8" title="1">db := &amp;DB{conn: conn}
        
        // Optimize database connection for performance
        if err := db.optimize(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to optimize database: %w", err)
        }</span>
        
        // Run migrations
        <span class="cov8" title="1">if err := db.migrate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to migrate database: %w", err)
        }</span>

        <span class="cov8" title="1">return db, nil</span>
}

// Close closes the database connection
func (db *DB) Close() error <span class="cov8" title="1">{
        if db.conn != nil </span><span class="cov8" title="1">{
                return db.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// migrate is implemented in migrations.go

// optimize configures SQLite for better performance
func (db *DB) optimize() error <span class="cov8" title="1">{
        optimizations := []string{
                "PRAGMA journal_mode=WAL",        // Write-Ahead Logging for better concurrency
                "PRAGMA synchronous=NORMAL",      // Faster writes with reasonable safety
                "PRAGMA cache_size=10000",        // 10MB cache (default is 2MB)
                "PRAGMA temp_store=MEMORY",       // Keep temp tables in memory
                "PRAGMA mmap_size=268435456",     // 256MB memory map size
                "PRAGMA optimize",               // Optimize query planner
        }
        
        for _, pragma := range optimizations </span><span class="cov8" title="1">{
                if _, err := db.conn.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute optimization '%s': %w", pragma, err)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// GetConn returns the underlying database connection
func (db *DB) GetConn() *sql.DB <span class="cov0" title="0">{
        return db.conn
}</pre>
		
		<pre class="file" id="file15" style="display: none">package database

import (
        "errors"
        "fmt"
)

// Common database errors
var (
        ErrNotFound      = errors.New("record not found")
        ErrAlreadyExists = errors.New("record already exists")
        ErrInvalidData   = errors.New("invalid data")
        ErrTransaction   = errors.New("transaction failed")
        ErrConnection    = errors.New("database connection failed")
        ErrMigration     = errors.New("migration failed")
)

// DatabaseError represents a database error with additional context
type DatabaseError struct {
        Op     string // Operation that failed
        Err    error  // Underlying error
        Table  string // Table involved
        ID     string // Record ID if applicable
        Detail string // Additional detail
}

// Error implements the error interface
func (e *DatabaseError) Error() string <span class="cov0" title="0">{
        if e.Detail != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("database error in %s on table %s: %v - %s", e.Op, e.Table, e.Err, e.Detail)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("database error in %s on table %s: %v", e.Op, e.Table, e.Err)</span>
}

// Unwrap returns the underlying error
func (e *DatabaseError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewDatabaseError creates a new database error
func NewDatabaseError(op, table string, err error) *DatabaseError <span class="cov0" title="0">{
        return &amp;DatabaseError{
                Op:    op,
                Table: table,
                Err:   err,
        }
}</span>

// WithID adds an ID to the database error
func (e *DatabaseError) WithID(id string) *DatabaseError <span class="cov0" title="0">{
        e.ID = id
        return e
}</span>

// WithDetail adds additional detail to the database error
func (e *DatabaseError) WithDetail(detail string) *DatabaseError <span class="cov0" title="0">{
        e.Detail = detail
        return e
}</span>

// IsNotFound checks if the error is a "not found" error
func IsNotFound(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, ErrNotFound)
}</span>

// IsAlreadyExists checks if the error is an "already exists" error
func IsAlreadyExists(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, ErrAlreadyExists)
}</span>

// IsInvalidData checks if the error is an "invalid data" error
func IsInvalidData(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, ErrInvalidData)
}</span>

// IsTransaction checks if the error is a transaction error
func IsTransaction(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, ErrTransaction)
}</span>

// IsConnection checks if the error is a connection error
func IsConnection(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, ErrConnection)
}</span>

// IsMigration checks if the error is a migration error
func IsMigration(err error) bool <span class="cov0" title="0">{
        return errors.Is(err, ErrMigration)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "time"
)

// GenerationRepository handles CRUD operations for generations
type GenerationRepository struct {
        db *DB
}

// NewGenerationRepository creates a new generation repository
func NewGenerationRepository(db *DB) *GenerationRepository <span class="cov8" title="1">{
        return &amp;GenerationRepository{db: db}
}</span>

// Create creates a new generation
func (r *GenerationRepository) Create(generation *Generation) error <span class="cov8" title="1">{
        query := `
                INSERT INTO generations (id, project_id, status, progress, current_step, start_time, results, errors, processing_time_ms)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `
        
        if generation.StartTime.IsZero() </span><span class="cov0" title="0">{
                generation.StartTime = time.Now()
        }</span>
        
        <span class="cov8" title="1">_, err := r.db.conn.Exec(query, 
                generation.ID, generation.ProjectID, generation.Status, generation.Progress,
                generation.CurrentStep, generation.StartTime, generation.Results, 
                generation.Errors, generation.ProcessingTimeMs)
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create generation: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// GetByID retrieves a generation by ID
func (r *GenerationRepository) GetByID(id string) (*Generation, error) <span class="cov8" title="1">{
        query := `
                SELECT id, project_id, status, progress, current_step, start_time, 
                           end_time, results, errors, processing_time_ms
                FROM generations 
                WHERE id = ?
        `
        
        generation := &amp;Generation{}
        err := r.db.conn.QueryRow(query, id).Scan(
                &amp;generation.ID, &amp;generation.ProjectID, &amp;generation.Status, &amp;generation.Progress,
                &amp;generation.CurrentStep, &amp;generation.StartTime, &amp;generation.EndTime,
                &amp;generation.Results, &amp;generation.Errors, &amp;generation.ProcessingTimeMs)
        
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("generation not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get generation: %w", err)</span>
        }
        
        <span class="cov8" title="1">return generation, nil</span>
}

// GetByProjectID retrieves all generations for a project
func (r *GenerationRepository) GetByProjectID(projectID string) ([]*Generation, error) <span class="cov8" title="1">{
        query := `
                SELECT id, project_id, status, progress, current_step, start_time, 
                           end_time, results, errors, processing_time_ms
                FROM generations 
                WHERE project_id = ?
                ORDER BY start_time DESC
        `
        
        rows, err := r.db.conn.Query(query, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query generations: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var generations []*Generation
        for rows.Next() </span><span class="cov8" title="1">{
                generation := &amp;Generation{}
                err := rows.Scan(
                        &amp;generation.ID, &amp;generation.ProjectID, &amp;generation.Status, &amp;generation.Progress,
                        &amp;generation.CurrentStep, &amp;generation.StartTime, &amp;generation.EndTime,
                        &amp;generation.Results, &amp;generation.Errors, &amp;generation.ProcessingTimeMs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan generation: %w", err)
                }</span>
                <span class="cov8" title="1">generations = append(generations, generation)</span>
        }
        
        <span class="cov8" title="1">return generations, nil</span>
}

// Update updates a generation
func (r *GenerationRepository) Update(generation *Generation) error <span class="cov0" title="0">{
        query := `
                UPDATE generations 
                SET status = ?, progress = ?, current_step = ?, end_time = ?, 
                        results = ?, errors = ?, processing_time_ms = ?
                WHERE id = ?
        `
        
        result, err := r.db.conn.Exec(query, 
                generation.Status, generation.Progress, generation.CurrentStep, 
                generation.EndTime, generation.Results, generation.Errors, 
                generation.ProcessingTimeMs, generation.ID)
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update generation: %w", err)
        }</span>
        
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>
        
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("generation not found")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a generation
func (r *GenerationRepository) Delete(id string) error <span class="cov0" title="0">{
        query := `DELETE FROM generations WHERE id = ?`
        
        result, err := r.db.conn.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete generation: %w", err)
        }</span>
        
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>
        
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("generation not found")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// GetRecent retrieves recent generations across all projects
func (r *GenerationRepository) GetRecent(limit int) ([]*Generation, error) <span class="cov0" title="0">{
        query := `
                SELECT id, project_id, status, progress, current_step, start_time, 
                           end_time, results, errors, processing_time_ms
                FROM generations 
                ORDER BY start_time DESC
                LIMIT ?
        `
        
        rows, err := r.db.conn.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query recent generations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        var generations []*Generation
        for rows.Next() </span><span class="cov0" title="0">{
                generation := &amp;Generation{}
                err := rows.Scan(
                        &amp;generation.ID, &amp;generation.ProjectID, &amp;generation.Status, &amp;generation.Progress,
                        &amp;generation.CurrentStep, &amp;generation.StartTime, &amp;generation.EndTime,
                        &amp;generation.Results, &amp;generation.Errors, &amp;generation.ProcessingTimeMs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan generation: %w", err)
                }</span>
                <span class="cov0" title="0">generations = append(generations, generation)</span>
        }
        
        <span class="cov0" title="0">return generations, nil</span>
}

// GetByStatus retrieves generations by status
func (r *GenerationRepository) GetByStatus(status string) ([]*Generation, error) <span class="cov0" title="0">{
        query := `
                SELECT id, project_id, status, progress, current_step, start_time, 
                           end_time, results, errors, processing_time_ms
                FROM generations 
                WHERE status = ?
                ORDER BY start_time DESC
        `
        
        rows, err := r.db.conn.Query(query, status)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query generations by status: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        var generations []*Generation
        for rows.Next() </span><span class="cov0" title="0">{
                generation := &amp;Generation{}
                err := rows.Scan(
                        &amp;generation.ID, &amp;generation.ProjectID, &amp;generation.Status, &amp;generation.Progress,
                        &amp;generation.CurrentStep, &amp;generation.StartTime, &amp;generation.EndTime,
                        &amp;generation.Results, &amp;generation.Errors, &amp;generation.ProcessingTimeMs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan generation: %w", err)
                }</span>
                <span class="cov0" title="0">generations = append(generations, generation)</span>
        }
        
        <span class="cov0" title="0">return generations, nil</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"
)

// Migration represents a database migration
type Migration struct {
        Version int
        Name    string
        Up      string
        Down    string
}

// migrations contains all database migrations in order
var migrations = []Migration{
        {
                Version: 1,
                Name:    "initial_schema",
                Up: `
                        -- Projects table
                        CREATE TABLE projects (
                                id TEXT PRIMARY KEY,
                                name TEXT NOT NULL,
                                spec_path TEXT,
                                spec_url TEXT,
                                output_path TEXT NOT NULL,
                                settings TEXT NOT NULL, -- JSON serialized ProjectSettings
                                status TEXT NOT NULL DEFAULT 'created',
                                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                                last_generated DATETIME,
                                generation_count INTEGER DEFAULT 0
                        );

                        -- Indexes for projects table
                        CREATE INDEX idx_projects_name ON projects(name);
                        CREATE INDEX idx_projects_status ON projects(status);
                        CREATE INDEX idx_projects_created_at ON projects(created_at);
                        CREATE INDEX idx_projects_last_generated ON projects(last_generated);

                        -- Generations table
                        CREATE TABLE generations (
                                id TEXT PRIMARY KEY,
                                project_id TEXT NOT NULL,
                                status TEXT NOT NULL,
                                progress REAL DEFAULT 0.0,
                                current_step TEXT,
                                start_time DATETIME DEFAULT CURRENT_TIMESTAMP,
                                end_time DATETIME,
                                results TEXT, -- JSON serialized GenerationResults
                                errors TEXT, -- JSON serialized GenerationError array
                                processing_time_ms INTEGER,
                                FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
                        );

                        -- Indexes for generations table
                        CREATE INDEX idx_generations_project_id ON generations(project_id);
                        CREATE INDEX idx_generations_status ON generations(status);
                        CREATE INDEX idx_generations_start_time ON generations(start_time);

                        -- Templates table
                        CREATE TABLE templates (
                                id TEXT PRIMARY KEY,
                                name TEXT NOT NULL,
                                description TEXT,
                                version TEXT NOT NULL,
                                author TEXT,
                                type TEXT NOT NULL, -- 'default', 'custom', 'plugin'
                                path TEXT NOT NULL,
                                is_built_in BOOLEAN DEFAULT FALSE,
                                variables TEXT, -- JSON serialized TemplateVariable array
                                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                        );

                        -- Indexes for templates table
                        CREATE INDEX idx_templates_name ON templates(name);
                        CREATE INDEX idx_templates_type ON templates(type);
                        CREATE INDEX idx_templates_is_built_in ON templates(is_built_in);

                        -- Application settings table
                        CREATE TABLE app_settings (
                                key TEXT PRIMARY KEY,
                                value TEXT NOT NULL,
                                type TEXT NOT NULL, -- 'string', 'number', 'boolean', 'json'
                                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                        );

                        -- Validation cache table
                        CREATE TABLE validation_cache (
                                spec_hash TEXT PRIMARY KEY,
                                spec_path TEXT,
                                spec_url TEXT,
                                validation_result TEXT NOT NULL, -- JSON serialized ValidationResult
                                cached_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                                expires_at DATETIME NOT NULL
                        );

                        -- Index for validation cache cleanup
                        CREATE INDEX idx_validation_cache_expires_at ON validation_cache(expires_at);

                        -- Insert initial schema version
                        INSERT INTO schema_version (version) VALUES (1);
                `,
                Down: `
                        DROP TABLE IF EXISTS validation_cache;
                        DROP TABLE IF EXISTS app_settings;
                        DROP TABLE IF EXISTS templates;
                        DROP TABLE IF EXISTS generations;
                        DROP TABLE IF EXISTS projects;
                        DROP TABLE IF EXISTS schema_version;
                `,
        },
}

// getCurrentVersion returns the current database schema version
func (db *DB) getCurrentVersion() (int, error) <span class="cov8" title="1">{
        var version int
        err := db.conn.QueryRow("SELECT COALESCE(MAX(version), 0) FROM schema_version").Scan(&amp;version)
        if err != nil </span><span class="cov0" title="0">{
                // If table doesn't exist, we're at version 0
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov8" title="1">return version, nil</span>
}

// migrate runs all pending migrations
func (db *DB) migrate() error <span class="cov8" title="1">{
        // Create schema_version table if it doesn't exist
        _, err := db.conn.Exec(`
                CREATE TABLE IF NOT EXISTS schema_version (
                        version INTEGER PRIMARY KEY,
                        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create schema_version table: %w", err)
        }</span>

        <span class="cov8" title="1">currentVersion, err := db.getCurrentVersion()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current version: %w", err)
        }</span>

        <span class="cov8" title="1">log.Printf("Current database schema version: %d", currentVersion)

        // Apply pending migrations
        for _, migration := range migrations </span><span class="cov8" title="1">{
                if migration.Version &gt; currentVersion </span><span class="cov8" title="1">{
                        log.Printf("Applying migration %d: %s", migration.Version, migration.Name)
                        
                        // Begin transaction
                        tx, err := db.conn.Begin()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to begin transaction for migration %d: %w", migration.Version, err)
                        }</span>

                        // Execute migration
                        <span class="cov8" title="1">_, err = tx.Exec(migration.Up)
                        if err != nil </span><span class="cov0" title="0">{
                                tx.Rollback()
                                return fmt.Errorf("failed to execute migration %d: %w", migration.Version, err)
                        }</span>

                        // Update schema version (only if not already done in the migration)
                        <span class="cov8" title="1">if migration.Version &gt; 1 </span><span class="cov0" title="0">{
                                _, err = tx.Exec("INSERT INTO schema_version (version) VALUES (?)", migration.Version)
                                if err != nil </span><span class="cov0" title="0">{
                                        tx.Rollback()
                                        return fmt.Errorf("failed to update schema version for migration %d: %w", migration.Version, err)
                                }</span>
                        }

                        // Commit transaction
                        <span class="cov8" title="1">err = tx.Commit()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to commit migration %d: %w", migration.Version, err)
                        }</span>

                        <span class="cov8" title="1">log.Printf("Successfully applied migration %d", migration.Version)</span>
                }
        }

        <span class="cov8" title="1">log.Printf("Database migrations completed")
        return nil</span>
}

// rollback rolls back the database to a specific version
func (db *DB) rollback(targetVersion int) error <span class="cov0" title="0">{
        currentVersion, err := db.getCurrentVersion()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current version: %w", err)
        }</span>

        <span class="cov0" title="0">if targetVersion &gt;= currentVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("target version %d is not less than current version %d", targetVersion, currentVersion)
        }</span>

        // Apply rollback migrations in reverse order
        <span class="cov0" title="0">for i := len(migrations) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                migration := migrations[i]
                if migration.Version &gt; targetVersion &amp;&amp; migration.Version &lt;= currentVersion </span><span class="cov0" title="0">{
                        log.Printf("Rolling back migration %d: %s", migration.Version, migration.Name)
                        
                        // Begin transaction
                        tx, err := db.conn.Begin()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to begin transaction for rollback %d: %w", migration.Version, err)
                        }</span>

                        // Execute rollback
                        <span class="cov0" title="0">_, err = tx.Exec(migration.Down)
                        if err != nil </span><span class="cov0" title="0">{
                                tx.Rollback()
                                return fmt.Errorf("failed to execute rollback %d: %w", migration.Version, err)
                        }</span>

                        // Remove schema version entry
                        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM schema_version WHERE version = ?", migration.Version)
                        if err != nil </span><span class="cov0" title="0">{
                                tx.Rollback()
                                return fmt.Errorf("failed to remove schema version for rollback %d: %w", migration.Version, err)
                        }</span>

                        // Commit transaction
                        <span class="cov0" title="0">err = tx.Commit()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to commit rollback %d: %w", migration.Version, err)
                        }</span>

                        <span class="cov0" title="0">log.Printf("Successfully rolled back migration %d", migration.Version)</span>
                }
        }

        <span class="cov0" title="0">log.Printf("Database rollback completed")
        return nil</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "time"
)

// ProjectRepository handles CRUD operations for projects
type ProjectRepository struct {
        db *DB
}

// NewProjectRepository creates a new project repository
func NewProjectRepository(db *DB) *ProjectRepository <span class="cov8" title="1">{
        return &amp;ProjectRepository{db: db}
}</span>

// Create creates a new project
func (r *ProjectRepository) Create(project *Project) error <span class="cov8" title="1">{
        query := `
                INSERT INTO projects (id, name, spec_path, spec_url, output_path, settings, status, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `
        
        now := time.Now()
        project.CreatedAt = now
        project.UpdatedAt = now
        
        _, err := r.db.conn.Exec(query, 
                project.ID, project.Name, project.SpecPath, project.SpecURL, 
                project.OutputPath, project.Settings, project.Status, 
                project.CreatedAt, project.UpdatedAt)
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create project: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// GetByID retrieves a project by ID
func (r *ProjectRepository) GetByID(id string) (*Project, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, spec_path, spec_url, output_path, settings, status, 
                           created_at, updated_at, last_generated, generation_count
                FROM projects 
                WHERE id = ?
        `
        
        project := &amp;Project{}
        err := r.db.conn.QueryRow(query, id).Scan(
                &amp;project.ID, &amp;project.Name, &amp;project.SpecPath, &amp;project.SpecURL,
                &amp;project.OutputPath, &amp;project.Settings, &amp;project.Status,
                &amp;project.CreatedAt, &amp;project.UpdatedAt, &amp;project.LastGenerated,
                &amp;project.GenerationCount)
        
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("project not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get project: %w", err)</span>
        }
        
        <span class="cov8" title="1">return project, nil</span>
}

// GetAll retrieves all projects
func (r *ProjectRepository) GetAll() ([]*Project, error) <span class="cov8" title="1">{
        query := `
                SELECT id, name, spec_path, spec_url, output_path, settings, status, 
                           created_at, updated_at, last_generated, generation_count
                FROM projects 
                ORDER BY updated_at DESC
        `
        
        rows, err := r.db.conn.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query projects: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var projects []*Project
        for rows.Next() </span><span class="cov8" title="1">{
                project := &amp;Project{}
                err := rows.Scan(
                        &amp;project.ID, &amp;project.Name, &amp;project.SpecPath, &amp;project.SpecURL,
                        &amp;project.OutputPath, &amp;project.Settings, &amp;project.Status,
                        &amp;project.CreatedAt, &amp;project.UpdatedAt, &amp;project.LastGenerated,
                        &amp;project.GenerationCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan project: %w", err)
                }</span>
                <span class="cov8" title="1">projects = append(projects, project)</span>
        }
        
        <span class="cov8" title="1">return projects, nil</span>
}

// Update updates a project
func (r *ProjectRepository) Update(project *Project) error <span class="cov8" title="1">{
        query := `
                UPDATE projects 
                SET name = ?, spec_path = ?, spec_url = ?, output_path = ?, 
                        settings = ?, status = ?, updated_at = ?, last_generated = ?, 
                        generation_count = ?
                WHERE id = ?
        `
        
        project.UpdatedAt = time.Now()
        
        result, err := r.db.conn.Exec(query, 
                project.Name, project.SpecPath, project.SpecURL, project.OutputPath,
                project.Settings, project.Status, project.UpdatedAt, project.LastGenerated,
                project.GenerationCount, project.ID)
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update project: %w", err)
        }</span>
        
        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>
        
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("project not found")
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// Delete deletes a project
func (r *ProjectRepository) Delete(id string) error <span class="cov8" title="1">{
        query := `DELETE FROM projects WHERE id = ?`
        
        result, err := r.db.conn.Exec(query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete project: %w", err)
        }</span>
        
        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>
        
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("project not found")
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// GetByName retrieves a single project by exact name match
func (r *ProjectRepository) GetByName(name string) (*Project, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, spec_path, spec_url, output_path, settings, status, 
                           created_at, updated_at, last_generated, generation_count
                FROM projects 
                WHERE name = ?
        `
        
        project := &amp;Project{}
        err := r.db.conn.QueryRow(query, name).Scan(
                &amp;project.ID, &amp;project.Name, &amp;project.SpecPath, &amp;project.SpecURL,
                &amp;project.OutputPath, &amp;project.Settings, &amp;project.Status,
                &amp;project.CreatedAt, &amp;project.UpdatedAt, &amp;project.LastGenerated,
                &amp;project.GenerationCount)
        
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("project not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get project by name: %w", err)</span>
        }
        
        <span class="cov0" title="0">return project, nil</span>
}

// SearchByName retrieves projects by name (useful for search)
func (r *ProjectRepository) SearchByName(name string) ([]*Project, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, spec_path, spec_url, output_path, settings, status, 
                           created_at, updated_at, last_generated, generation_count
                FROM projects 
                WHERE name LIKE ? 
                ORDER BY updated_at DESC
        `
        
        rows, err := r.db.conn.Query(query, "%"+name+"%")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query projects by name: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        var projects []*Project
        for rows.Next() </span><span class="cov0" title="0">{
                project := &amp;Project{}
                err := rows.Scan(
                        &amp;project.ID, &amp;project.Name, &amp;project.SpecPath, &amp;project.SpecURL,
                        &amp;project.OutputPath, &amp;project.Settings, &amp;project.Status,
                        &amp;project.CreatedAt, &amp;project.UpdatedAt, &amp;project.LastGenerated,
                        &amp;project.GenerationCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan project: %w", err)
                }</span>
                <span class="cov0" title="0">projects = append(projects, project)</span>
        }
        
        <span class="cov0" title="0">return projects, nil</span>
}

// GetRecent retrieves recently updated projects
func (r *ProjectRepository) GetRecent(limit int) ([]*Project, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, spec_path, spec_url, output_path, settings, status, 
                           created_at, updated_at, last_generated, generation_count
                FROM projects 
                ORDER BY updated_at DESC
                LIMIT ?
        `
        
        rows, err := r.db.conn.Query(query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query recent projects: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        var projects []*Project
        for rows.Next() </span><span class="cov0" title="0">{
                project := &amp;Project{}
                err := rows.Scan(
                        &amp;project.ID, &amp;project.Name, &amp;project.SpecPath, &amp;project.SpecURL,
                        &amp;project.OutputPath, &amp;project.Settings, &amp;project.Status,
                        &amp;project.CreatedAt, &amp;project.UpdatedAt, &amp;project.LastGenerated,
                        &amp;project.GenerationCount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan project: %w", err)
                }</span>
                <span class="cov0" title="0">projects = append(projects, project)</span>
        }
        
        <span class="cov0" title="0">return projects, nil</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package database

import (
        "database/sql"
)

// Repository provides access to all database repositories
type Repository struct {
        Projects    *ProjectRepository
        Generations *GenerationRepository
        Settings    *SettingsRepository
        db          *DB
}

// NewRepository creates a new repository manager
func NewRepository(db *DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                Projects:    NewProjectRepository(db),
                Generations: NewGenerationRepository(db),
                Settings:    NewSettingsRepository(db),
                db:          db,
        }
}</span>

// Close closes the database connection
func (r *Repository) Close() error <span class="cov0" title="0">{
        return r.db.Close()
}</span>

// GetDB returns the underlying database connection
func (r *Repository) GetDB() *DB <span class="cov0" title="0">{
        return r.db
}</span>

// Transaction executes a function within a database transaction
func (r *Repository) Transaction(fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        tx, err := r.db.conn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Execute the function
        <span class="cov0" title="0">err = fn(tx)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        
        <span class="cov0" title="0">return tx.Commit()</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "time"
)

// SettingsRepository handles CRUD operations for application settings
type SettingsRepository struct {
        db *DB
}

// NewSettingsRepository creates a new settings repository
func NewSettingsRepository(db *DB) *SettingsRepository <span class="cov8" title="1">{
        return &amp;SettingsRepository{db: db}
}</span>

// Set sets a setting value
func (r *SettingsRepository) Set(key, value, settingType string) error <span class="cov8" title="1">{
        query := `
                INSERT INTO app_settings (key, value, type, updated_at)
                VALUES (?, ?, ?, ?)
                ON CONFLICT(key) DO UPDATE SET
                        value = excluded.value,
                        type = excluded.type,
                        updated_at = excluded.updated_at
        `
        
        _, err := r.db.conn.Exec(query, key, value, settingType, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set setting: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// Get retrieves a setting value
func (r *SettingsRepository) Get(key string) (*AppSetting, error) <span class="cov8" title="1">{
        query := `
                SELECT key, value, type, updated_at
                FROM app_settings 
                WHERE key = ?
        `
        
        setting := &amp;AppSetting{}
        err := r.db.conn.QueryRow(query, key).Scan(
                &amp;setting.Key, &amp;setting.Value, &amp;setting.Type, &amp;setting.UpdatedAt)
        
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("setting not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get setting: %w", err)</span>
        }
        
        <span class="cov8" title="1">return setting, nil</span>
}

// GetAll retrieves all settings
func (r *SettingsRepository) GetAll() ([]*AppSetting, error) <span class="cov8" title="1">{
        query := `
                SELECT key, value, type, updated_at
                FROM app_settings 
                ORDER BY key
        `
        
        rows, err := r.db.conn.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query settings: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        
        var settings []*AppSetting
        for rows.Next() </span><span class="cov8" title="1">{
                setting := &amp;AppSetting{}
                err := rows.Scan(&amp;setting.Key, &amp;setting.Value, &amp;setting.Type, &amp;setting.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan setting: %w", err)
                }</span>
                <span class="cov8" title="1">settings = append(settings, setting)</span>
        }
        
        <span class="cov8" title="1">return settings, nil</span>
}

// Delete deletes a setting
func (r *SettingsRepository) Delete(key string) error <span class="cov0" title="0">{
        query := `DELETE FROM app_settings WHERE key = ?`
        
        result, err := r.db.conn.Exec(query, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete setting: %w", err)
        }</span>
        
        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>
        
        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("setting not found")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// GetByType retrieves settings by type
func (r *SettingsRepository) GetByType(settingType string) ([]*AppSetting, error) <span class="cov0" title="0">{
        query := `
                SELECT key, value, type, updated_at
                FROM app_settings 
                WHERE type = ?
                ORDER BY key
        `
        
        rows, err := r.db.conn.Query(query, settingType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query settings by type: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        var settings []*AppSetting
        for rows.Next() </span><span class="cov0" title="0">{
                setting := &amp;AppSetting{}
                err := rows.Scan(&amp;setting.Key, &amp;setting.Value, &amp;setting.Type, &amp;setting.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan setting: %w", err)
                }</span>
                <span class="cov0" title="0">settings = append(settings, setting)</span>
        }
        
        <span class="cov0" title="0">return settings, nil</span>
}

// SetMultiple sets multiple settings in a transaction
func (r *SettingsRepository) SetMultiple(settings map[string]AppSetting) error <span class="cov0" title="0">{
        tx, err := r.db.conn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()
        
        query := `
                INSERT INTO app_settings (key, value, type, updated_at)
                VALUES (?, ?, ?, ?)
                ON CONFLICT(key) DO UPDATE SET
                        value = excluded.value,
                        type = excluded.type,
                        updated_at = excluded.updated_at
        `
        
        stmt, err := tx.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()
        
        now := time.Now()
        for key, setting := range settings </span><span class="cov0" title="0">{
                _, err := stmt.Exec(key, setting.Value, setting.Type, now)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute statement for key %s: %w", key, err)
                }</span>
        }
        
        <span class="cov0" title="0">return tx.Commit()</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package database

import (
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "fmt"
        "io"
        "os"
        "time"
)

// ValidationCacheRepository handles CRUD operations for validation cache
type ValidationCacheRepository struct {
        db *DB
}

// NewValidationCacheRepository creates a new validation cache repository
func NewValidationCacheRepository(db *DB) *ValidationCacheRepository <span class="cov8" title="1">{
        return &amp;ValidationCacheRepository{db: db}
}</span>

// GetByHash retrieves a validation result by spec hash
func (r *ValidationCacheRepository) GetByHash(specHash string) (*ValidationCache, error) <span class="cov8" title="1">{
        query := `
                SELECT spec_hash, spec_path, spec_url, validation_result, cached_at, expires_at
                FROM validation_cache 
                WHERE spec_hash = ? AND expires_at &gt; ?
        `
        
        cache := &amp;ValidationCache{}
        err := r.db.conn.QueryRow(query, specHash, time.Now()).Scan(
                &amp;cache.SpecHash, &amp;cache.SpecPath, &amp;cache.SpecURL, 
                &amp;cache.ValidationResult, &amp;cache.CachedAt, &amp;cache.ExpiresAt)
        
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil // Cache miss
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get validation cache: %w", err)</span>
        }
        
        <span class="cov8" title="1">return cache, nil</span>
}

// Store stores a validation result in the cache
func (r *ValidationCacheRepository) Store(cache *ValidationCache) error <span class="cov8" title="1">{
        query := `
                INSERT OR REPLACE INTO validation_cache 
                (spec_hash, spec_path, spec_url, validation_result, cached_at, expires_at)
                VALUES (?, ?, ?, ?, ?, ?)
        `
        
        _, err := r.db.conn.Exec(query, 
                cache.SpecHash, cache.SpecPath, cache.SpecURL, 
                cache.ValidationResult, cache.CachedAt, cache.ExpiresAt)
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store validation cache: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// CleanExpired removes expired validation cache entries
func (r *ValidationCacheRepository) CleanExpired() error <span class="cov8" title="1">{
        query := `DELETE FROM validation_cache WHERE expires_at &lt;= ?`
        
        result, err := r.db.conn.Exec(query, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clean expired validation cache: %w", err)
        }</span>
        
        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>
        
        <span class="cov8" title="1">fmt.Printf("Cleaned %d expired validation cache entries\n", rowsAffected)
        return nil</span>
}

// GetStats returns cache statistics
func (r *ValidationCacheRepository) GetStats() (*ValidationCacheStats, error) <span class="cov8" title="1">{
        query := `
                SELECT 
                        COUNT(*) as total_entries,
                        COUNT(CASE WHEN expires_at &gt; ? THEN 1 END) as active_entries,
                        COUNT(CASE WHEN expires_at &lt;= ? THEN 1 END) as expired_entries
                FROM validation_cache
        `
        
        stats := &amp;ValidationCacheStats{}
        now := time.Now()
        
        err := r.db.conn.QueryRow(query, now, now).Scan(
                &amp;stats.TotalEntries, &amp;stats.ActiveEntries, &amp;stats.ExpiredEntries)
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get cache stats: %w", err)
        }</span>
        
        <span class="cov8" title="1">return stats, nil</span>
}

// GenerateSpecHash generates a hash for a specification file
func (r *ValidationCacheRepository) GenerateSpecHash(specPath string) (string, error) <span class="cov8" title="1">{
        file, err := os.Open(specPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to open spec file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()
        
        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to hash spec file: %w", err)
        }</span>
        
        <span class="cov8" title="1">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

// GenerateURLHash generates a hash for a specification URL
func (r *ValidationCacheRepository) GenerateURLHash(specURL string, lastModified time.Time) string <span class="cov8" title="1">{
        hash := sha256.New()
        hash.Write([]byte(specURL))
        hash.Write([]byte(lastModified.Format(time.RFC3339)))
        return hex.EncodeToString(hash.Sum(nil))
}</span>

// ValidationCacheStats represents cache statistics
type ValidationCacheStats struct {
        TotalEntries   int `json:"totalEntries"`
        ActiveEntries  int `json:"activeEntries"`
        ExpiredEntries int `json:"expiredEntries"`
}</pre>
		
		<pre class="file" id="file22" style="display: none">package generator

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"
        "unicode"

        "MCPWeaver/internal/mapping"
        "MCPWeaver/internal/parser"
)

// TemplateData holds all data needed for template generation
type TemplateData struct {
        PackageName string
        APITitle    string
        APIVersion  string
        BaseURL     string
        Tools       []mapping.MCPTool
}

// Service handles MCP server code generation
type Service struct {
        outputDir string
}

// ValidationResult represents the result of code validation
type ValidationResult struct {
        IsValid bool     `json:"isValid"`
        Errors  []string `json:"errors,omitempty"`
        Warnings []string `json:"warnings,omitempty"`
        FilesValidated int `json:"filesValidated"`
}

// NewService creates a new code generator service
func NewService(outputDir string) *Service <span class="cov0" title="0">{
        return &amp;Service{
                outputDir: outputDir,
        }
}</span>

// Generate creates a complete MCP server from parsed API and tools
func (s *Service) Generate(api *parser.ParsedAPI, tools []mapping.MCPTool, serverName string) error <span class="cov0" title="0">{
        // Create output directory structure
        if err := s.createOutputStructure(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output structure: %w", err)
        }</span>

        // Prepare template data
        <span class="cov0" title="0">data := TemplateData{
                PackageName: s.sanitizePackageName(serverName),
                APITitle:    api.Title,
                APIVersion:  api.Version,
                BaseURL:     api.BaseURL,
                Tools:       tools,
        }

        // Generate main server file
        if err := s.generateFromTemplate("server.go.tmpl", "main.go", data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate server file: %w", err)
        }</span>

        // Generate go.mod file
        <span class="cov0" title="0">if err := s.generateFromTemplate("go.mod.tmpl", "go.mod", data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate go.mod file: %w", err)
        }</span>

        // Generate README
        <span class="cov0" title="0">if err := s.generateREADME(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate README: %w", err)
        }</span>

        // Generate additional files
        <span class="cov0" title="0">if err := s.generateDockerfile(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate Dockerfile: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.generateMakefile(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate Makefile: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.generateGitignore(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate .gitignore: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateFromTemplate processes a template and writes the output to a file
func (s *Service) generateFromTemplate(templateName, outputFile string, data TemplateData) error <span class="cov0" title="0">{
        // Validate template name to prevent path traversal
        if !isValidTemplateName(templateName) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid template name: %s", templateName)
        }</span>

        // Read template from file system
        <span class="cov0" title="0">templatePath := filepath.Join("templates", templateName)
        // Validate template path is within templates directory
        if !isPathSafe(templatePath, "templates") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid template path: path traversal detected")
        }</span>

        // #nosec G304 - templatePath is validated above to prevent path traversal
        <span class="cov0" title="0">templateContent, err := os.ReadFile(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read template %s: %w", templatePath, err)
        }</span>

        // Parse template with custom functions
        <span class="cov0" title="0">tmpl, err := template.New(templateName).Funcs(template.FuncMap{
                "title": func(s string) string </span><span class="cov0" title="0">{
                        if s == "" </span><span class="cov0" title="0">{
                                return s
                        }</span>
                        <span class="cov0" title="0">runes := []rune(s)
                        for i, r := range runes </span><span class="cov0" title="0">{
                                if i == 0 || !unicode.IsLetter(runes[i-1]) </span><span class="cov0" title="0">{
                                        runes[i] = unicode.ToUpper(r)
                                }</span>
                        }
                        <span class="cov0" title="0">return string(runes)</span>
                },
        }).Parse(string(templateContent))
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse template %s: %w", templateName, err)
        }</span>

        // Create output file
        <span class="cov0" title="0">outputPath := filepath.Join(s.outputDir, outputFile)
        // Validate output path is within output directory
        if !isPathSafe(outputPath, s.outputDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid output path: path traversal detected")
        }</span>

        // #nosec G304 - outputPath is validated above to prevent path traversal
        <span class="cov0" title="0">file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = file.Close() }</span>()

        // Execute template
        <span class="cov0" title="0">if err := tmpl.Execute(file, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template %s: %w", templateName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateREADME creates a README file for the generated server
func (s *Service) generateREADME(data TemplateData) error <span class="cov0" title="0">{
        readmeContent := fmt.Sprintf(`# %s MCP Server

Generated MCP server for %s (version %s).

## Description

This MCP server provides tools to interact with the %s API through the Model Context Protocol.

## Available Tools

`, data.PackageName, data.APITitle, data.APIVersion, data.APITitle)

        for i, tool := range data.Tools </span><span class="cov0" title="0">{
                readmeContent += fmt.Sprintf("%d. **%s** - %s\n", i+1, tool.Name, tool.Description)
                if len(tool.InputSchema.Required) &gt; 0 </span><span class="cov0" title="0">{
                        readmeContent += fmt.Sprintf("   - Required parameters: %s\n", strings.Join(tool.InputSchema.Required, ", "))
                }</span>
                <span class="cov0" title="0">readmeContent += "\n"</span>
        }

        <span class="cov0" title="0">readmeContent += fmt.Sprintf(`## Usage

1. Build the server:
   `+"```bash"+`
   go build -o %s-server main.go
   `+"```"+`

2. Use with an MCP client (like Claude Desktop):
   `+"```bash"+`
   ./%s-server
   `+"```"+`

## API Base URL

This server connects to: %s

## Generated by

MCPWeaver - Desktop OpenAPI to MCP Server Generator
`, data.PackageName, data.PackageName, data.BaseURL)

        readmePath := filepath.Join(s.outputDir, "README.md")
        // Validate readme path is within output directory
        if !isPathSafe(readmePath, s.outputDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid readme path: path traversal detected")
        }</span>

        <span class="cov0" title="0">return os.WriteFile(readmePath, []byte(readmeContent), 0600)</span>
}

// sanitizePackageName creates a valid Go package name from a string
func (s *Service) sanitizePackageName(name string) string <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return "generated-mcp-server"
        }</span>

        // Convert to lowercase and replace invalid characters
        <span class="cov0" title="0">name = strings.ToLower(name)
        name = strings.ReplaceAll(name, " ", "-")
        name = strings.ReplaceAll(name, "_", "-")

        // Remove any characters that aren't alphanumeric or hyphens
        var result strings.Builder
        for _, r := range name </span><span class="cov0" title="0">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '-' </span><span class="cov0" title="0">{
                        result.WriteRune(r)
                }</span>
        }

        <span class="cov0" title="0">sanitized := result.String()

        // Ensure it doesn't start with a number or hyphen
        if len(sanitized) &gt; 0 &amp;&amp; (sanitized[0] &gt;= '0' &amp;&amp; sanitized[0] &lt;= '9' || sanitized[0] == '-') </span><span class="cov0" title="0">{
                sanitized = "mcp-" + strings.TrimLeft(sanitized, "-")
        }</span>

        <span class="cov0" title="0">if sanitized == "" </span><span class="cov0" title="0">{
                return "generated-mcp-server"
        }</span>

        <span class="cov0" title="0">return sanitized</span>
}

// isValidTemplateName validates that the template name is safe
func isValidTemplateName(name string) bool <span class="cov0" title="0">{
        // Template name should not contain path separators or path traversal
        if strings.Contains(name, "..") || strings.Contains(name, "/") || strings.Contains(name, "\\") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// isPathSafe validates that the target path is within the base directory
// and doesn't contain path traversal attempts
func isPathSafe(targetPath, baseDir string) bool <span class="cov0" title="0">{
        // Clean the paths to resolve any . or .. elements
        cleanTarget := filepath.Clean(targetPath)
        cleanBase := filepath.Clean(baseDir)

        // Check for path traversal attempts
        if strings.Contains(cleanTarget, "..") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Ensure target is within base directory
        <span class="cov0" title="0">rel, err := filepath.Rel(cleanBase, cleanTarget)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if relative path goes outside base directory
        <span class="cov0" title="0">return !strings.HasPrefix(rel, "..") &amp;&amp; !strings.HasPrefix(rel, "/")</span>
}

// ValidateGeneratedCode validates the generated server code
func (s *Service) ValidateGeneratedCode() (*ValidationResult, error) <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                IsValid: true,
                Errors:  []string{},
                Warnings: []string{},
                FilesValidated: 0,
        }

        // Expected files to validate
        expectedFiles := []string{
                "main.go",
                "go.mod",
                "README.md",
        }

        // Check if all expected files exist
        for _, filename := range expectedFiles </span><span class="cov0" title="0">{
                filePath := filepath.Join(s.outputDir, filename)
                if err := s.validateFile(filePath, result); err != nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, fmt.Sprintf("Failed to validate %s: %v", filename, err))
                        result.IsValid = false
                }</span>
        }

        // Validate Go syntax for main.go
        <span class="cov0" title="0">if err := s.validateGoSyntax(filepath.Join(s.outputDir, "main.go"), result); err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Sprintf("Go syntax validation failed: %v", err))
                result.IsValid = false
        }</span>

        // Validate go.mod format
        <span class="cov0" title="0">if err := s.validateGoMod(filepath.Join(s.outputDir, "go.mod"), result); err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Sprintf("go.mod validation failed: %v", err))
                result.IsValid = false
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// validateFile checks if a file exists and is readable
func (s *Service) validateFile(filePath string, result *ValidationResult) error <span class="cov0" title="0">{
        // Validate file path is within output directory
        if !isPathSafe(filePath, s.outputDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("file path is outside output directory")
        }</span>

        // Check if file exists
        <span class="cov0" title="0">info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("file does not exist: %s", filePath)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to stat file: %w", err)</span>
        }

        // Check if it's a regular file
        <span class="cov0" title="0">if !info.Mode().IsRegular() </span><span class="cov0" title="0">{
                return fmt.Errorf("not a regular file: %s", filePath)
        }</span>

        // Check if file is readable
        <span class="cov0" title="0">if info.Mode().Perm()&amp;0400 == 0 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, fmt.Sprintf("File may not be readable: %s", filePath))
        }</span>

        // Check if file is empty
        <span class="cov0" title="0">if info.Size() == 0 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, fmt.Sprintf("File is empty: %s", filePath))
        }</span>

        <span class="cov0" title="0">result.FilesValidated++
        return nil</span>
}

// validateGoSyntax performs basic Go syntax validation
func (s *Service) validateGoSyntax(filePath string, result *ValidationResult) error <span class="cov0" title="0">{
        // Validate file path is within output directory
        if !isPathSafe(filePath, s.outputDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("file path is outside output directory")
        }</span>

        // Read the file
        <span class="cov0" title="0">content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read Go file: %w", err)
        }</span>

        // Basic syntax checks
        <span class="cov0" title="0">contentStr := string(content)
        
        // Check for package declaration
        if !strings.Contains(contentStr, "package main") </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, "Missing 'package main' declaration")
                return fmt.Errorf("missing package declaration")
        }</span>

        // Check for main function
        <span class="cov0" title="0">if !strings.Contains(contentStr, "func main()") </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, "Missing 'func main()' function")
                return fmt.Errorf("missing main function")
        }</span>

        // Check for required imports
        <span class="cov0" title="0">requiredImports := []string{
                "context",
                "encoding/json",
                "fmt",
                "log",
                "net/http",
                "os",
                "github.com/sourcegraph/jsonrpc2",
        }

        for _, imp := range requiredImports </span><span class="cov0" title="0">{
                if !strings.Contains(contentStr, fmt.Sprintf("\"%s\"", imp)) </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, fmt.Sprintf("Missing import: %s", imp))
                }</span>
        }

        // Check for balanced braces
        <span class="cov0" title="0">if !s.validateBraces(contentStr) </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, "Unbalanced braces in Go code")
                return fmt.Errorf("unbalanced braces")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateGoMod validates the go.mod file format
func (s *Service) validateGoMod(filePath string, result *ValidationResult) error <span class="cov0" title="0">{
        // Validate file path is within output directory
        if !isPathSafe(filePath, s.outputDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("file path is outside output directory")
        }</span>

        // Read the file
        <span class="cov0" title="0">content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read go.mod file: %w", err)
        }</span>

        <span class="cov0" title="0">contentStr := string(content)
        
        // Check for module declaration
        if !strings.Contains(contentStr, "module ") </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, "Missing 'module' declaration in go.mod")
                return fmt.Errorf("missing module declaration")
        }</span>

        // Check for Go version
        <span class="cov0" title="0">if !strings.Contains(contentStr, "go 1.") </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, "Missing Go version specification in go.mod")
        }</span>

        // Check for required dependencies
        <span class="cov0" title="0">requiredDeps := []string{
                "github.com/sourcegraph/jsonrpc2",
        }

        for _, dep := range requiredDeps </span><span class="cov0" title="0">{
                if !strings.Contains(contentStr, dep) </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, fmt.Sprintf("Missing dependency: %s", dep))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateBraces checks for balanced braces in Go code
func (s *Service) validateBraces(content string) bool <span class="cov0" title="0">{
        stack := 0
        inString := false
        inComment := false
        
        for i, char := range content </span><span class="cov0" title="0">{
                if inComment </span><span class="cov0" title="0">{
                        if char == '\n' </span><span class="cov0" title="0">{
                                inComment = false
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                
                <span class="cov0" title="0">if char == '/' &amp;&amp; i+1 &lt; len(content) &amp;&amp; content[i+1] == '/' </span><span class="cov0" title="0">{
                        inComment = true
                        continue</span>
                }
                
                <span class="cov0" title="0">if char == '"' &amp;&amp; (i == 0 || content[i-1] != '\\') </span><span class="cov0" title="0">{
                        inString = !inString
                        continue</span>
                }
                
                <span class="cov0" title="0">if inString </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">switch char </span>{
                case '{':<span class="cov0" title="0">
                        stack++</span>
                case '}':<span class="cov0" title="0">
                        stack--
                        if stack &lt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return stack == 0</span>
}

// createOutputStructure creates the organized directory structure for the generated project
func (s *Service) createOutputStructure() error <span class="cov0" title="0">{
        // Create main output directory
        if err := os.MkdirAll(s.outputDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create main output directory: %w", err)
        }</span>

        // Create additional directories for organized structure
        <span class="cov0" title="0">directories := []string{
                "docs",
                "examples",
                "scripts",
        }

        for _, dir := range directories </span><span class="cov0" title="0">{
                dirPath := filepath.Join(s.outputDir, dir)
                if err := os.MkdirAll(dirPath, 0750); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// generateDockerfile creates a Dockerfile for the generated server
func (s *Service) generateDockerfile(data TemplateData) error <span class="cov0" title="0">{
        dockerfileContent := fmt.Sprintf(`# Multi-stage build for %s MCP Server
FROM golang:1.21-alpine AS builder

# Set working directory
WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the server
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o server main.go

# Final stage
FROM alpine:latest

# Install ca-certificates for HTTPS requests
RUN apk --no-cache add ca-certificates

# Set working directory
WORKDIR /root/

# Copy the binary from builder stage
COPY --from=builder /app/server .

# Expose port (if needed)
EXPOSE 8080

# Run the server
CMD ["./server"]
`, data.APITitle)

        dockerfilePath := filepath.Join(s.outputDir, "Dockerfile")
        if !isPathSafe(dockerfilePath, s.outputDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid dockerfile path: path traversal detected")
        }</span>

        <span class="cov0" title="0">return os.WriteFile(dockerfilePath, []byte(dockerfileContent), 0644)</span>
}

// generateMakefile creates a Makefile for the generated server
func (s *Service) generateMakefile(data TemplateData) error <span class="cov0" title="0">{
        makefileContent := fmt.Sprintf(`# Makefile for %s MCP Server

# Variables
BINARY_NAME=%s-server
MAIN_FILE=main.go
BUILD_DIR=build
DOCKER_TAG=%s:latest

# Default target
.PHONY: all
all: clean build

# Clean build artifacts
.PHONY: clean
clean:
        rm -rf $(BUILD_DIR)
        rm -f $(BINARY_NAME)

# Build the server
.PHONY: build
build:
        mkdir -p $(BUILD_DIR)
        go build -o $(BUILD_DIR)/$(BINARY_NAME) $(MAIN_FILE)

# Run the server
.PHONY: run
run: build
        ./$(BUILD_DIR)/$(BINARY_NAME)

# Run tests
.PHONY: test
test:
        go test -v ./...

# Format code
.PHONY: fmt
fmt:
        go fmt ./...

# Vet code
.PHONY: vet
vet:
        go vet ./...

# Lint code (requires golangci-lint)
.PHONY: lint
lint:
        golangci-lint run

# Install dependencies
.PHONY: deps
deps:
        go mod download
        go mod tidy

# Build for multiple platforms
.PHONY: build-cross
build-cross:
        mkdir -p $(BUILD_DIR)
        GOOS=linux GOARCH=amd64 go build -o $(BUILD_DIR)/$(BINARY_NAME)-linux-amd64 $(MAIN_FILE)
        GOOS=darwin GOARCH=amd64 go build -o $(BUILD_DIR)/$(BINARY_NAME)-darwin-amd64 $(MAIN_FILE)
        GOOS=windows GOARCH=amd64 go build -o $(BUILD_DIR)/$(BINARY_NAME)-windows-amd64.exe $(MAIN_FILE)

# Docker build
.PHONY: docker-build
docker-build:
        docker build -t $(DOCKER_TAG) .

# Docker run
.PHONY: docker-run
docker-run:
        docker run -p 8080:8080 $(DOCKER_TAG)

# Help
.PHONY: help
help:
        @echo "Available targets:"
        @echo "  all          - Clean and build"
        @echo "  clean        - Remove build artifacts"
        @echo "  build        - Build the server"
        @echo "  run          - Build and run the server"
        @echo "  test         - Run tests"
        @echo "  fmt          - Format code"
        @echo "  vet          - Vet code"
        @echo "  lint         - Lint code"
        @echo "  deps         - Install dependencies"
        @echo "  build-cross  - Build for multiple platforms"
        @echo "  docker-build - Build Docker image"
        @echo "  docker-run   - Run Docker container"
        @echo "  help         - Show this help"
`, data.APITitle, data.PackageName, data.PackageName)

        makefilePath := filepath.Join(s.outputDir, "Makefile")
        if !isPathSafe(makefilePath, s.outputDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid makefile path: path traversal detected")
        }</span>

        <span class="cov0" title="0">return os.WriteFile(makefilePath, []byte(makefileContent), 0644)</span>
}

// generateGitignore creates a .gitignore file for the generated project
func (s *Service) generateGitignore() error <span class="cov0" title="0">{
        gitignoreContent := `# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with 'go test -c'
*.test

# Output of the go coverage tool
*.out

# Go workspace file
go.work

# Build directory
build/
dist/

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS files
.DS_Store
Thumbs.db

# Logs
*.log

# Environment variables
.env
.env.local

# Dependencies
vendor/

# Coverage reports
coverage.html
coverage.out

# Temporary files
*.tmp
*.temp
`

        gitignorePath := filepath.Join(s.outputDir, ".gitignore")
        if !isPathSafe(gitignorePath, s.outputDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid gitignore path: path traversal detected")
        }</span>

        <span class="cov0" title="0">return os.WriteFile(gitignorePath, []byte(gitignoreContent), 0644)</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">package mapping

import (
        "fmt"
        "strings"
        "unicode"

        "MCPWeaver/internal/parser"
)

// toTitle converts the first character of a string to uppercase
func toTitle(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">runes := []rune(s)
        runes[0] = unicode.ToUpper(runes[0])
        return string(runes)</span>
}

// MCPTool represents an MCP tool definition
type MCPTool struct {
        Name        string      `json:"name"`
        Description string      `json:"description"`
        InputSchema InputSchema `json:"inputSchema"`
        Method      string      `json:"-"` // HTTP method for implementation
        Path        string      `json:"-"` // API path for implementation
        BaseURL     string      `json:"-"` // Base URL for API calls
}

// InputSchema represents the JSON schema for tool input parameters
type InputSchema struct {
        Type       string              `json:"type"`
        Properties map[string]Property `json:"properties"`
        Required   []string            `json:"required"`
}

// Property represents a property in the input schema
type Property struct {
        Type        string    `json:"type"`
        Description string    `json:"description,omitempty"`
        Example     any       `json:"example,omitempty"`
        Enum        []string  `json:"enum,omitempty"`
        Format      string    `json:"format,omitempty"`
        Items       *Property `json:"items,omitempty"`
}

// Service handles the conversion from OpenAPI operations to MCP tools
type Service struct {
        baseURL string
}

// NewService creates a new endpoint mapping service
func NewService(baseURL string) *Service <span class="cov8" title="1">{
        return &amp;Service{
                baseURL: baseURL,
        }
}</span>

// MapOperationsToTools converts OpenAPI operations to MCP tools
func (s *Service) MapOperationsToTools(operations []parser.Operation) ([]MCPTool, error) <span class="cov0" title="0">{
        var tools []MCPTool
        toolNames := make(map[string]int) // Track duplicate names

        for _, op := range operations </span><span class="cov0" title="0">{
                tool, err := s.mapOperationToTool(op)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to map operation %s: %w", op.ID, err)
                }</span>

                // Handle duplicate tool names
                <span class="cov0" title="0">if count, exists := toolNames[tool.Name]; exists </span><span class="cov0" title="0">{
                        toolNames[tool.Name] = count + 1
                        tool.Name = fmt.Sprintf("%s_%d", tool.Name, count+1)
                }</span> else<span class="cov0" title="0"> {
                        toolNames[tool.Name] = 1
                }</span>

                <span class="cov0" title="0">tools = append(tools, tool)</span>
        }

        <span class="cov0" title="0">return tools, nil</span>
}

// mapOperationToTool converts a single OpenAPI operation to an MCP tool
func (s *Service) mapOperationToTool(op parser.Operation) (MCPTool, error) <span class="cov8" title="1">{
        tool := MCPTool{
                Name:        s.generateToolName(op),
                Description: s.generateToolDescription(op),
                Method:      op.Method,
                Path:        op.Path,
                BaseURL:     s.baseURL,
                InputSchema: InputSchema{
                        Type:       "object",
                        Properties: make(map[string]Property),
                        Required:   []string{},
                },
        }

        // Map parameters to input schema properties
        for _, param := range op.Parameters </span><span class="cov8" title="1">{
                property, err := s.mapParameterToProperty(param)
                if err != nil </span><span class="cov0" title="0">{
                        return tool, fmt.Errorf("failed to map parameter %s: %w", param.Name, err)
                }</span>

                <span class="cov8" title="1">tool.InputSchema.Properties[param.Name] = property

                if param.Required </span><span class="cov8" title="1">{
                        tool.InputSchema.Required = append(tool.InputSchema.Required, param.Name)
                }</span>
        }

        // Handle request body for POST/PUT operations
        <span class="cov8" title="1">if op.RequestBody != nil &amp;&amp; (op.Method == "POST" || op.Method == "PUT" || op.Method == "PATCH") </span><span class="cov0" title="0">{
                bodyProperty, err := s.mapRequestBodyToProperty(op.RequestBody)
                if err != nil </span><span class="cov0" title="0">{
                        return tool, fmt.Errorf("failed to map request body: %w", err)
                }</span>

                <span class="cov0" title="0">tool.InputSchema.Properties["body"] = bodyProperty

                if op.RequestBody.Required </span><span class="cov0" title="0">{
                        tool.InputSchema.Required = append(tool.InputSchema.Required, "body")
                }</span>
        }

        <span class="cov8" title="1">return tool, nil</span>
}

// generateToolName creates a tool name from the operation
func (s *Service) generateToolName(op parser.Operation) string <span class="cov8" title="1">{
        if op.ID != "" </span><span class="cov8" title="1">{
                return op.ID
        }</span>

        // Generate from method and path
        <span class="cov8" title="1">parts := strings.Split(op.Path, "/")
        var cleanParts []string

        for _, part := range parts </span><span class="cov8" title="1">{
                if part == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Remove path parameters braces
                <span class="cov8" title="1">part = strings.ReplaceAll(part, "{", "")
                part = strings.ReplaceAll(part, "}", "")
                // Convert to camelCase
                if len(cleanParts) &gt; 0 </span><span class="cov8" title="1">{
                        part = toTitle(part)
                }</span>
                <span class="cov8" title="1">cleanParts = append(cleanParts, part)</span>
        }

        <span class="cov8" title="1">pathPart := strings.Join(cleanParts, "")
        return strings.ToLower(op.Method) + toTitle(pathPart)</span>
}

// generateToolDescription creates a description for the tool
func (s *Service) generateToolDescription(op parser.Operation) string <span class="cov8" title="1">{
        if op.Description != "" </span><span class="cov8" title="1">{
                return op.Description
        }</span>

        <span class="cov8" title="1">if op.Summary != "" </span><span class="cov8" title="1">{
                return op.Summary
        }</span>

        // Generate generic description
        <span class="cov8" title="1">action := s.getActionFromMethod(op.Method)
        resource := s.getResourceFromPath(op.Path)

        return fmt.Sprintf("%s %s", action, resource)</span>
}

// getActionFromMethod returns a human-readable action for the HTTP method
func (s *Service) getActionFromMethod(method string) string <span class="cov8" title="1">{
        switch strings.ToUpper(method) </span>{
        case "GET":<span class="cov8" title="1">
                return "Retrieve"</span>
        case "POST":<span class="cov8" title="1">
                return "Create"</span>
        case "PUT":<span class="cov8" title="1">
                return "Update"</span>
        case "PATCH":<span class="cov8" title="1">
                return "Modify"</span>
        case "DELETE":<span class="cov8" title="1">
                return "Delete"</span>
        default:<span class="cov8" title="1">
                return "Perform operation on"</span>
        }
}

// getResourceFromPath extracts the resource name from the path
func (s *Service) getResourceFromPath(path string) string <span class="cov8" title="1">{
        parts := strings.Split(path, "/")
        for i := len(parts) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                part := parts[i]
                if part != "" &amp;&amp; !strings.Contains(part, "{") </span><span class="cov8" title="1">{
                        return part
                }</span>
        }
        <span class="cov8" title="1">return "resource"</span>
}

// mapParameterToProperty converts an OpenAPI parameter to a JSON schema property
func (s *Service) mapParameterToProperty(param parser.Parameter) (Property, error) <span class="cov8" title="1">{
        property := Property{
                Description: param.Description,
                Example:     param.Example,
        }

        // Handle missing schema gracefully
        if param.Schema == nil || param.Schema.Value == nil </span><span class="cov0" title="0">{
                property.Type = "string"
                return property, nil
        }</span>

        <span class="cov8" title="1">schema := param.Schema.Value

        // Map basic type with error handling
        if schema.Type != nil &amp;&amp; len(*schema.Type) &gt; 0 </span><span class="cov8" title="1">{
                schemaType := (*schema.Type)[0]
                // Validate type is supported
                supportedTypes := map[string]bool{
                        "string": true, "number": true, "integer": true, 
                        "boolean": true, "array": true, "object": true,
                }
                if !supportedTypes[schemaType] </span><span class="cov0" title="0">{
                        return property, fmt.Errorf("unsupported parameter type: %s", schemaType)
                }</span>
                <span class="cov8" title="1">property.Type = schemaType</span>
        } else<span class="cov0" title="0"> {
                property.Type = "string"
        }</span>

        // Map format with validation
        <span class="cov8" title="1">if schema.Format != "" </span><span class="cov8" title="1">{
                property.Format = schema.Format
        }</span>

        // Map enum values with type safety
        <span class="cov8" title="1">if len(schema.Enum) &gt; 0 </span><span class="cov0" title="0">{
                for _, enumVal := range schema.Enum </span><span class="cov0" title="0">{
                        if str, ok := enumVal.(string); ok </span><span class="cov0" title="0">{
                                property.Enum = append(property.Enum, str)
                        }</span>
                }
        }

        // Handle array types with proper validation
        <span class="cov8" title="1">if property.Type == "array" &amp;&amp; schema.Items != nil &amp;&amp; schema.Items.Value != nil </span><span class="cov0" title="0">{
                items := &amp;Property{}
                if schema.Items.Value.Type != nil &amp;&amp; len(*schema.Items.Value.Type) &gt; 0 </span><span class="cov0" title="0">{
                        items.Type = (*schema.Items.Value.Type)[0]
                }</span> else<span class="cov0" title="0"> {
                        items.Type = "string"
                }</span>
                <span class="cov0" title="0">if schema.Items.Value.Format != "" </span><span class="cov0" title="0">{
                        items.Format = schema.Items.Value.Format
                }</span>
                <span class="cov0" title="0">property.Items = items</span>
        }

        <span class="cov8" title="1">return property, nil</span>
}

// mapRequestBodyToProperty converts a request body to a JSON schema property
func (s *Service) mapRequestBodyToProperty(reqBody *parser.RequestBody) (Property, error) <span class="cov0" title="0">{
        property := Property{
                Type:        "object",
                Description: reqBody.Description,
        }

        // For now, we'll treat all request bodies as generic objects
        // In a more sophisticated implementation, we would parse the actual schema
        if len(reqBody.Content) &gt; 0 </span><span class="cov0" title="0">{
                // Look for JSON content first
                if jsonContent, exists := reqBody.Content["application/json"]; exists </span><span class="cov0" title="0">{
                        if jsonContent.Schema != nil &amp;&amp; jsonContent.Schema.Value != nil </span><span class="cov0" title="0">{
                                // This would require more complex schema parsing
                                // For now, keep as generic object
                                property.Description = fmt.Sprintf("%s (JSON object)", property.Description)
                        }</span>
                }
        }

        <span class="cov0" title="0">return property, nil</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">package parser

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "path"
        "regexp"
        "strings"
        "sync"
        "time"
        "unicode"

        "github.com/getkin/kin-openapi/openapi3"
)

// Compiled regex patterns for preprocessing (cached for performance)
var (
        tupleRegexOnce      sync.Once
        tupleRegex          *regexp.Regexp
        additionalItemsOnce sync.Once
        additionalItemsRegex *regexp.Regexp
        lookAheadOnce       sync.Once
        lookAheadRegex      *regexp.Regexp
        negLookAheadOnce    sync.Once
        negLookAheadRegex   *regexp.Regexp
)

// getTupleRegex returns the compiled tuple regex pattern
func getTupleRegex() *regexp.Regexp <span class="cov8" title="1">{
        tupleRegexOnce.Do(func() </span><span class="cov8" title="1">{
                tupleRegex = regexp.MustCompile(`(\s+items:\s*\n\s+)- (type: object\s*\n(?:\s+properties:\s*\n(?:\s+[^\n-]*\n)*)?)`)
        }</span>)
        <span class="cov8" title="1">return tupleRegex</span>
}

// getAdditionalItemsRegex returns the compiled additional items regex pattern
func getAdditionalItemsRegex() *regexp.Regexp <span class="cov8" title="1">{
        additionalItemsOnce.Do(func() </span><span class="cov8" title="1">{
                additionalItemsRegex = regexp.MustCompile(`(?m)^\s+additionalItems:.*\n`)
        }</span>)
        <span class="cov8" title="1">return additionalItemsRegex</span>
}

// getLookAheadRegex returns the compiled lookahead regex pattern
func getLookAheadRegex() *regexp.Regexp <span class="cov0" title="0">{
        lookAheadOnce.Do(func() </span><span class="cov0" title="0">{
                lookAheadRegex = regexp.MustCompile(`\(\?\=[^)]*\)`)
        }</span>)
        <span class="cov0" title="0">return lookAheadRegex</span>
}

// getNegLookAheadRegex returns the compiled negative lookahead regex pattern
func getNegLookAheadRegex() *regexp.Regexp <span class="cov0" title="0">{
        negLookAheadOnce.Do(func() </span><span class="cov0" title="0">{
                negLookAheadRegex = regexp.MustCompile(`\(\?\![^)]*\)`)
        }</span>)
        <span class="cov0" title="0">return negLookAheadRegex</span>
}

// toTitle converts the first character of a string to uppercase
func toTitle(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">runes := []rune(s)
        runes[0] = unicode.ToUpper(runes[0])
        return string(runes)</span>
}

// Service handles OpenAPI specification parsing
type Service struct {
        loader *openapi3.Loader
}

// NewService creates a new OpenAPI parser service
func NewService() *Service <span class="cov8" title="1">{
        return &amp;Service{
                loader: openapi3.NewLoader(),
        }
}</span>

// ParseFromFile parses an OpenAPI specification from a file
func (s *Service) ParseFromFile(filePath string) (*ParsedAPI, error) <span class="cov0" title="0">{
        doc, err := s.loader.LoadFromFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load OpenAPI spec: %w", err)
        }</span>

        <span class="cov0" title="0">return s.parseDocument(doc)</span>
}

// ParseFromURL parses an OpenAPI specification from a URL
func (s *Service) ParseFromURL(ctx context.Context, specURL string) (*ParsedAPI, error) <span class="cov0" title="0">{
        // Validate URL format
        if _, err := url.Parse(specURL); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid URL: %w", err)
        }</span>

        // For better YAML support, we'll fetch the content manually and then parse
        <span class="cov0" title="0">doc, err := s.loadFromURLWithContext(ctx, specURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load OpenAPI spec from URL: %w", err)
        }</span>

        <span class="cov0" title="0">return s.parseDocument(doc)</span>
}

// parseDocument converts an OpenAPI document to our internal representation
func (s *Service) parseDocument(doc *openapi3.T) (*ParsedAPI, error) <span class="cov8" title="1">{
        // Validate the document - use a more lenient validation for problematic specs
        ctx := context.Background()
        if err := doc.Validate(ctx); err != nil </span><span class="cov0" title="0">{
                // Try to provide more helpful error details for common issues
                errorStr := err.Error()
                if strings.Contains(errorStr, "items") &amp;&amp; strings.Contains(errorStr, "array") </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("OpenAPI validation failed due to array schema issue: %w\n\nThis specification contains array definitions that use tuple-style or non-standard schema formats.\nThese are valid in JSON Schema but not fully supported by the kin-openapi library.\nConsider simplifying array schemas to use standard 'items' object definitions", err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("OpenAPI validation failed: %w", err)</span>
        }

        <span class="cov8" title="1">parsed := &amp;ParsedAPI{
                Document:    doc,
                Title:       doc.Info.Title,
                Version:     doc.Info.Version,
                Description: doc.Info.Description,
                Schemas:     make(map[string]*openapi3.SchemaRef),
        }

        // Extract base URL from servers
        if len(doc.Servers) &gt; 0 </span><span class="cov0" title="0">{
                parsed.BaseURL = doc.Servers[0].URL
                for _, server := range doc.Servers </span><span class="cov0" title="0">{
                        parsed.Servers = append(parsed.Servers, server.URL)
                }</span>
        }

        // Extract schemas from components
        <span class="cov8" title="1">if doc.Components != nil &amp;&amp; doc.Components.Schemas != nil </span><span class="cov0" title="0">{
                for name, schema := range doc.Components.Schemas </span><span class="cov0" title="0">{
                        parsed.Schemas[name] = schema
                }</span>
        }

        // Extract operations
        <span class="cov8" title="1">operations, err := s.extractOperations(doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to extract operations: %w", err)
        }</span>
        <span class="cov8" title="1">parsed.Operations = operations

        return parsed, nil</span>
}

// extractOperations extracts all operations from the OpenAPI document
func (s *Service) extractOperations(doc *openapi3.T) ([]Operation, error) <span class="cov8" title="1">{
        var operations []Operation

        for path, pathItem := range doc.Paths.Map() </span><span class="cov8" title="1">{
                for method, operation := range pathItem.Operations() </span><span class="cov8" title="1">{
                        if operation == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">op := Operation{
                                ID:          operation.OperationID,
                                Method:      strings.ToUpper(method),
                                Path:        path,
                                Summary:     operation.Summary,
                                Description: operation.Description,
                                Tags:        operation.Tags,
                                Responses:   make(map[string]*Response),
                        }

                        // Generate operation ID if not provided
                        if op.ID == "" </span><span class="cov0" title="0">{
                                op.ID = s.generateOperationID(method, path)
                        }</span>

                        // Extract parameters
                        <span class="cov8" title="1">parameters, err := s.extractParameters(operation.Parameters)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to extract parameters for %s %s: %w", method, path, err)
                        }</span>
                        <span class="cov8" title="1">op.Parameters = parameters

                        // Extract request body
                        if operation.RequestBody != nil </span><span class="cov0" title="0">{
                                requestBody, err := s.extractRequestBody(operation.RequestBody)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to extract request body for %s %s: %w", method, path, err)
                                }</span>
                                <span class="cov0" title="0">op.RequestBody = requestBody</span>
                        }

                        // Extract responses
                        <span class="cov8" title="1">responses, err := s.extractResponses(operation.Responses)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to extract responses for %s %s: %w", method, path, err)
                        }</span>
                        <span class="cov8" title="1">op.Responses = responses

                        // Extract security requirements
                        if operation.Security != nil </span><span class="cov0" title="0">{
                                for _, security := range *operation.Security </span><span class="cov0" title="0">{
                                        op.Security = append(op.Security, security)
                                }</span>
                        }

                        <span class="cov8" title="1">operations = append(operations, op)</span>
                }
        }

        <span class="cov8" title="1">return operations, nil</span>
}

// generateOperationID generates an operation ID from method and path
func (s *Service) generateOperationID(method, path string) string <span class="cov8" title="1">{
        // Convert path to camelCase identifier
        parts := strings.Split(path, "/")
        var cleanParts []string

        for _, part := range parts </span><span class="cov8" title="1">{
                if part == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Remove path parameters braces
                <span class="cov8" title="1">part = strings.ReplaceAll(part, "{", "")
                part = strings.ReplaceAll(part, "}", "")
                // Convert to camelCase
                if len(cleanParts) &gt; 0 </span><span class="cov8" title="1">{
                        part = toTitle(part)
                }</span>
                <span class="cov8" title="1">cleanParts = append(cleanParts, part)</span>
        }

        <span class="cov8" title="1">pathPart := strings.Join(cleanParts, "")
        return strings.ToLower(method) + toTitle(pathPart)</span>
}

// extractParameters extracts parameter information
func (s *Service) extractParameters(params openapi3.Parameters) ([]Parameter, error) <span class="cov8" title="1">{
        var parameters []Parameter

        for _, paramRef := range params </span><span class="cov0" title="0">{
                if paramRef.Value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">param := Parameter{
                        Name:        paramRef.Value.Name,
                        In:          paramRef.Value.In,
                        Description: paramRef.Value.Description,
                        Required:    paramRef.Value.Required,
                        Schema:      paramRef.Value.Schema,
                        Example:     paramRef.Value.Example,
                }

                parameters = append(parameters, param)</span>
        }

        <span class="cov8" title="1">return parameters, nil</span>
}

// extractRequestBody extracts request body information
func (s *Service) extractRequestBody(reqBodyRef *openapi3.RequestBodyRef) (*RequestBody, error) <span class="cov0" title="0">{
        if reqBodyRef == nil || reqBodyRef.Value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">requestBody := &amp;RequestBody{
                Description: reqBodyRef.Value.Description,
                Required:    reqBodyRef.Value.Required,
                Content:     make(map[string]*MediaType),
        }

        for mediaType, mediaTypeObj := range reqBodyRef.Value.Content </span><span class="cov0" title="0">{
                mt := &amp;MediaType{
                        Schema:   mediaTypeObj.Schema,
                        Example:  mediaTypeObj.Example,
                        Examples: mediaTypeObj.Examples,
                }
                requestBody.Content[mediaType] = mt
        }</span>

        <span class="cov0" title="0">return requestBody, nil</span>
}

// extractResponses extracts response information
func (s *Service) extractResponses(responses *openapi3.Responses) (map[string]*Response, error) <span class="cov8" title="1">{
        result := make(map[string]*Response)

        if responses == nil </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov8" title="1">for status, responseRef := range responses.Map() </span><span class="cov0" title="0">{
                if responseRef.Value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">description := ""
                if responseRef.Value.Description != nil </span><span class="cov0" title="0">{
                        description = *responseRef.Value.Description
                }</span>

                <span class="cov0" title="0">response := &amp;Response{
                        Description: description,
                        Headers:     responseRef.Value.Headers,
                        Content:     make(map[string]*MediaType),
                }

                for mediaType, mediaTypeObj := range responseRef.Value.Content </span><span class="cov0" title="0">{
                        mt := &amp;MediaType{
                                Schema:   mediaTypeObj.Schema,
                                Example:  mediaTypeObj.Example,
                                Examples: mediaTypeObj.Examples,
                        }
                        response.Content[mediaType] = mt
                }</span>

                <span class="cov0" title="0">result[status] = response</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// loadFromURLWithContext fetches OpenAPI spec from URL with better YAML/JSON handling
func (s *Service) loadFromURLWithContext(ctx context.Context, specURL string) (*openapi3.T, error) <span class="cov0" title="0">{
        // Create HTTP client with timeout
        client := &amp;http.Client{
                Timeout: 30 * time.Second,
        }

        // Create request with context
        req, err := http.NewRequestWithContext(ctx, "GET", specURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        // Set appropriate Accept header for both JSON and YAML
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json, application/x-yaml, text/yaml, text/x-yaml, */*")
        req.Header.Set("User-Agent", "MCPWeaver/1.0")

        // Make the request
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch URL: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP error: %d %s", resp.StatusCode, resp.Status)
        }</span>

        // Read the response body
        <span class="cov0" title="0">data, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Determine if this is likely YAML based on URL path extension
        <span class="cov0" title="0">parsedURL, _ := url.Parse(specURL)
        isYAML := strings.HasSuffix(strings.ToLower(path.Ext(parsedURL.Path)), ".yaml") ||
                strings.HasSuffix(strings.ToLower(path.Ext(parsedURL.Path)), ".yml")

        // Pre-process the data to fix common schema issues
        processedData := s.preprocessSpecData(data)

        // Parse the processed data using the appropriate method
        var doc *openapi3.T
        if isYAML </span><span class="cov0" title="0">{
                // Try YAML first for .yaml/.yml files
                doc, err = s.loader.LoadFromData(processedData)
                if err != nil </span><span class="cov0" title="0">{
                        // If YAML parsing fails, try JSON as fallback
                        doc, err = s.loader.LoadFromData(processedData)
                }</span>
        } else<span class="cov0" title="0"> {
                // Try JSON first for other extensions
                doc, err = s.loader.LoadFromData(processedData)
                if err != nil </span><span class="cov0" title="0">{
                        // If JSON parsing fails, try YAML as fallback
                        doc, err = s.loader.LoadFromData(processedData)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse OpenAPI specification: %w\n\nHint: This may be due to:\n- Invalid OpenAPI schema syntax in the source file\n- Non-standard OpenAPI extensions\n- OpenAPI 2.0 spec (this tool requires OpenAPI 3.0+)\n- Malformed YAML/JSON structure", err)
        }</span>

        <span class="cov0" title="0">return doc, nil</span>
}

// preprocessSpecData applies common fixes for schema compatibility issues
func (s *Service) preprocessSpecData(data []byte) []byte <span class="cov8" title="1">{
        content := string(data)

        // Fix 1: Handle tuple-style array items
        tupleRegex := getTupleRegex()
        if tupleRegex.MatchString(content) </span><span class="cov0" title="0">{
                content = tupleRegex.ReplaceAllString(content, `${1}$2`)
        }</span>

        // Fix 2: Remove additionalItems which is not well supported
        <span class="cov8" title="1">additionalItemsRegex := getAdditionalItemsRegex()
        content = additionalItemsRegex.ReplaceAllString(content, "")

        // Fix 3: Handle unsupported regex patterns
        lines := strings.Split(content, "\n")
        for i, line := range lines </span><span class="cov8" title="1">{
                if strings.Contains(line, "pattern:") &amp;&amp; strings.Contains(line, "(?") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(line, "pattern:", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                indent := parts[0]
                                patternPart := strings.TrimSpace(parts[1])

                                // Handle quoted patterns
                                var quote string
                                if strings.HasPrefix(patternPart, "\"") </span><span class="cov0" title="0">{
                                        quote = "\""
                                        patternPart = strings.Trim(patternPart, "\"")
                                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(patternPart, "'") </span><span class="cov8" title="1">{
                                        quote = "'"
                                        patternPart = strings.Trim(patternPart, "'")
                                }</span>

                                // Handle patterns wrapped in forward slashes
                                <span class="cov8" title="1">if strings.HasPrefix(patternPart, "/") &amp;&amp; strings.HasSuffix(patternPart, "/") </span><span class="cov8" title="1">{
                                        patternPart = strings.Trim(patternPart, "/")
                                }</span>

                                // Remove unsupported lookahead/lookbehind assertions
                                <span class="cov8" title="1">if strings.Contains(patternPart, "(?=") || strings.Contains(patternPart, "(?!") </span><span class="cov8" title="1">{
                                        // For password validation patterns, replace with simpler equivalent
                                        if strings.Contains(patternPart, "(?=.*[a-z])") &amp;&amp; strings.Contains(patternPart, "(?=.*[A-Z])") </span><span class="cov8" title="1">{
                                                patternPart = "^[a-zA-Z0-9]+$"
                                        }</span> else<span class="cov0" title="0"> {
                                                // Remove lookahead/lookbehind for other patterns using cached regex
                                                lookAheadRegex := getLookAheadRegex()
                                                patternPart = lookAheadRegex.ReplaceAllString(patternPart, "")
                                                negLookAheadRegex := getNegLookAheadRegex()
                                                patternPart = negLookAheadRegex.ReplaceAllString(patternPart, "")
                                        }</span>

                                        <span class="cov8" title="1">patternPart = strings.TrimSpace(patternPart)
                                        if patternPart != "" </span><span class="cov8" title="1">{
                                                if quote != "" </span><span class="cov8" title="1">{
                                                        lines[i] = indent + "pattern: " + quote + patternPart + quote
                                                }</span> else<span class="cov0" title="0"> {
                                                        lines[i] = indent + "pattern: " + patternPart
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                lines[i] = indent + "# pattern: # removed unsupported regex"
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return []byte(strings.Join(lines, "\n"))</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">package project

import (
        "context"
        "fmt"
        "time"
)

// Service handles project management operations
type Service struct {
        // Add database connection and configuration
}

// Project represents a project
type Project struct {
        ID        string    `json:"id"`
        Name      string    `json:"name"`
        SpecPath  string    `json:"specPath"`
        CreatedAt time.Time `json:"createdAt"`
        UpdatedAt time.Time `json:"updatedAt"`
}

// CreateProjectRequest represents a request to create a project
type CreateProjectRequest struct {
        Name     string `json:"name"`
        SpecPath string `json:"specPath"`
}

// New creates a new project service
func New() *Service <span class="cov0" title="0">{
        return &amp;Service{}
}</span>

// Create creates a new project
func (s *Service) Create(ctx context.Context, req CreateProjectRequest) (*Project, error) <span class="cov0" title="0">{
        // TODO: Implement project creation
        project := &amp;Project{
                ID:        generateID(),
                Name:      req.Name,
                SpecPath:  req.SpecPath,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }
        return project, fmt.Errorf("not yet implemented")
}</span>

// GetAll returns all projects
func (s *Service) GetAll(ctx context.Context) ([]*Project, error) <span class="cov0" title="0">{
        // TODO: Implement project retrieval
        return nil, fmt.Errorf("not yet implemented")
}</span>

// GetByID returns a project by ID
func (s *Service) GetByID(ctx context.Context, id string) (*Project, error) <span class="cov0" title="0">{
        // TODO: Implement project retrieval by ID
        return nil, fmt.Errorf("not yet implemented")
}</span>

// generateID generates a unique ID for projects
func generateID() string <span class="cov0" title="0">{
        return fmt.Sprintf("proj_%d", time.Now().UnixNano())
}</pre>
		
		<pre class="file" id="file26" style="display: none">package validator

import (
        "context"
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/getkin/kin-openapi/openapi3"
)

// Service handles validation operations
type Service struct {
        loader *openapi3.Loader
}

// ValidationResult represents comprehensive validation results
type ValidationResult struct {
        Valid           bool                `json:"valid"`
        Errors          []ValidationError   `json:"errors"`
        Warnings        []ValidationWarning `json:"warnings"`
        Suggestions     []string            `json:"suggestions"`
        SpecInfo        *SpecInfo           `json:"specInfo,omitempty"`
        ValidationTime  time.Duration       `json:"validationTime"`
        CacheHit        bool                `json:"cacheHit"`
        ValidatedAt     time.Time           `json:"validatedAt"`
}

// ValidationError represents a validation error with detailed information
type ValidationError struct {
        Type        string         `json:"type"`
        Code        string         `json:"code"`
        Message     string         `json:"message"`
        Path        string         `json:"path"`
        Line        int            `json:"line,omitempty"`
        Column      int            `json:"column,omitempty"`
        Severity    SeverityLevel  `json:"severity"`
        Location    *ErrorLocation `json:"location,omitempty"`
        Context     string         `json:"context,omitempty"`
        Suggestion  string         `json:"suggestion,omitempty"`
}

// ValidationWarning represents a validation warning
type ValidationWarning struct {
        Type        string `json:"type"`
        Code        string `json:"code"`
        Message     string `json:"message"`
        Path        string `json:"path"`
        Suggestion  string `json:"suggestion"`
        Context     string `json:"context,omitempty"`
}

// SeverityLevel represents the severity of a validation issue
type SeverityLevel string

const (
        SeverityError   SeverityLevel = "error"
        SeverityWarning SeverityLevel = "warning"
        SeverityInfo    SeverityLevel = "info"
)

// ErrorLocation provides detailed location information for errors
type ErrorLocation struct {
        File   string `json:"file"`
        Line   int    `json:"line"`
        Column int    `json:"column"`
        Path   string `json:"path"`
}

// SpecInfo provides information about the validated specification
type SpecInfo struct {
        Version         string              `json:"version"`
        Title           string              `json:"title"`
        Description     string              `json:"description"`
        OperationCount  int                 `json:"operationCount"`
        SchemaCount     int                 `json:"schemaCount"`
        SecuritySchemes []SecuritySchemeInfo `json:"securitySchemes"`
        Servers         []ServerInfo        `json:"servers"`
        Tags            []TagInfo           `json:"tags"`
        Complexity      ComplexityLevel     `json:"complexity"`
        EstimatedSize   string              `json:"estimatedSize"`
}

// SecuritySchemeInfo provides information about security schemes
type SecuritySchemeInfo struct {
        Type         string `json:"type"`
        Name         string `json:"name"`
        Description  string `json:"description"`
        In           string `json:"in,omitempty"`
        Scheme       string `json:"scheme,omitempty"`
        BearerFormat string `json:"bearerFormat,omitempty"`
        OpenIDConnectURL string `json:"openIdConnectUrl,omitempty"`
}

// ServerInfo provides information about servers
type ServerInfo struct {
        URL         string                    `json:"url"`
        Description string                    `json:"description"`
        Variables   map[string]*ServerVariable `json:"variables,omitempty"`
}

// ServerVariable provides information about server variables
type ServerVariable struct {
        Default     string   `json:"default"`
        Description string   `json:"description"`
        Enum        []string `json:"enum,omitempty"`
}

// TagInfo provides information about tags
type TagInfo struct {
        Name         string            `json:"name"`
        Description  string            `json:"description"`
        ExternalDocs *ExternalDocsInfo `json:"externalDocs,omitempty"`
}

// ExternalDocsInfo provides information about external documentation
type ExternalDocsInfo struct {
        Description string `json:"description"`
        URL         string `json:"url"`
}

// ComplexityLevel represents the complexity of the specification
type ComplexityLevel string

const (
        ComplexityLow    ComplexityLevel = "low"
        ComplexityMedium ComplexityLevel = "medium"
        ComplexityHigh   ComplexityLevel = "high"
)

// New creates a new validator service
func New() *Service <span class="cov8" title="1">{
        return &amp;Service{
                loader: openapi3.NewLoader(),
        }
}</span>

// ValidateSpec validates an OpenAPI specification document
func (s *Service) ValidateSpec(ctx context.Context, spec *openapi3.T) (*ValidationResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        
        result := &amp;ValidationResult{
                Valid:          true,
                Errors:         []ValidationError{},
                Warnings:       []ValidationWarning{},
                Suggestions:    []string{},
                ValidationTime: 0,
                CacheHit:       false,
                ValidatedAt:    startTime,
        }

        // Basic specification validation
        if err := spec.Validate(ctx); err != nil </span><span class="cov8" title="1">{
                result.Valid = false
                s.parseValidationError(err, result)
        }</span>

        // Extract specification information
        <span class="cov8" title="1">s.extractSpecInfo(spec, result)

        // Perform detailed validation
        s.validateOperations(spec, result)
        s.validateSchemas(spec, result)
        s.validateSecuritySchemes(spec, result)
        s.validateServers(spec, result)
        s.validateExamples(spec, result)
        s.validateReferences(spec, result)

        // Generate suggestions
        s.generateSuggestions(spec, result)

        // Set final validation time
        result.ValidationTime = time.Since(startTime)

        return result, nil</span>
}

// ValidateFile validates an OpenAPI specification file
func (s *Service) ValidateFile(ctx context.Context, filePath string) (*ValidationResult, error) <span class="cov8" title="1">{
        // Check if file exists
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return &amp;ValidationResult{
                        Valid: false,
                        Errors: []ValidationError{
                                {
                                        Type:     "file",
                                        Code:     "FILE_NOT_FOUND",
                                        Message:  fmt.Sprintf("File not found: %s", filePath),
                                        Path:     filePath,
                                        Severity: SeverityError,
                                },
                        },
                        Warnings:    []ValidationWarning{},
                        Suggestions: []string{},
                }, nil
        }</span>

        // Load the specification
        <span class="cov8" title="1">spec, err := s.loader.LoadFromFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationResult{
                        Valid: false,
                        Errors: []ValidationError{
                                {
                                        Type:     "parsing",
                                        Code:     "PARSING_ERROR",
                                        Message:  fmt.Sprintf("Failed to parse OpenAPI specification: %v", err),
                                        Path:     filePath,
                                        Severity: SeverityError,
                                        Location: &amp;ErrorLocation{
                                                File: filepath.Base(filePath),
                                        },
                                },
                        },
                        Warnings:    []ValidationWarning{},
                        Suggestions: s.getParsingErrorSuggestions(err),
                }, nil
        }</span>

        // Validate the specification
        <span class="cov8" title="1">return s.ValidateSpec(ctx, spec)</span>
}

// ValidateURL validates an OpenAPI specification from a URL
func (s *Service) ValidateURL(ctx context.Context, specURL string) (*ValidationResult, error) <span class="cov8" title="1">{
        // Validate URL format
        if _, err := url.Parse(specURL); err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationResult{
                        Valid: false,
                        Errors: []ValidationError{
                                {
                                        Type:     "url",
                                        Code:     "INVALID_URL",
                                        Message:  fmt.Sprintf("Invalid URL format: %v", err),
                                        Path:     specURL,
                                        Severity: SeverityError,
                                },
                        },
                        Warnings:    []ValidationWarning{},
                        Suggestions: []string{"Please provide a valid URL"},
                }, nil
        }</span>

        // Load the specification from URL
        <span class="cov8" title="1">parsedURL, err := url.Parse(specURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ValidationResult{
                        Valid: false,
                        Errors: []ValidationError{
                                {
                                        Type:     "url",
                                        Code:     "INVALID_URL",
                                        Message:  fmt.Sprintf("Invalid URL format: %v", err),
                                        Path:     specURL,
                                        Severity: SeverityError,
                                },
                        },
                        Warnings:    []ValidationWarning{},
                        Suggestions: []string{"Please provide a valid URL"},
                }, nil
        }</span>
        
        <span class="cov8" title="1">spec, err := s.loader.LoadFromURI(parsedURL)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;ValidationResult{
                        Valid: false,
                        Errors: []ValidationError{
                                {
                                        Type:     "network",
                                        Code:     "NETWORK_ERROR",
                                        Message:  fmt.Sprintf("Failed to fetch OpenAPI specification: %v", err),
                                        Path:     specURL,
                                        Severity: SeverityError,
                                },
                        },
                        Warnings:    []ValidationWarning{},
                        Suggestions: s.getNetworkErrorSuggestions(err),
                }, nil
        }</span>

        // Validate the specification
        <span class="cov0" title="0">return s.ValidateSpec(ctx, spec)</span>
}

// parseValidationError parses validation errors from kin-openapi
func (s *Service) parseValidationError(err error, result *ValidationResult) <span class="cov8" title="1">{
        errorMsg := err.Error()
        
        // Try to extract line and column information
        lineRegex := regexp.MustCompile(`line (\d+)`)
        columnRegex := regexp.MustCompile(`column (\d+)`)
        
        var line, column int
        if matches := lineRegex.FindStringSubmatch(errorMsg); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                fmt.Sscanf(matches[1], "%d", &amp;line)
        }</span>
        <span class="cov8" title="1">if matches := columnRegex.FindStringSubmatch(errorMsg); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                fmt.Sscanf(matches[1], "%d", &amp;column)
        }</span>

        <span class="cov8" title="1">result.Errors = append(result.Errors, ValidationError{
                Type:     "validation",
                Code:     "SPEC_VALIDATION_ERROR",
                Message:  errorMsg,
                Path:     "/",
                Line:     line,
                Column:   column,
                Severity: SeverityError,
                Location: &amp;ErrorLocation{
                        Line:   line,
                        Column: column,
                },
        })</span>
}

// extractSpecInfo extracts information from the specification
func (s *Service) extractSpecInfo(spec *openapi3.T, result *ValidationResult) <span class="cov8" title="1">{
        info := &amp;SpecInfo{
                Version:         spec.OpenAPI,
                Title:           spec.Info.Title,
                Description:     spec.Info.Description,
                OperationCount:  s.countOperations(spec),
                SchemaCount:     s.countSchemas(spec),
                SecuritySchemes: s.extractSecuritySchemes(spec),
                Servers:         s.extractServers(spec),
                Tags:            s.extractTags(spec),
                Complexity:      s.assessComplexity(spec),
                EstimatedSize:   s.estimateSize(spec),
        }
        
        result.SpecInfo = info
}</span>

// validateOperations validates all operations in the specification
func (s *Service) validateOperations(spec *openapi3.T, result *ValidationResult) <span class="cov8" title="1">{
        if spec.Paths == nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Type:       "operations",
                        Code:       "NO_PATHS",
                        Message:    "No paths defined in the specification",
                        Path:       "/paths",
                        Suggestion: "Add API endpoints to generate MCP tools",
                })
                return
        }</span>

        <span class="cov8" title="1">operationIds := make(map[string]bool)
        
        for path, pathItem := range spec.Paths.Map() </span><span class="cov8" title="1">{
                if pathItem == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov8" title="1">for method, operation := range pathItem.Operations() </span><span class="cov8" title="1">{
                        if operation == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        
                        <span class="cov8" title="1">opPath := fmt.Sprintf("/paths%s/%s", path, strings.ToLower(method))
                        
                        // Check for duplicate operation IDs
                        if operation.OperationID != "" </span><span class="cov8" title="1">{
                                if operationIds[operation.OperationID] </span><span class="cov8" title="1">{
                                        result.Errors = append(result.Errors, ValidationError{
                                                Type:     "operations",
                                                Code:     "DUPLICATE_OPERATION_ID",
                                                Message:  fmt.Sprintf("Duplicate operation ID: %s", operation.OperationID),
                                                Path:     opPath,
                                                Severity: SeverityError,
                                        })
                                        result.Valid = false
                                }</span>
                                <span class="cov8" title="1">operationIds[operation.OperationID] = true</span>
                        }

                        // Check for missing descriptions
                        <span class="cov8" title="1">if operation.Description == "" &amp;&amp; operation.Summary == "" </span><span class="cov8" title="1">{
                                result.Warnings = append(result.Warnings, ValidationWarning{
                                        Type:       "operations",
                                        Code:       "MISSING_DESCRIPTION",
                                        Message:    fmt.Sprintf("Operation %s %s has no description", method, path),
                                        Path:       opPath,
                                        Suggestion: "Add description or summary to improve generated tool documentation",
                                })
                        }</span>

                        // Validate parameters
                        <span class="cov8" title="1">s.validateParameters(operation.Parameters, opPath, result)

                        // Validate responses
                        s.validateResponses(operation.Responses, opPath, result)</span>
                }
        }
}

// validateSchemas validates all schemas in the specification
func (s *Service) validateSchemas(spec *openapi3.T, result *ValidationResult) <span class="cov8" title="1">{
        if spec.Components == nil || spec.Components.Schemas == nil </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Type:       "schemas",
                        Code:       "NO_SCHEMAS",
                        Message:    "No schemas defined in the specification",
                        Path:       "/components/schemas",
                        Suggestion: "Define reusable schemas to improve specification maintainability",
                })
                return
        }</span>

        <span class="cov8" title="1">for name, schemaRef := range spec.Components.Schemas </span><span class="cov8" title="1">{
                if schemaRef.Value == nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, ValidationError{
                                Type:     "schemas",
                                Code:     "EMPTY_SCHEMA",
                                Message:  fmt.Sprintf("Schema '%s' has no definition", name),
                                Path:     fmt.Sprintf("/components/schemas/%s", name),
                                Severity: SeverityError,
                        })
                        result.Valid = false
                        continue</span>
                }

                <span class="cov8" title="1">schema := schemaRef.Value
                schemaPath := fmt.Sprintf("/components/schemas/%s", name)

                // Check for schemas without descriptions
                if schema.Description == "" </span><span class="cov8" title="1">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Type:       "schemas",
                                Code:       "MISSING_DESCRIPTION",
                                Message:    fmt.Sprintf("Schema '%s' has no description", name),
                                Path:       schemaPath,
                                Suggestion: "Add schema descriptions to improve documentation",
                        })
                }</span>

                // Validate schema properties
                <span class="cov8" title="1">s.validateSchemaProperties(schema, schemaPath, result)</span>
        }
}

// validateSecuritySchemes validates security schemes
func (s *Service) validateSecuritySchemes(spec *openapi3.T, result *ValidationResult) <span class="cov8" title="1">{
        if spec.Components == nil || spec.Components.SecuritySchemes == nil </span><span class="cov8" title="1">{
                result.Suggestions = append(result.Suggestions, 
                        "Consider adding security schemes if your API requires authentication")
                return
        }</span>

        <span class="cov0" title="0">for name, securitySchemeRef := range spec.Components.SecuritySchemes </span><span class="cov0" title="0">{
                if securitySchemeRef.Value == nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, ValidationError{
                                Type:     "security",
                                Code:     "EMPTY_SECURITY_SCHEME",
                                Message:  fmt.Sprintf("Security scheme '%s' has no definition", name),
                                Path:     fmt.Sprintf("/components/securitySchemes/%s", name),
                                Severity: SeverityError,
                        })
                        result.Valid = false
                }</span>
        }
}

// validateServers validates server configurations
func (s *Service) validateServers(spec *openapi3.T, result *ValidationResult) <span class="cov8" title="1">{
        if len(spec.Servers) == 0 </span><span class="cov8" title="1">{
                result.Suggestions = append(result.Suggestions, 
                        "Consider adding server information to specify the base URL")
                return
        }</span>

        <span class="cov0" title="0">for i, server := range spec.Servers </span><span class="cov0" title="0">{
                if server.URL == "" </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Type:       "servers",
                                Code:       "EMPTY_SERVER_URL",
                                Message:    fmt.Sprintf("Server #%d has no URL", i+1),
                                Path:       fmt.Sprintf("/servers[%d]", i),
                                Suggestion: "Provide a valid server URL",
                        })
                }</span>
        }
}

// validateExamples validates examples in the specification
func (s *Service) validateExamples(spec *openapi3.T, result *ValidationResult) {<span class="cov8" title="1">
        // This is a placeholder for example validation
        // In a real implementation, you would validate examples against schemas
}</span>

// validateReferences validates all $ref references in the specification
func (s *Service) validateReferences(spec *openapi3.T, result *ValidationResult) {<span class="cov8" title="1">
        // This is a placeholder for reference validation
        // In a real implementation, you would check that all references are valid
}</span>

// Helper methods for extracting information
func (s *Service) countOperations(spec *openapi3.T) int <span class="cov8" title="1">{
        if spec.Paths == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov8" title="1">count := 0
        for _, pathItem := range spec.Paths.Map() </span><span class="cov8" title="1">{
                if pathItem != nil </span><span class="cov8" title="1">{
                        count += len(pathItem.Operations())
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

func (s *Service) countSchemas(spec *openapi3.T) int <span class="cov8" title="1">{
        if spec.Components == nil || spec.Components.Schemas == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return len(spec.Components.Schemas)</span>
}

func (s *Service) extractSecuritySchemes(spec *openapi3.T) []SecuritySchemeInfo <span class="cov8" title="1">{
        var schemes []SecuritySchemeInfo
        
        if spec.Components == nil || spec.Components.SecuritySchemes == nil </span><span class="cov8" title="1">{
                return schemes
        }</span>
        
        <span class="cov0" title="0">for name, schemeRef := range spec.Components.SecuritySchemes </span><span class="cov0" title="0">{
                if schemeRef.Value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">scheme := schemeRef.Value
                info := SecuritySchemeInfo{
                        Type:        scheme.Type,
                        Name:        name,
                        Description: scheme.Description,
                }
                
                if scheme.In != "" </span><span class="cov0" title="0">{
                        info.In = scheme.In
                }</span>
                <span class="cov0" title="0">if scheme.Scheme != "" </span><span class="cov0" title="0">{
                        info.Scheme = scheme.Scheme
                }</span>
                <span class="cov0" title="0">if scheme.BearerFormat != "" </span><span class="cov0" title="0">{
                        info.BearerFormat = scheme.BearerFormat
                }</span>
                <span class="cov0" title="0">if scheme.OpenIdConnectUrl != "" </span><span class="cov0" title="0">{
                        info.OpenIDConnectURL = scheme.OpenIdConnectUrl
                }</span>
                
                <span class="cov0" title="0">schemes = append(schemes, info)</span>
        }
        
        <span class="cov0" title="0">return schemes</span>
}

func (s *Service) extractServers(spec *openapi3.T) []ServerInfo <span class="cov8" title="1">{
        var servers []ServerInfo
        
        for _, server := range spec.Servers </span><span class="cov0" title="0">{
                info := ServerInfo{
                        URL:         server.URL,
                        Description: server.Description,
                        Variables:   make(map[string]*ServerVariable),
                }
                
                for name, variable := range server.Variables </span><span class="cov0" title="0">{
                        info.Variables[name] = &amp;ServerVariable{
                                Default:     variable.Default,
                                Description: variable.Description,
                                Enum:        variable.Enum,
                        }
                }</span>
                
                <span class="cov0" title="0">servers = append(servers, info)</span>
        }
        
        <span class="cov8" title="1">return servers</span>
}

func (s *Service) extractTags(spec *openapi3.T) []TagInfo <span class="cov8" title="1">{
        var tags []TagInfo
        
        for _, tag := range spec.Tags </span><span class="cov0" title="0">{
                info := TagInfo{
                        Name:        tag.Name,
                        Description: tag.Description,
                }
                
                if tag.ExternalDocs != nil </span><span class="cov0" title="0">{
                        info.ExternalDocs = &amp;ExternalDocsInfo{
                                Description: tag.ExternalDocs.Description,
                                URL:         tag.ExternalDocs.URL,
                        }
                }</span>
                
                <span class="cov0" title="0">tags = append(tags, info)</span>
        }
        
        <span class="cov8" title="1">return tags</span>
}

func (s *Service) assessComplexity(spec *openapi3.T) ComplexityLevel <span class="cov8" title="1">{
        operationCount := s.countOperations(spec)
        schemaCount := s.countSchemas(spec)
        
        totalComplexity := operationCount + schemaCount
        
        if totalComplexity &gt; 100 </span><span class="cov8" title="1">{
                return ComplexityHigh
        }</span> else<span class="cov8" title="1"> if totalComplexity &gt; 20 </span><span class="cov8" title="1">{
                return ComplexityMedium
        }</span>
        <span class="cov8" title="1">return ComplexityLow</span>
}

func (s *Service) estimateSize(spec *openapi3.T) string <span class="cov8" title="1">{
        operationCount := s.countOperations(spec)
        
        if operationCount &gt; 100 </span><span class="cov0" title="0">{
                return "Large"
        }</span> else<span class="cov8" title="1"> if operationCount &gt; 20 </span><span class="cov0" title="0">{
                return "Medium"
        }</span>
        <span class="cov8" title="1">return "Small"</span>
}

// Additional validation helper methods
func (s *Service) validateParameters(params openapi3.Parameters, basePath string, result *ValidationResult) <span class="cov8" title="1">{
        for i, paramRef := range params </span><span class="cov0" title="0">{
                if paramRef.Value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">param := paramRef.Value
                paramPath := fmt.Sprintf("%s/parameters[%d]", basePath, i)
                
                if param.Description == "" </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Type:       "parameters",
                                Code:       "MISSING_DESCRIPTION",
                                Message:    fmt.Sprintf("Parameter '%s' has no description", param.Name),
                                Path:       paramPath,
                                Suggestion: "Add parameter descriptions to improve usability",
                        })
                }</span>
        }
}

func (s *Service) validateResponses(responses *openapi3.Responses, basePath string, result *ValidationResult) <span class="cov8" title="1">{
        if responses == nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Type:       "responses",
                        Code:       "NO_RESPONSES",
                        Message:    "No responses defined",
                        Path:       fmt.Sprintf("%s/responses", basePath),
                        Suggestion: "Define response schemas to improve API documentation",
                })
                return
        }</span>

        // Check for missing success responses
        <span class="cov8" title="1">hasSuccessResponse := false
        for status := range responses.Map() </span><span class="cov8" title="1">{
                if strings.HasPrefix(status, "2") </span><span class="cov8" title="1">{
                        hasSuccessResponse = true
                        break</span>
                }
        }
        
        <span class="cov8" title="1">if !hasSuccessResponse </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Type:       "responses",
                        Code:       "NO_SUCCESS_RESPONSE",
                        Message:    "No success response (2xx) defined",
                        Path:       fmt.Sprintf("%s/responses", basePath),
                        Suggestion: "Add success response definitions",
                })
        }</span>
}

func (s *Service) validateSchemaProperties(schema *openapi3.Schema, schemaPath string, result *ValidationResult) <span class="cov8" title="1">{
        // Validate required properties exist
        for _, required := range schema.Required </span><span class="cov8" title="1">{
                if schema.Properties == nil || schema.Properties[required] == nil </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, ValidationError{
                                Type:     "schemas",
                                Code:     "MISSING_REQUIRED_PROPERTY",
                                Message:  fmt.Sprintf("Required property '%s' is not defined", required),
                                Path:     fmt.Sprintf("%s/properties", schemaPath),
                                Severity: SeverityError,
                        })
                        result.Valid = false
                }</span>
        }
}

// generateSuggestions generates helpful suggestions based on the specification
func (s *Service) generateSuggestions(spec *openapi3.T, result *ValidationResult) <span class="cov8" title="1">{
        // Check for large specifications
        if s.countOperations(spec) &gt; 50 </span><span class="cov0" title="0">{
                result.Suggestions = append(result.Suggestions, 
                        "Large specifications may result in many MCP tools. Consider grouping related operations")
        }</span>
        
        // Check for missing base URL
        <span class="cov8" title="1">if len(spec.Servers) == 0 </span><span class="cov8" title="1">{
                result.Suggestions = append(result.Suggestions, 
                        "Consider adding server information to specify the base URL")
        }</span>
        
        // Check for missing OpenAPI version
        <span class="cov8" title="1">if spec.OpenAPI == "" </span><span class="cov0" title="0">{
                result.Suggestions = append(result.Suggestions, 
                        "Specify the OpenAPI version for better compatibility")
        }</span>
}

// getParsingErrorSuggestions returns suggestions for parsing errors
func (s *Service) getParsingErrorSuggestions(err error) []string <span class="cov8" title="1">{
        errorStr := err.Error()
        var suggestions []string
        
        if strings.Contains(errorStr, "array schema") </span><span class="cov0" title="0">{
                suggestions = append(suggestions, 
                        "Consider simplifying array schemas to use standard 'items' object definitions")
        }</span>
        <span class="cov8" title="1">if strings.Contains(errorStr, "regex") </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Remove or simplify regex patterns with unsupported features like lookaheads")
        }</span>
        <span class="cov8" title="1">if strings.Contains(errorStr, "OpenAPI 2.0") </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Convert your specification to OpenAPI 3.0+ format")
        }</span>
        <span class="cov8" title="1">if strings.Contains(errorStr, "YAML") </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Check YAML syntax and indentation")
        }</span>
        <span class="cov8" title="1">if strings.Contains(errorStr, "JSON") </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Check JSON syntax and structure")
        }</span>
        
        <span class="cov8" title="1">return suggestions</span>
}

// getNetworkErrorSuggestions returns suggestions for network errors
func (s *Service) getNetworkErrorSuggestions(err error) []string <span class="cov8" title="1">{
        errorStr := err.Error()
        var suggestions []string
        
        if strings.Contains(errorStr, "HTTP error") </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Check if the URL is accessible and returns a valid OpenAPI specification")
        }</span>
        <span class="cov8" title="1">if strings.Contains(errorStr, "timeout") </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "The server may be slow to respond. Try again or check the URL")
        }</span>
        <span class="cov8" title="1">if strings.Contains(errorStr, "connection") </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Check your internet connection and firewall settings")
        }</span>
        
        <span class="cov8" title="1">return suggestions</span>
}</pre>
		
		<pre class="file" id="file27" style="display: none">package main

import (
        "context"
        "embed"

        "MCPWeaver/internal/app"
        "github.com/wailsapp/wails/v2"
        "github.com/wailsapp/wails/v2/pkg/options"
        "github.com/wailsapp/wails/v2/pkg/options/assetserver"
)

//go:embed all:frontend/dist
var assets embed.FS

func main() <span class="cov0" title="0">{
        // Create an instance of the app structure
        application := app.NewApp()

        // Create application with options
        err := wails.Run(&amp;options.App{
                Title:            "MCPWeaver",
                Width:            1200,
                Height:           800,
                MinWidth:         800,
                MinHeight:        600,
                MaxWidth:         0,
                MaxHeight:        0,
                DisableResize:    false,
                Fullscreen:       false,
                Frameless:        false,
                StartHidden:      false,
                HideWindowOnClose: false,
                AssetServer: &amp;assetserver.Options{
                        Assets: assets,
                },
                BackgroundColour: &amp;options.RGBA{R: 27, G: 38, B: 54, A: 1},
                OnStartup:        func(ctx context.Context) </span><span class="cov0" title="0">{ application.OnStartup(ctx) }</span>,
                OnDomReady:       application.OnDomReady,
                OnBeforeClose:    application.OnBeforeClose,
                OnShutdown:       func(ctx context.Context) <span class="cov0" title="0">{ application.OnShutdown(ctx) }</span>,
                WindowStartState: options.Normal,
                Bind: []interface{}{
                        application,
                },
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                println("Error:", err.Error())
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
