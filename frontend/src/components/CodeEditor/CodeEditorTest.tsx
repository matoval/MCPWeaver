import React, { useState } from 'react';
import { CodeEditorDashboard } from './index';
import type { FileTreeNode } from './index';

// Sample generated files for testing
const sampleFiles: FileTreeNode[] = [
  {
    id: 'main',
    name: 'main.go',
    type: 'file',
    path: '/output/main.go',
    language: 'go',
    size: 1234,
    lastModified: new Date(),
    content: `package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/sourcegraph/jsonrpc2"
)

// MCPServer represents an MCP server instance
type MCPServer struct {
	name    string
	version string
	tools   []Tool
}

// Tool represents an MCP tool
type Tool struct {
	Name        string \`json:"name"\`
	Description string \`json:"description"\`
	InputSchema Schema \`json:"input_schema"\`
}

// Schema represents a JSON schema
type Schema struct {
	Type       string            \`json:"type"\`
	Properties map[string]Schema \`json:"properties,omitempty"\`
	Required   []string          \`json:"required,omitempty"\`
}

func main() {
	server := &MCPServer{
		name:    "generated-mcp-server",
		version: "1.0.0",
		tools:   []Tool{},
	}

	fmt.Printf("Starting MCP Server: %s v%s\\n", server.name, server.version)
	
	// Start the server
	if err := server.Start(); err != nil {
		log.Fatal("Failed to start server:", err)
	}
}

// Start starts the MCP server
func (s *MCPServer) Start() error {
	handler := jsonrpc2.HandlerWithError(s.handleRequest)
	
	conn, err := jsonrpc2.NewConn(
		context.Background(),
		jsonrpc2.NewBufferedStream(os.Stdin, os.Stdout),
		handler,
	)
	if err != nil {
		return fmt.Errorf("failed to create connection: %w", err)
	}

	<-conn.DisconnectNotify()
	return nil
}

// handleRequest handles incoming JSON-RPC requests
func (s *MCPServer) handleRequest(ctx context.Context, conn *jsonrpc2.Conn, req *jsonrpc2.Request) (interface{}, error) {
	switch req.Method {
	case "initialize":
		return s.handleInitialize(req.Params)
	case "tools/list":
		return s.handleToolsList()
	case "tools/call":
		return s.handleToolsCall(req.Params)
	default:
		return nil, &jsonrpc2.Error{
			Code:    jsonrpc2.CodeMethodNotFound,
			Message: fmt.Sprintf("method %s not found", req.Method),
		}
	}
}

// handleInitialize handles the initialize request
func (s *MCPServer) handleInitialize(params *json.RawMessage) (interface{}, error) {
	return map[string]interface{}{
		"protocolVersion": "2024-11-05",
		"serverInfo": map[string]interface{}{
			"name":    s.name,
			"version": s.version,
		},
		"capabilities": map[string]interface{}{
			"tools": map[string]interface{}{},
		},
	}, nil
}

// handleToolsList handles the tools/list request
func (s *MCPServer) handleToolsList() (interface{}, error) {
	return map[string]interface{}{
		"tools": s.tools,
	}, nil
}

// handleToolsCall handles the tools/call request
func (s *MCPServer) handleToolsCall(params *json.RawMessage) (interface{}, error) {
	var request struct {
		Name      string                 \`json:"name"\`
		Arguments map[string]interface{} \`json:"arguments"\`
	}

	if err := json.Unmarshal(*params, &request); err != nil {
		return nil, &jsonrpc2.Error{
			Code:    jsonrpc2.CodeParseError,
			Message: "invalid request parameters",
		}
	}

	// Handle tool execution here
	return map[string]interface{}{
		"content": []map[string]interface{}{
			{
				"type": "text",
				"text": fmt.Sprintf("Tool %s executed successfully", request.Name),
			},
		},
	}, nil
}`
  },
  {
    id: 'gomod',
    name: 'go.mod',
    type: 'file',
    path: '/output/go.mod',
    language: 'go',
    size: 256,
    lastModified: new Date(),
    content: `module generated-mcp-server

go 1.21

require (
	github.com/sourcegraph/jsonrpc2 v0.2.0
)

require (
	github.com/gorilla/websocket v1.5.0 // indirect
)`
  },
  {
    id: 'readme',
    name: 'README.md',
    type: 'file',
    path: '/output/README.md',
    language: 'markdown',
    size: 512,
    lastModified: new Date(),
    content: `# Generated MCP Server

This MCP server provides tools to interact with the API through the Model Context Protocol.

## Available Tools

1. **example-tool** - Example tool description
   - Required parameters: param1, param2

## Usage

1. Build the server:
   \`\`\`bash
   go build -o generated-mcp-server main.go
   \`\`\`

2. Use with an MCP client (like Claude Desktop):
   \`\`\`bash
   ./generated-mcp-server
   \`\`\`

## API Base URL

This server connects to: https://api.example.com

## Generated by

MCPWeaver - Desktop OpenAPI to MCP Server Generator`
  },
  {
    id: 'docs',
    name: 'docs',
    type: 'directory',
    path: '/output/docs',
    children: [
      {
        id: 'api-docs',
        name: 'api.md',
        type: 'file',
        path: '/output/docs/api.md',
        language: 'markdown',
        size: 128,
        lastModified: new Date(),
        content: '# API Documentation\n\nGenerated API documentation...'
      }
    ]
  },
  {
    id: 'dockerfile',
    name: 'Dockerfile',
    type: 'file',
    path: '/output/Dockerfile',
    language: 'dockerfile',
    size: 384,
    lastModified: new Date(),
    content: `# Multi-stage build for Generated MCP Server
FROM golang:1.21-alpine AS builder

# Set working directory
WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the server
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o server main.go

# Final stage
FROM alpine:latest

# Install ca-certificates for HTTPS requests
RUN apk --no-cache add ca-certificates

# Set working directory
WORKDIR /root/

# Copy the binary from builder stage
COPY --from=builder /app/server .

# Expose port (if needed)
EXPOSE 8080

# Run the server
CMD ["./server"]`
  }
];

const CodeEditorTest: React.FC = () => {
  const [projectId] = useState('test-project-123');

  const handleFileChange = (file: FileTreeNode, content: string) => {
    console.log('File changed:', file.name, content.length, 'characters');
  };

  const handleFileSave = (file: FileTreeNode, content: string) => {
    console.log('File saved:', file.name, content.length, 'characters');
  };

  const handleFileValidate = (file: FileTreeNode, isValid: boolean, errors: string[]) => {
    console.log('File validation:', file.name, isValid ? 'valid' : 'invalid', errors);
  };

  return (
    <div style={{ height: '100vh', width: '100vw' }}>
      <CodeEditorDashboard
        projectId={projectId}
        generatedFiles={sampleFiles}
        onFileChange={handleFileChange}
        onFileSave={handleFileSave}
        onFileValidate={handleFileValidate}
      />
    </div>
  );
};

export default CodeEditorTest;