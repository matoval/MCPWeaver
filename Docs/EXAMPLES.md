# Input/Output Examples

## Overview

This document provides comprehensive examples of how MCPWeaver transforms OpenAPI specifications into Model Context Protocol (MCP) servers. Each example demonstrates different features and complexity levels to illustrate the tool's capabilities and decision-making process.

## Basic Examples

### Simple REST API

#### Input OpenAPI Specification

```yaml
# simple-api.yaml
openapi: 3.0.0
info:
  title: User Management API
  version: 1.0.0
  description: Simple API for managing users
servers:
  - url: https://api.example.com/v1
    description: Production server
paths:
  /users:
    get:
      operationId: listUsers
      summary: List all users
      description: Retrieve a paginated list of users
      parameters:
        - name: limit
          in: query
          description: Number of users to return
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 10
        - name: offset
          in: query
          description: Number of users to skip
          schema:
            type: integer
            minimum: 0
            default: 0
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: object
                properties:
                  users:
                    type: array
                    items:
                      $ref: '#/components/schemas/User'
                  total:
                    type: integer
    post:
      operationId: createUser
      summary: Create new user
      description: Create a new user account
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserCreate'
      responses:
        '201':
          description: User created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
  /users/{id}:
    get:
      operationId: getUser
      summary: Get user by ID
      description: Retrieve a specific user by their ID
      parameters:
        - name: id
          in: path
          required: true
          description: User ID
          schema:
            type: integer
            minimum: 1
      responses:
        '200':
          description: User found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          description: User not found
components:
  schemas:
    User:
      type: object
      required:
        - id
        - name
        - email
      properties:
        id:
          type: integer
          description: Unique user identifier
        name:
          type: string
          description: User's full name
          minLength: 1
          maxLength: 100
        email:
          type: string
          format: email
          description: User's email address
        created_at:
          type: string
          format: date-time
          description: Account creation timestamp
    UserCreate:
      type: object
      required:
        - name
        - email
      properties:
        name:
          type: string
          minLength: 1
          maxLength: 100
        email:
          type: string
          format: email
```

#### Generated MCP Server Output

##### server.py

```python
"""
User Management API MCP Server
Generated by MCPWeaver from OpenAPI specification
"""

import httpx
import json
from typing import Any, Dict, List, Optional
from mcp import Server
from mcp.types import TextContent, Tool

# Initialize MCP server
server = Server("user-management-api")

# Base URL for API requests
BASE_URL = "https://api.example.com/v1"

# HTTP client configuration
client = httpx.AsyncClient(
    base_url=BASE_URL,
    timeout=30.0,
    headers={
        # TODO: Add authentication headers here
        # "Authorization": "Bearer YOUR_TOKEN",
        # "X-API-Key": "YOUR_API_KEY",
    }
)

@server.tool()
async def list_users(limit: Optional[int] = 10, offset: Optional[int] = 0) -> List[TextContent]:
    """List all users
    
    Retrieve a paginated list of users
    
    Args:
        limit: Number of users to return (1-100, default: 10)
        offset: Number of users to skip (minimum: 0, default: 0)
    
    Returns:
        List of users with pagination info
    """
    try:
        # Validate parameters
        if limit is not None and (limit < 1 or limit > 100):
            return [TextContent(type="text", text="Error: limit must be between 1 and 100")]
        if offset is not None and offset < 0:
            return [TextContent(type="text", text="Error: offset must be non-negative")]
        
        # Build query parameters
        params = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        
        # Make API request
        response = await client.get("/users", params=params)
        response.raise_for_status()
        
        # Format response
        data = response.json()
        result = f"Found {data.get('total', 0)} users (showing {len(data.get('users', []))}):\n\n"
        
        for user in data.get('users', []):
            result += f"â€¢ {user.get('name')} ({user.get('email')}) - ID: {user.get('id')}\n"
        
        return [TextContent(type="text", text=result)]
        
    except httpx.HTTPStatusError as e:
        return [TextContent(type="text", text=f"HTTP Error {e.response.status_code}: {e.response.text}")]
    except Exception as e:
        return [TextContent(type="text", text=f"Error: {str(e)}")]

@server.tool()
async def create_user(name: str, email: str) -> List[TextContent]:
    """Create new user
    
    Create a new user account
    
    Args:
        name: User's full name (1-100 characters)
        email: User's email address (valid email format)
    
    Returns:
        Created user information
    """
    try:
        # Validate parameters
        if not name or len(name.strip()) < 1 or len(name) > 100:
            return [TextContent(type="text", text="Error: name must be 1-100 characters")]
        if not email or "@" not in email:
            return [TextContent(type="text", text="Error: invalid email format")]
        
        # Prepare request body
        user_data = {
            "name": name.strip(),
            "email": email.strip().lower()
        }
        
        # Make API request
        response = await client.post("/users", json=user_data)
        response.raise_for_status()
        
        # Format response
        user = response.json()
        result = f"User created successfully!\n\n"
        result += f"ID: {user.get('id')}\n"
        result += f"Name: {user.get('name')}\n"
        result += f"Email: {user.get('email')}\n"
        result += f"Created: {user.get('created_at', 'N/A')}\n"
        
        return [TextContent(type="text", text=result)]
        
    except httpx.HTTPStatusError as e:
        return [TextContent(type="text", text=f"HTTP Error {e.response.status_code}: {e.response.text}")]
    except Exception as e:
        return [TextContent(type="text", text=f"Error: {str(e)}")]

@server.tool()
async def get_user(id: int) -> List[TextContent]:
    """Get user by ID
    
    Retrieve a specific user by their ID
    
    Args:
        id: User ID (minimum: 1)
    
    Returns:
        User information
    """
    try:
        # Validate parameters
        if id < 1:
            return [TextContent(type="text", text="Error: user ID must be positive")]
        
        # Make API request
        response = await client.get(f"/users/{id}")
        response.raise_for_status()
        
        # Format response
        user = response.json()
        result = f"User Details:\n\n"
        result += f"ID: {user.get('id')}\n"
        result += f"Name: {user.get('name')}\n"
        result += f"Email: {user.get('email')}\n"
        result += f"Created: {user.get('created_at', 'N/A')}\n"
        
        return [TextContent(type="text", text=result)]
        
    except httpx.HTTPStatusError as e:
        if e.response.status_code == 404:
            return [TextContent(type="text", text=f"User with ID {id} not found")]
        return [TextContent(type="text", text=f"HTTP Error {e.response.status_code}: {e.response.text}")]
    except Exception as e:
        return [TextContent(type="text", text=f"Error: {str(e)}")]

# Cleanup function
async def cleanup():
    """Close HTTP client on shutdown"""
    await client.aclose()

if __name__ == "__main__":
    import asyncio
    import signal
    
    def signal_handler(signum, frame):
        asyncio.create_task(cleanup())
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    server.run()
```

##### test_server.py

```python
"""
Test suite for User Management API MCP Server
Generated by MCPWeaver
"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch
from mcp.types import TextContent
import httpx

# Import server functions
from server import list_users, create_user, get_user

class TestUserManagementAPI:
    """Test cases for User Management API MCP tools"""
    
    @pytest.mark.asyncio
    async def test_list_users_success(self):
        """Test successful user listing"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "users": [
                {"id": 1, "name": "John Doe", "email": "john@example.com"},
                {"id": 2, "name": "Jane Smith", "email": "jane@example.com"}
            ],
            "total": 2
        }
        mock_response.raise_for_status = Mock()
        
        with patch('server.client.get', return_value=mock_response):
            result = await list_users(limit=10, offset=0)
            
            assert len(result) == 1
            assert isinstance(result[0], TextContent)
            assert "Found 2 users" in result[0].text
            assert "John Doe" in result[0].text
            assert "Jane Smith" in result[0].text
    
    @pytest.mark.asyncio
    async def test_list_users_invalid_limit(self):
        """Test list_users with invalid limit parameter"""
        result = await list_users(limit=150)  # Over maximum
        
        assert len(result) == 1
        assert "Error: limit must be between 1 and 100" in result[0].text
    
    @pytest.mark.asyncio
    async def test_create_user_success(self):
        """Test successful user creation"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "id": 123,
            "name": "Test User",
            "email": "test@example.com",
            "created_at": "2024-01-01T12:00:00Z"
        }
        mock_response.raise_for_status = Mock()
        
        with patch('server.client.post', return_value=mock_response):
            result = await create_user(name="Test User", email="test@example.com")
            
            assert len(result) == 1
            assert "User created successfully!" in result[0].text
            assert "ID: 123" in result[0].text
            assert "Test User" in result[0].text
    
    @pytest.mark.asyncio
    async def test_create_user_invalid_email(self):
        """Test create_user with invalid email"""
        result = await create_user(name="Test User", email="invalid-email")
        
        assert len(result) == 1
        assert "Error: invalid email format" in result[0].text
    
    @pytest.mark.asyncio
    async def test_get_user_success(self):
        """Test successful user retrieval"""
        mock_response = Mock()
        mock_response.json.return_value = {
            "id": 123,
            "name": "Test User",
            "email": "test@example.com",
            "created_at": "2024-01-01T12:00:00Z"
        }
        mock_response.raise_for_status = Mock()
        
        with patch('server.client.get', return_value=mock_response):
            result = await get_user(id=123)
            
            assert len(result) == 1
            assert "User Details:" in result[0].text
            assert "ID: 123" in result[0].text
            assert "Test User" in result[0].text
    
    @pytest.mark.asyncio
    async def test_get_user_not_found(self):
        """Test get_user with non-existent user"""
        mock_response = Mock()
        mock_response.raise_for_status.side_effect = httpx.HTTPStatusError(
            "Not Found", request=Mock(), response=Mock(status_code=404)
        )
        
        with patch('server.client.get', return_value=mock_response):
            result = await get_user(id=999)
            
            assert len(result) == 1
            assert "User with ID 999 not found" in result[0].text
    
    @pytest.mark.asyncio
    async def test_get_user_invalid_id(self):
        """Test get_user with invalid ID parameter"""
        result = await get_user(id=0)  # Invalid ID
        
        assert len(result) == 1
        assert "Error: user ID must be positive" in result[0].text

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

##### README.md

```markdown
  # User Management API MCP Server

  This MCP server provides integration with the User Management API, allowing AI assistants to interact with user data through the Model Context Protocol.

  ## Generated Tools

  - **list_users**: Retrieve a paginated list of users
  - **create_user**: Create a new user account  
  - **get_user**: Get user details by ID

  ## Setup

  1. Install dependencies:
    ```bash
    pip install -r requirements.txt
    ```

  2. Configure authentication:
    Edit `server.py` and add your API credentials:

    ```python
    headers={
        "Authorization": "Bearer YOUR_TOKEN",
        # or
        "X-API-Key": "YOUR_API_KEY",
    }
    ```

  3. Run the server:

    ```bash
    python server.py

```

## Testing

Run the test suite:

```bash
pytest test_server.py -v
```

## API Reference

### list_users(limit=10, offset=0)

Retrieve users with optional pagination.

**Parameters:**

- `limit` (int, optional): Number of users (1-100, default: 10)
- `offset` (int, optional): Skip count (â‰¥0, default: 0)

### create_user(name, email)

Create a new user account.

**Parameters:**

- `name` (str, required): Full name (1-100 characters)
- `email` (str, required): Valid email address

### get_user(id)

Get user by ID.

**Parameters:**

- `id` (int, required): User ID (>0)

## Configuration

The server connects to: `https://api.example.com/v1`

To change the base URL, modify the `BASE_URL` constant in `server.py`.

## Error Handling

All tools include comprehensive error handling:

- Parameter validation
- HTTP status code handling  
- Network error recovery
- Clear error messages

## Generated by MCPWeaver

This MCP server was automatically generated from an OpenAPI specification using [MCPWeaver](https://github.com/matoval/MCPWeaver).

```bash

##### requirements.txt

```text
mcp==1.0.0
httpx==0.25.0
pytest==7.4.0
pytest-asyncio==0.21.0
```

## Complex Example

### E-commerce API with Authentication

#### Input OpenAPI Specification file

```yaml
# ecommerce-api.yaml  
openapi: 3.0.0
info:
  title: E-commerce API
  version: 2.1.0
  description: Advanced e-commerce platform API
servers:
  - url: https://api.ecommerce.com/v2
security:
  - ApiKeyAuth: []
  - BearerAuth: []
paths:
  /products:
    get:
      summary: Search products
      description: Search and filter products with advanced options
      parameters:
        - name: query
          in: query
          description: Search query string
          schema:
            type: string
            maxLength: 200
        - name: category
          in: query
          description: Product category filter
          schema:
            type: string
            enum: [electronics, clothing, books, home, sports]
        - name: min_price
          in: query
          description: Minimum price filter
          schema:
            type: number
            minimum: 0
        - name: max_price  
          in: query
          description: Maximum price filter
          schema:
            type: number
            minimum: 0
        - name: sort
          in: query
          description: Sort order
          schema:
            type: string
            enum: [price_asc, price_desc, name_asc, rating_desc, created_desc]
            default: created_desc
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
      responses:
        '200':
          description: Product search results
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductSearchResponse'
    post:
      summary: Create product
      description: Create a new product (admin only)
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ProductCreate'
      responses:
        '201':
          description: Product created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Product'
  /orders:
    post:
      summary: Create order
      description: Create a new order with multiple items
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OrderCreate'
      responses:
        '201':
          description: Order created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
components:
  securitySchemes:
    ApiKeyAuth:
      type: apiKey
      in: header
      name: X-API-Key
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    Product:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        description:
          type: string
        price:
          type: number
          format: decimal
        category:
          type: string
        in_stock:
          type: boolean
        rating:
          type: number
          minimum: 0
          maximum: 5
    ProductCreate:
      type: object
      required: [name, price, category]
      properties:
        name:
          type: string
          minLength: 1
          maxLength: 200
        description:
          type: string
          maxLength: 2000
        price:
          type: number
          minimum: 0.01
        category:
          type: string
          enum: [electronics, clothing, books, home, sports]
    ProductSearchResponse:
      type: object
      properties:
        products:
          type: array
          items:
            $ref: '#/components/schemas/Product'
        total:
          type: integer
        page:
          type: integer
        per_page:
          type: integer
    OrderCreate:
      type: object
      required: [items, shipping_address]
      properties:
        items:
          type: array
          minItems: 1
          items:
            type: object
            required: [product_id, quantity]
            properties:
              product_id:
                type: integer
              quantity:
                type: integer
                minimum: 1
        shipping_address:
          $ref: '#/components/schemas/Address'
        notes:
          type: string
          maxLength: 500
    Order:
      type: object
      properties:
        id:
          type: integer
        items:
          type: array
          items:
            type: object
        total_amount:
          type: number
        status:
          type: string
        created_at:
          type: string
          format: date-time
    Address:
      type: object
      required: [street, city, country, postal_code]
      properties:
        street:
          type: string
        city:
          type: string
        country:
          type: string
        postal_code:
          type: string
```

#### Expected Generated Output Structure

This complex example would generate:

1. **Enhanced server.py** with:
   - Multiple authentication options (API key and Bearer token)
   - Complex parameter validation
   - Enum validation for categories and sort options
   - Nested object handling for orders and addresses
   - Advanced error handling for business logic

2. **Comprehensive test_server.py** with:
   - Test cases for all parameter combinations
   - Authentication testing scenarios
   - Edge cases for complex data structures
   - Mock responses for different business scenarios

3. **Detailed README.md** with:
   - Authentication setup instructions
   - Parameter documentation with examples
   - Business logic explanations
   - Integration examples

## Command Line Usage Examples

### Basic Generation

```bash
# Generate MCP server from simple API
$ mcpweaver generate simple-api.yaml

Processing OpenAPI specification...
âœ“ Parsing specification (simple-api.yaml)
âœ“ Validating OpenAPI format
âœ“ Found 3 endpoints

Select endpoints to include:
 âœ“ GET /users - List all users
 âœ“ POST /users - Create new user
 âœ“ GET /users/{id} - Get user by ID

[a] Select all  [n] Select none  [Enter] Continue

âœ“ Generating MCP server code
âœ“ Creating test suite  
âœ“ Writing documentation

Generation complete! Files created:
  server.py - FastMCP server (3 tools)
  test_server.py - Test suite with 12 test cases
  README.md - Setup and usage documentation
  requirements.txt - Python dependencies
```

### Custom Output Directory

```bash
# Generate in specific directory
$ mcpweaver generate ecommerce-api.yaml --output ./ecommerce-server

Processing OpenAPI specification...
âœ“ Parsing specification (ecommerce-api.yaml)
âœ“ Validating OpenAPI format
âœ“ Found 3 endpoints

Authentication detected: ApiKeyAuth, BearerAuth
Using primary auth method: ApiKeyAuth

Generation complete! Files created in ./ecommerce-server/:
  server.py - FastMCP server with authentication (3 tools)
  test_server.py - Test suite with mocked auth
  README.md - Setup guide with auth configuration
  requirements.txt - Dependencies including auth libraries
```

### Verbose Mode Output

```bash
# Detailed processing information
$ mcpweaver generate simple-api.yaml --verbose

[DEBUG] Starting MCPWeaver v1.0.0
[DEBUG] Loading OpenAPI specification: simple-api.yaml
[DEBUG] File size: 2.1KB, Format: YAML
[INFO]  Parsing OpenAPI 3.0.0 specification
[DEBUG] Found info: User Management API v1.0.0  
[DEBUG] Found 1 server: https://api.example.com/v1
[DEBUG] Found 2 paths with 3 operations total
[INFO]  Validating OpenAPI specification
[DEBUG] Validating schemas: User, UserCreate
[DEBUG] Validating responses for 3 operations
[INFO]  Extracting MCP tools
[DEBUG] Processing GET /users -> list_users
[DEBUG]   Parameters: limit (query, optional), offset (query, optional)
[DEBUG]   Response: 200 with User array schema
[DEBUG] Processing POST /users -> create_user  
[DEBUG]   Request body: UserCreate schema
[DEBUG]   Response: 201 with User schema
[DEBUG] Processing GET /users/{id} -> get_user
[DEBUG]   Parameters: id (path, required)
[DEBUG]   Response: 200 with User schema, 404 error case
[INFO]  Generating Python FastMCP server
[DEBUG] Template: fastmcp/server.py.tmpl
[DEBUG] Generated 156 lines of Python code
[DEBUG] Added HTTP client with httpx
[DEBUG] Added parameter validation for all tools
[INFO]  Generating test suite
[DEBUG] Template: fastmcp/test.py.tmpl  
[DEBUG] Generated 89 lines of test code
[DEBUG] Added 12 test cases with mocked responses
[INFO]  Writing documentation
[DEBUG] Template: fastmcp/readme.md.tmpl
[DEBUG] Generated setup guide and API reference
[INFO]  Generation completed successfully
[DEBUG] Total processing time: 1.2s
```

## Error Handling Examples

### Invalid OpenAPI Specification

```bash
$ mcpweaver generate broken-api.yaml

Error: Invalid OpenAPI specification
  File: broken-api.yaml
  Line: 15
  Issue: Missing required 'responses' field for GET /users

  The OpenAPI specification requires all operations to define response schemas.
  Add a 'responses' section like this:
  
  responses:
    '200':
      description: Success
      content:
        application/json:
          schema:
            # Your response schema here
```

### File Not Found

```bash
$ mcpweaver generate missing-file.yaml

Error: File not found
  Path: missing-file.yaml
  
  Please check that the file path is correct and the file exists.
  Supported formats: YAML (.yaml, .yml) and JSON (.json)
```

### Complex Schema Warnings

```bash
$ mcpweaver generate complex-api.yaml

Processing OpenAPI specification...
âœ“ Parsing specification (complex-api.yaml)
âœ“ Validating OpenAPI format

Warning: Recursive schema 'Category' detected at line 45
  Simplified to 'dict' type in generated code
  Manual review recommended for complex nested structures

Warning: Multiple security schemes found (ApiKey, OAuth2, Basic)
  Using primary scheme: ApiKeyAuth
  Additional auth methods available as comments in generated code

âœ“ Found 8 endpoints (2 skipped due to warnings)

Generation complete with warnings!
Review the generated README.md for additional setup requirements.
```

## Design Decisions Summary

### Tool Naming Strategy

- **OpenAPI operationId**: Used when available (e.g., `listUsers` â†’ `list_users`)
- **HTTP method + path**: Generated when operationId missing (e.g., `GET /users` â†’ `get_users`)
- **Snake case conversion**: All tool names use Python conventions

### Parameter Handling

- **Path parameters**: Required function parameters with validation
- **Query parameters**: Optional function parameters with defaults
- **Request body**: Structured as required function parameters
- **Validation**: Client-side validation with descriptive error messages

### Authentication Strategy

- **Primary method**: Use first authentication scheme in OpenAPI spec
- **Multiple methods**: Generate TODO comments for additional schemes
- **Configuration**: Placeholder code requiring user customization

### Error Response Strategy

- **HTTP errors**: Converted to descriptive text responses
- **Validation errors**: Client-side validation with clear messages
- **Network errors**: Graceful handling with retry suggestions
- **Business logic**: Preserve API error semantics

This comprehensive example set demonstrates MCPWeaver's capability to handle real-world OpenAPI specifications and generate production-ready MCP servers with proper validation, testing, and documentation.
